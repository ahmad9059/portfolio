import * as tracing_1 from "@effect-ts/core/Tracing";
const fileName_1 = "packages/@contentlayer/source-files/src/fetchData/mapping.ts";
import * as core from '@contentlayer/core';
import * as utils from '@contentlayer/utils';
import { identity, pipe, T } from '@contentlayer/utils/effect';
// Use legacy import format since somehow ESM export isn't properly picked up for `date-fns-tz`
import dateFnsTz from 'date-fns-tz';
import * as path from 'path';
import { FetchDataError } from '../errors/index.js';
import { getFromDocumentContext } from './DocumentContext.js';
export const makeDocument = ({ rawContent, documentTypeDef, coreSchemaDef, relativeFilePath, contentDirPath, options, }) => (T.mapError_(T.gen(function* ($) {
    const { bodyFieldName, typeFieldName } = options.fieldOptions;
    // const includeBody = documentTypeDef.fieldDefs.some(
    //   (_) => _.name === bodyFieldName && _.isSystemField,
    // )
    const body = utils.pattern
        .match(rawContent)
        .when(rawContentHasBody, (_) => _.body)
        .otherwise(() => undefined);
    const rawData = { ...rawContent.fields, [bodyFieldName]: body };
    const docValues = yield* $(T.forEachParDict_(documentTypeDef.fieldDefs, {
        mapValue: (fieldDef) => getDataForFieldDef({
            fieldDef,
            rawFieldData: rawData[fieldDef.name],
            coreSchemaDef,
            options,
            relativeFilePath,
            contentDirPath,
        }),
        mapKey: (fieldDef) => T.succeed(fieldDef.name, fileName_1 + ":60:42"),
    }), fileName_1 + ":49:33");
    const contentType = utils.pattern
        .match(rawContent.kind)
        .with('markdown', () => 'markdown')
        .with('mdx', () => 'mdx')
        .otherwise(() => 'data');
    const _raw = {
        sourceFilePath: relativeFilePath,
        sourceFileName: path.basename(relativeFilePath),
        sourceFileDir: path.dirname(relativeFilePath),
        contentType,
        flattenedPath: getFlattenedPath(relativeFilePath),
    };
    const doc = {
        ...docValues,
        _id: relativeFilePath,
        _raw,
        [typeFieldName]: documentTypeDef.name,
    };
    return doc;
}, fileName_1 + ":38:10"), (error) => error._tag === 'NoSuchNestedDocumentTypeError'
    ? error
    : new FetchDataError.UnexpectedError({ error, documentFilePath: relativeFilePath }), fileName_1 + ":87:15"));
const rawContentHasBody = (_) => 'body' in _ && _.body !== undefined;
export const getFlattenedPath = (relativeFilePath) => relativeFilePath
    // remove extension
    .split('.')
    .slice(0, -1)
    .join('.')
    // remove tailing `/index` or `index`
    .replace(/\/?index$/, '');
// TODO aggregate all "global" params into an effect service
const makeNestedDocument = ({ rawObjectData, fieldDefs, typeName, coreSchemaDef, options, relativeFilePath, contentDirPath, }) => T.gen(function* ($) {
    const objValues = yield* $(T.forEachParDict_(fieldDefs, {
        mapValue: (fieldDef) => getDataForFieldDef({
            fieldDef,
            rawFieldData: rawObjectData[fieldDef.name],
            coreSchemaDef,
            options,
            relativeFilePath,
            contentDirPath,
        }),
        mapKey: (fieldDef) => T.succeed(fieldDef.name, fileName_1 + ":142:40"),
    }), fileName_1 + ":131:31");
    const typeNameField = options.fieldOptions.typeFieldName;
    const obj = { ...objValues, [typeNameField]: typeName, _raw: {} };
    return obj;
}, fileName_1 + ":130:8");
const getDataForFieldDef = ({ fieldDef, rawFieldData, coreSchemaDef, options, relativeFilePath, contentDirPath, }) => T.gen(function* ($) {
    if (rawFieldData === undefined && fieldDef.default) {
        rawFieldData = fieldDef.default;
    }
    if (rawFieldData === undefined) {
        if (fieldDef.isRequired && !fieldDef.isSystemField) {
            console.error(`Inconsistent data found: ${JSON.stringify(fieldDef)}`);
        }
        return undefined;
    }
    switch (fieldDef.type) {
        case 'nested': {
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.nestedTypeName];
            return yield* $(makeNestedDocument({
                rawObjectData: rawFieldData,
                fieldDefs: nestedTypeDef.fieldDefs,
                typeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            }), fileName_1 + ":183:24");
        }
        case 'nested_unnamed':
            return yield* $(makeNestedDocument({
                rawObjectData: rawFieldData,
                fieldDefs: fieldDef.typeDef.fieldDefs,
                typeName: '__UNNAMED__',
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            }), fileName_1 + ":196:24");
        case 'nested_polymorphic': {
            const typeName = rawFieldData[fieldDef.typeField];
            if (!fieldDef.nestedTypeNames.includes(typeName)) {
                return yield* $(T.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
                    documentTypeName: typeName,
                    documentFilePath: relativeFilePath,
                    fieldName: fieldDef.name,
                    validNestedTypeNames: fieldDef.nestedTypeNames,
                }), fileName_1 + ":212:19"), fileName_1 + ":211:26");
            }
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[typeName];
            return yield* $(makeNestedDocument({
                rawObjectData: rawFieldData,
                fieldDefs: nestedTypeDef.fieldDefs,
                typeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            }), fileName_1 + ":225:24");
        }
        case 'reference':
        case 'reference_polymorphic':
            return rawFieldData;
        case 'list_polymorphic':
        case 'list':
            return yield* $(T.forEachPar_(rawFieldData, (rawItemData) => getDataForListItem({ rawItemData, fieldDef, coreSchemaDef, options, relativeFilePath, contentDirPath }), fileName_1 + ":243:24"), fileName_1 + ":242:24");
        case 'date':
            let dateValue = new Date(rawFieldData);
            if (options.date?.timezone) {
                dateValue = dateFnsTz.zonedTimeToUtc(dateValue, options.date.timezone);
            }
            return dateValue.toISOString();
        case 'markdown': {
            const isBodyField = fieldDef.name === options.fieldOptions.bodyFieldName;
            // NOTE for the body field, we're passing the entire document file contents to MDX (e.g. in case some remark/rehype plugins need access to the frontmatter)
            // TODO we should come up with a better way to do this
            if (isBodyField) {
                const rawContent = yield* $(getFromDocumentContext('rawContent'), fileName_1 + ":258:38");
                if (rawContent.kind !== 'markdown' && rawContent.kind !== 'mdx')
                    return utils.assertNever(rawContent);
                const html = yield* $(core.markdownToHtml({ mdString: rawContent.rawDocumentContent, options: options?.markdown }), fileName_1 + ":261:32");
                return { raw: rawFieldData, html };
            }
            else {
                const html = yield* $(core.markdownToHtml({ mdString: rawFieldData, options: options?.markdown }), fileName_1 + ":266:32");
                return { raw: rawFieldData, html };
            }
        }
        case 'mdx': {
            const isBodyField = fieldDef.name === options.fieldOptions.bodyFieldName;
            // NOTE for the body field, we're passing the entire document file contents to MDX (e.g. in case some remark/rehype plugins need access to the frontmatter)
            // TODO we should come up with a better way to do this
            if (isBodyField) {
                const rawContent = yield* $(getFromDocumentContext('rawContent'), fileName_1 + ":275:38");
                if (rawContent.kind !== 'mdx' && rawContent.kind !== 'markdown')
                    return utils.assertNever(rawContent);
                const code = yield* $(core.bundleMDX({ mdxString: rawContent.rawDocumentContent, options: options?.mdx, contentDirPath }), fileName_1 + ":278:32");
                return { raw: rawFieldData, code };
            }
            else {
                const code = yield* $(core.bundleMDX({ mdxString: rawFieldData, options: options?.mdx, contentDirPath }), fileName_1 + ":283:32");
                return { raw: rawFieldData, code };
            }
        }
        case 'boolean':
        case 'string':
        case 'number':
        case 'json':
        // case 'slug':
        // case 'text':
        // case 'url':
        case 'enum':
            // case 'image':
            return rawFieldData;
        default:
            utils.casesHandled(fieldDef);
    }
}, fileName_1 + ":167:8");
export const testOnly_getDataForFieldDef = getDataForFieldDef;
const getDataForListItem = ({ rawItemData, fieldDef, coreSchemaDef, options, relativeFilePath, contentDirPath, }) => {
    if (typeof rawItemData === 'string') {
        return T.succeed(rawItemData, fileName_1 + ":320:21");
    }
    if (fieldDef.type === 'list_polymorphic') {
        const nestedTypeName = rawItemData[fieldDef.typeField];
        const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[nestedTypeName];
        if (nestedTypeDef === undefined) {
            const validNestedTypeNames = fieldDef.of
                .filter((_) => _.type === 'nested')
                .map((_) => _.nestedTypeName);
            return T.fail(new FetchDataError.NoSuchNestedDocumentTypeError({
                documentTypeName: nestedTypeName,
                documentFilePath: relativeFilePath,
                fieldName: fieldDef.name,
                validNestedTypeNames,
            }), fileName_1 + ":331:20");
        }
        return makeNestedDocument({
            rawObjectData: rawItemData,
            fieldDefs: nestedTypeDef.fieldDefs,
            typeName: nestedTypeDef.name,
            coreSchemaDef,
            options,
            relativeFilePath,
            contentDirPath,
        });
    }
    switch (fieldDef.of.type) {
        case 'nested':
            const nestedTypeDef = coreSchemaDef.nestedTypeDefMap[fieldDef.of.nestedTypeName];
            return makeNestedDocument({
                rawObjectData: rawItemData,
                fieldDefs: nestedTypeDef.fieldDefs,
                typeName: nestedTypeDef.name,
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            });
        case 'nested_unnamed':
            return makeNestedDocument({
                rawObjectData: rawItemData,
                fieldDefs: fieldDef.of.typeDef.fieldDefs,
                typeName: '__UNNAMED__',
                coreSchemaDef,
                options,
                relativeFilePath,
                contentDirPath,
            });
        case 'boolean':
        case 'enum':
        case 'reference':
        case 'string':
            return T.succeed(rawItemData, fileName_1 + ":377:23");
        default:
            return utils.casesHandled(fieldDef.of);
    }
};
//# sourceMappingURL=mapping.js.map