var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var schedule_exports = {};
__export(schedule_exports, {
  Schedule: () => Schedule,
  addDelay: () => addDelay,
  addDelayM: () => addDelayM,
  addDelayM_: () => addDelayM_,
  addDelay_: () => addDelay_,
  andThen: () => andThen,
  andThenEither: () => andThenEither,
  andThenEither_: () => andThenEither_,
  andThen_: () => andThen_,
  as: () => as,
  bothInOut: () => bothInOut,
  bothInOut_: () => bothInOut_,
  check: () => check,
  checkM: () => checkM,
  checkM_: () => checkM_,
  check_: () => check_,
  choose: () => choose,
  chooseMerge: () => chooseMerge,
  chooseMerge_: () => chooseMerge_,
  choose_: () => choose_,
  collectAll: () => collectAll,
  collectAllIdentity: () => collectAllIdentity,
  compose: () => compose,
  compose_: () => compose_,
  contramap: () => contramap,
  contramap_: () => contramap_,
  count: () => count,
  delayed: () => delayed,
  delayedFrom: () => delayedFrom,
  delayedM: () => delayedM,
  delayedM_: () => delayedM_,
  delayed_: () => delayed_,
  dimap: () => dimap,
  dimap_: () => dimap_,
  driver: () => driver,
  duration: () => duration,
  durations: () => durations,
  elapsed: () => elapsed,
  ensuring: () => ensuring,
  ensuring_: () => ensuring_,
  exponential: () => exponential,
  fibonacci: () => fibonacci,
  first: () => first,
  fixed: () => fixed,
  fold: () => fold,
  foldM: () => foldM,
  foldM_: () => foldM_,
  fold_: () => fold_,
  forever: () => forever,
  fromFunction: () => fromFunction,
  identity: () => identity,
  intersectWith: () => intersectWith,
  intersectWith_: () => intersectWith_,
  intersection: () => intersection,
  intersection_: () => intersection_,
  jittered: () => jittered,
  jittered_: () => jittered_,
  left: () => left,
  linear: () => linear,
  map: () => map,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  modifyDelay: () => modifyDelay,
  modifyDelayM: () => modifyDelayM,
  modifyDelayM_: () => modifyDelayM_,
  modifyDelay_: () => modifyDelay_,
  onDecision: () => onDecision,
  onDecision_: () => onDecision_,
  once: () => once,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  provideSome: () => provideSome,
  provideSome_: () => provideSome_,
  reconsider: () => reconsider,
  reconsiderM: () => reconsiderM,
  reconsiderM_: () => reconsiderM_,
  reconsider_: () => reconsider_,
  recurUntil: () => recurUntil,
  recurUntilEquals: () => recurUntilEquals,
  recurUntilM: () => recurUntilM,
  recurWhile: () => recurWhile,
  recurWhileEquals: () => recurWhileEquals,
  recurWhileM: () => recurWhileM,
  recurs: () => recurs,
  repeat: () => repeat,
  repetitions: () => repetitions,
  resetAfter: () => resetAfter,
  resetWhen: () => resetWhen,
  resetWhen_: () => resetWhen_,
  right: () => right,
  run: () => run,
  run_: () => run_,
  second: () => second,
  spaced: () => spaced,
  stop: () => stop,
  succeed: () => succeed,
  tapInput: () => tapInput,
  tapInput_: () => tapInput_,
  tapOutput: () => tapOutput,
  tapOutput_: () => tapOutput_,
  unfold: () => unfold,
  unfoldM: () => unfoldM,
  unfoldM_: () => unfoldM_,
  unfold_: () => unfold_,
  union: () => union,
  unionWith: () => unionWith,
  unionWith_: () => unionWith_,
  union_: () => union_,
  unit: () => unit,
  untilInput: () => untilInput,
  untilInputM: () => untilInputM,
  untilInputM_: () => untilInputM_,
  untilInput_: () => untilInput_,
  untilOutput: () => untilOutput,
  untilOutputM: () => untilOutputM,
  untilOutputM_: () => untilOutputM_,
  untilOutput_: () => untilOutput_,
  whileInput: () => whileInput,
  whileInputM: () => whileInputM,
  whileInputM_: () => whileInputM_,
  whileInput_: () => whileInput_,
  whileOutput: () => whileOutput,
  whileOutputM: () => whileOutputM,
  whileOutputM_: () => whileOutputM_,
  whileOutput_: () => whileOutput_,
  windowed: () => windowed,
  zip: () => zip,
  zipLeft: () => zipLeft,
  zipLeft_: () => zipLeft_,
  zipRight: () => zipRight,
  zipRight_: () => zipRight_,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var Clock = __toESM(require("../Clock/index.js"));
var A = __toESM(require("../Collections/Immutable/Array/index.js"));
var L = __toESM(require("../Collections/Immutable/List/index.js"));
var NA = __toESM(require("../Collections/Immutable/NonEmptyArray/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var NoSuchElementException = __toESM(require("../GlobalExceptions/index.js"));
var O = __toESM(require("../Option/index.js"));
var Random = __toESM(require("../Random/index.js"));
var R = __toESM(require("../Ref/index.js"));
var Decision = __toESM(require("./Decision/index.js"));
var Driver = __toESM(require("./Driver/index.js"));
var T = __toESM(require("./effect.js"));
class Schedule {
  constructor(step) {
    this.step = step;
    this["&&"] = (that) => intersection_(this, that);
    this["***"] = (that) => bothInOut_(this, that);
    this["*>"] = (that) => map_(this["&&"](that), (_) => _.get(1));
    this["+++"] = (that) => chooseMerge_(this, that);
    this["++"] = (that) => andThen_(this, that);
    this["<*"] = (that) => map_(this["&&"](that), (_) => _.get(0));
    this["<*>"] = (that) => zip_(this, that);
    this["<<<"] = (that) => compose_(that, this);
    this[">>>"] = (that) => compose_(this, that);
    this["||"] = (that) => union_(this, that);
    this["|||"] = (that) => chooseMerge_(this, that);
    this["<||>"] = (that) => andThenEither_(this, that);
  }
}
function driver(self) {
  return T.map_(R.makeRef([O.none, self.step]), (ref) => {
    const reset = ref.set([O.none, self.step]);
    const last = T.chain_(ref.get, ([o, _]) => O.fold_(o, () => T.fail(new NoSuchElementException.NoSuchElementException()), (b) => T.succeed(b)));
    const next = (i) => T.map_(T.bind_(T.bind_(T.bind_(T.bind_(T.do, "step", () => T.map_(ref.get, ([_, o]) => o)), "now", () => Clock.currentTime), "dec", ({
      now,
      step
    }) => step(now, i)), "v", ({
      dec,
      now
    }) => {
      switch (dec._tag) {
        case "Done": {
          return T.chain_(ref.set([O.some(dec.out), Decision.done(dec.out)]), () => T.fail(O.none));
        }
        case "Continue": {
          return T.map_(T.chain_(T.map_(ref.set([O.some(dec.out), dec.next]), () => dec.interval - now), (s) => s > 0 ? T.sleep(s) : T.unit), () => dec.out);
        }
      }
    }), ({
      v
    }) => v);
    return new Driver.Driver(next, last, reset);
  });
}
function repeatLoop(init, self = init) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return repeatLoop(init, self)(now, i);
      }
      case "Continue": {
        return T.succeed(Decision.makeContinue(d.out, d.interval, repeatLoop(init, d.next)));
      }
    }
  });
}
function repeat(self) {
  return new Schedule(repeatLoop(self.step));
}
function addDelay(f) {
  return (self) => addDelayM_(self, (b) => T.succeed(f(b)));
}
function addDelay_(self, f) {
  return addDelayM_(self, (b) => T.succeed(f(b)));
}
function addDelayM(f) {
  return (self) => addDelayM_(self, f);
}
function addDelayM_(self, f) {
  return modifyDelayM_(self, (o, d) => T.map_(f(o), (i) => i + d));
}
function andThen(that) {
  return (self) => andThen_(self, that);
}
function andThen_(self, that) {
  return map_(andThenEither_(self, that), (a) => a._tag === "Left" ? a.left : a.right);
}
function as(o) {
  return (self) => map_(self, () => o);
}
function bothLoop(self, that) {
  return (now, t) => {
    const {
      tuple: [in1, in2]
    } = t;
    return T.zipWith_(self(now, in1), that(now, in2), (d1, d2) => {
      switch (d1._tag) {
        case "Done": {
          switch (d2._tag) {
            case "Done": {
              return Decision.makeDone(Tp.tuple(d1.out, d2.out));
            }
            case "Continue": {
              return Decision.makeDone(Tp.tuple(d1.out, d2.out));
            }
          }
        }
        case "Continue": {
          switch (d2._tag) {
            case "Done": {
              return Decision.makeDone(Tp.tuple(d1.out, d2.out));
            }
            case "Continue": {
              return Decision.makeContinue(Tp.tuple(d1.out, d2.out), Math.min(d1.interval, d2.interval), bothLoop(d1.next, d2.next));
            }
          }
        }
      }
    });
  };
}
function bothInOut(that) {
  return (self) => new Schedule(bothLoop(self.step, that.step));
}
function bothInOut_(self, that) {
  return new Schedule(bothLoop(self.step, that.step));
}
function intersection(that) {
  return (self) => intersection_(self, that);
}
function intersection_(self, that) {
  return intersectWith_(self, that, (l, r) => Math.max(l, r));
}
function check(f) {
  return (self) => check_(self, f);
}
function check_(self, f) {
  return checkM_(self, (i, o) => T.succeed(f(i, o)));
}
function checkMLoop(self, test) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.succeed(Decision.makeDone(d.out));
      }
      case "Continue": {
        return T.map_(test(i, d.out), (b) => b ? Decision.makeContinue(d.out, d.interval, checkMLoop(d.next, test)) : Decision.makeDone(d.out));
      }
    }
  });
}
function checkM(test) {
  return (self) => new Schedule(checkMLoop(self.step, test));
}
function checkM_(self, test) {
  return new Schedule(checkMLoop(self.step, test));
}
function andThenEither(that) {
  return (self) => andThenEither_(self, that);
}
function andThenEitherLoop(self, that, onLeft) {
  return (now, i) => {
    if (onLeft) {
      return T.chain_(self(now, i), (d) => {
        switch (d._tag) {
          case "Continue": {
            return T.succeed(Decision.makeContinue(E.left(d.out), d.interval, andThenEitherLoop(d.next, that, true)));
          }
          case "Done": {
            return andThenEitherLoop(self, that, false)(now, i);
          }
        }
      });
    } else {
      return T.map_(that(now, i), (d) => {
        switch (d._tag) {
          case "Done": {
            return Decision.makeDone(E.right(d.out));
          }
          case "Continue": {
            return Decision.makeContinue(E.right(d.out), d.interval, andThenEitherLoop(self, d.next, false));
          }
        }
      });
    }
  };
}
function andThenEither_(self, that) {
  return new Schedule(andThenEitherLoop(self.step, that.step, true));
}
function chooseLoop(self, that) {
  return (now, either) => E.fold_(either, (i) => T.map_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return Decision.makeDone(E.left(d.out));
      }
      case "Continue": {
        return Decision.makeContinue(E.left(d.out), d.interval, chooseLoop(d.next, that));
      }
    }
  }), (i2) => T.map_(that(now, i2), (d) => {
    switch (d._tag) {
      case "Done": {
        return Decision.makeDone(E.right(d.out));
      }
      case "Continue": {
        return Decision.makeContinue(E.right(d.out), d.interval, chooseLoop(self, d.next));
      }
    }
  }));
}
function choose(that) {
  return (self) => choose_(self, that);
}
function choose_(self, that) {
  return new Schedule(chooseLoop(self.step, that.step));
}
function chooseMerge(that) {
  return (self) => chooseMerge_(self, that);
}
function chooseMerge_(self, that) {
  return map_(choose_(self, that), E.merge);
}
function collectAll(self) {
  return map_(fold_(self, L.empty(), (xs, x) => L.append_(xs, x)), L.toArray);
}
function collectAllIdentity() {
  return collectAll(identity());
}
function composeLoop(self, that) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.map_(that(now, d.out), Decision.toDone);
      }
      case "Continue": {
        return T.map_(that(now, d.out), (d2) => {
          switch (d2._tag) {
            case "Done": {
              return Decision.makeDone(d2.out);
            }
            case "Continue": {
              return Decision.makeContinue(d2.out, Math.max(d.interval, d2.interval), composeLoop(d.next, d2.next));
            }
          }
        });
      }
    }
  });
}
function compose(that) {
  return (self) => compose_(self, that);
}
function compose_(self, that) {
  return new Schedule(composeLoop(self.step, that.step));
}
function intersectWithLoop(self, that, f) {
  return (now, i) => {
    const left2 = self(now, i);
    const right2 = that(now, i);
    return T.zipWith_(left2, right2, (l, r) => {
      switch (l._tag) {
        case "Done": {
          switch (r._tag) {
            case "Done": {
              return Decision.makeDone(Tp.tuple(l.out, r.out));
            }
            case "Continue": {
              return Decision.makeDone(Tp.tuple(l.out, r.out));
            }
          }
        }
        case "Continue": {
          switch (r._tag) {
            case "Done": {
              return Decision.makeDone(Tp.tuple(l.out, r.out));
            }
            case "Continue": {
              return Decision.makeContinue(Tp.tuple(l.out, r.out), f(l.interval, r.interval), intersectWithLoop(l.next, r.next, f));
            }
          }
        }
      }
    });
  };
}
function contramap(f) {
  return (self) => contramap_(self, f);
}
function contramap_(self, f) {
  return new Schedule((now, i) => T.map_(self.step(now, f(i)), Decision.contramap(f)));
}
function delayed(f) {
  return (self) => delayed_(self, f);
}
function delayedFrom(schedule) {
  return addDelay_(schedule, (x) => x);
}
function delayed_(self, f) {
  return delayedM_(self, (d) => T.succeed(f(d)));
}
function delayedM(f) {
  return (self) => delayedM_(self, f);
}
function delayedM_(self, f) {
  return modifyDelayM_(self, (o, d) => f(d));
}
function dimap(f) {
  return (g) => (self) => dimap_(self, f, g);
}
function dimap_(self, f, g) {
  return map_(contramap_(self, f), g);
}
function duration(n) {
  return new Schedule((now, _) => T.succeed(Decision.makeContinue(0, now + n, () => T.succeed(Decision.makeDone(n)))));
}
function durations(n, ...rest) {
  return A.reduce_(rest, duration(n), (acc, d) => andThen_(acc, duration(d)));
}
function union(that) {
  return (self) => union_(self, that);
}
function union_(self, that) {
  return unionWith_(self, that, (d1, d2) => Math.min(d1, d2));
}
function unionWith(that, f) {
  return (self) => unionWith_(self, that, f);
}
function unionWithLoop(self, that, f) {
  return (now, inp) => {
    const left2 = self(now, inp);
    const right2 = that(now, inp);
    return T.zipWith_(left2, right2, (l, r) => {
      switch (l._tag) {
        case "Done": {
          switch (r._tag) {
            case "Done": {
              return Decision.makeDone(Tp.tuple(l.out, r.out));
            }
            case "Continue": {
              return Decision.makeContinue(Tp.tuple(l.out, r.out), r.interval, unionWithLoop(() => T.succeed(l), r.next, f));
            }
          }
        }
        case "Continue": {
          switch (r._tag) {
            case "Done": {
              return Decision.makeContinue(Tp.tuple(l.out, r.out), l.interval, unionWithLoop(l.next, () => T.succeed(r), f));
            }
            case "Continue": {
              return Decision.makeContinue(Tp.tuple(l.out, r.out), f(l.interval, r.interval), unionWithLoop(l.next, r.next, f));
            }
          }
        }
      }
    });
  };
}
function unionWith_(self, that, f) {
  return new Schedule(unionWithLoop(self.step, that.step, f));
}
function elapsedLoop(o) {
  return (now, _) => T.succeed(O.fold_(o, () => Decision.makeContinue(0, now, elapsedLoop(O.some(now))), (start) => Decision.makeContinue(now - start, now, elapsedLoop(O.some(start)))));
}
const elapsed = /* @__PURE__ */ new Schedule(/* @__PURE__ */ elapsedLoop(O.none));
function exponential(base, factor = 2) {
  return delayedFrom(map_(forever, (i) => base * Math.pow(factor, i)));
}
function fibonacci(one) {
  return delayedFrom(map_(unfold_((0, import_Function.tuple)(one, one), ([a1, a2]) => (0, import_Function.tuple)(a1, a1 + a2)), ([_]) => _));
}
function fixed(interval) {
  function loop(startMillis, n) {
    return (now, _) => T.succeed(O.fold_(startMillis, () => Decision.makeContinue(n + 1, now + interval, loop(O.some({
      startMillis: now,
      lastRun: now + interval
    }), n + 1)), ({
      lastRun,
      startMillis: startMillis2
    }) => {
      const runningBehind = now > lastRun + interval;
      const boundary = interval === 0 ? interval : interval - (now - startMillis2) % interval;
      const sleepTime = boundary === 0 ? interval : boundary;
      const nextRun = runningBehind ? now : now + sleepTime;
      return Decision.makeContinue(n + 1, nextRun, loop(O.some({
        startMillis: startMillis2,
        lastRun: nextRun
      }), n + 1));
    }));
  }
  return new Schedule(loop(O.none, 0));
}
function fromFunction(f) {
  return map_(identity(), f);
}
const count = /* @__PURE__ */ unfold_(0, (n) => n + 1);
function ensuringLoop(finalizer, self) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.as_(finalizer, Decision.makeDone(d.out));
      }
      case "Continue": {
        return T.succeed(Decision.makeContinue(d.out, d.interval, ensuringLoop(finalizer, d.next)));
      }
    }
  });
}
function ensuring(finalizer) {
  return (self) => new Schedule(ensuringLoop(finalizer, self.step));
}
function ensuring_(self, finalizer) {
  return new Schedule(ensuringLoop(finalizer, self.step));
}
function first() {
  return (self) => bothInOut_(self, identity());
}
function foldMLoop(z, f, self) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.succeed(Decision.makeDone(z));
      }
      case "Continue": {
        return T.map_(f(z, d.out), (z2) => Decision.makeContinue(z2, d.interval, foldMLoop(z2, f, d.next)));
      }
    }
  });
}
function fold(z) {
  return (f) => (self) => fold_(self, z, f);
}
function fold_(self, z, f) {
  return foldM_(self, z, (z2, o) => T.succeed(f(z2, o)));
}
function foldM(z) {
  return (f) => (self) => foldM_(self, z, f);
}
function foldM_(self, z, f) {
  return new Schedule(foldMLoop(z, f, self.step));
}
const forever = /* @__PURE__ */ unfold_(0, (n) => n + 1);
function identityLoop() {
  return (now, i) => T.succeed(Decision.makeContinue(i, now, identityLoop()));
}
function identity() {
  return new Schedule(identityLoop());
}
function intersectWith_(self, that, f) {
  return new Schedule(intersectWithLoop(self.step, that.step, f));
}
function intersectWith(that, f) {
  return (self) => intersectWith_(self, that, f);
}
function jittered({
  max = 0.1,
  min = 0
} = {}) {
  return (self) => jittered_(self, {
    min,
    max
  });
}
function jittered_(self, {
  max = 0.1,
  min = 0
} = {}) {
  return delayedM_(self, (d) => T.map_(Random.next, (random) => d * min * (1 - random) + d * max * random));
}
function linear(base) {
  return delayedFrom(map_(forever, (i) => base * (i + 1)));
}
const once = /* @__PURE__ */ unit(/* @__PURE__ */ recurs(1));
function mapMLoop(f, self) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.map_(f(d.out), (o) => Decision.makeDone(o));
      }
      case "Continue": {
        return T.map_(f(d.out), (o) => Decision.makeContinue(o, d.interval, mapMLoop(f, d.next)));
      }
    }
  });
}
function left() {
  return (self) => choose_(self, identity());
}
function map(f) {
  return (self) => map_(self, f);
}
function map_(self, f) {
  return mapM_(self, (o) => T.succeed(f(o)));
}
function mapM(f) {
  return (self) => new Schedule(mapMLoop(f, self.step));
}
function mapM_(self, f) {
  return new Schedule(mapMLoop(f, self.step));
}
function modifyDelayMLoop(f, self) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.succeed(Decision.makeDone(d.out));
      }
      case "Continue": {
        const delay = d.interval - now;
        return T.map_(f(d.out, delay), (n) => Decision.makeContinue(d.out, d.interval + n, modifyDelayMLoop(f, d.next)));
      }
    }
  });
}
function modifyDelayM(f) {
  return (self) => modifyDelayM_(self, f);
}
function modifyDelayM_(self, f) {
  return new Schedule(modifyDelayMLoop(f, self.step));
}
function modifyDelay(f) {
  return (self) => modifyDelay_(self, f);
}
function modifyDelay_(self, f) {
  return modifyDelayM_(self, (o, d) => T.succeed(f(o, d)));
}
function onDecisionLoop(self, f) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.as_(f(d), Decision.makeDone(d.out));
      }
      case "Continue": {
        return T.as_(f(d), Decision.makeContinue(d.out, d.interval, onDecisionLoop(d.next, f)));
      }
    }
  });
}
function onDecision_(self, f) {
  return new Schedule(onDecisionLoop(self.step, f));
}
function onDecision(f) {
  return (self) => new Schedule(onDecisionLoop(self.step, f));
}
function provideAllLoop(env, self) {
  return (now, i) => T.provideAll_(T.map_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return Decision.makeDone(d.out);
      }
      case "Continue": {
        return Decision.makeContinue(d.out, d.interval, provideAllLoop(env, d.next));
      }
    }
  }), env);
}
function provideAll(env) {
  return (self) => provideAll_(self, env);
}
function provideAll_(self, env) {
  return new Schedule(provideAllLoop(env, self.step));
}
function provideSomeLoop(env, self) {
  return (now, i) => T.provideSome_(T.map_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return Decision.makeDone(d.out);
      }
      case "Continue": {
        return Decision.makeContinue(d.out, d.interval, provideSomeLoop(env, d.next));
      }
    }
  }), env);
}
function provideSome(env) {
  return (self) => new Schedule(provideSomeLoop(env, self.step));
}
function provideSome_(self, env) {
  return new Schedule(provideSomeLoop(env, self.step));
}
function reconsider(f) {
  return (self) => reconsider_(self, f);
}
function reconsider_(self, f) {
  return reconsiderM_(self, (d) => T.succeed(f(d)));
}
function reconsiderMLoop(self, f) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.map_(f(d), E.fold((o2) => Decision.makeDone(o2), ([o2]) => Decision.makeDone(o2)));
      }
      case "Continue": {
        return T.map_(f(d), E.fold((o2) => Decision.makeDone(o2), ([o2, int]) => Decision.makeContinue(o2, int, reconsiderMLoop(d.next, f))));
      }
    }
  });
}
function reconsiderM(f) {
  return (self) => reconsiderM_(self, f);
}
function reconsiderM_(self, f) {
  return new Schedule(reconsiderMLoop(self.step, f));
}
function repetitions(self) {
  return fold_(self, 0, (n) => n + 1);
}
function resetAfter(duration2) {
  return (self) => map_(resetWhen_(zip_(self, elapsed), ({
    tuple: [_, d]
  }) => d >= duration2), ({
    tuple: [o]
  }) => o);
}
function resetWhenLoop(self, step, f) {
  return (now, i) => T.chain_(step(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return f(d.out) ? self.step(now, i) : T.succeed(Decision.makeDone(d.out));
      }
      case "Continue": {
        return f(d.out) ? self.step(now, i) : T.succeed(Decision.makeContinue(d.out, d.interval, resetWhenLoop(self, d.next, f)));
      }
    }
  });
}
function resetWhen(f) {
  return (self) => resetWhen_(self, f);
}
function resetWhen_(self, f) {
  return new Schedule(resetWhenLoop(self, self.step, f));
}
function recurWhile(f) {
  return whileInput_(identity(), f);
}
function recurWhileM(f) {
  return whileInputM_(identity(), f);
}
function recurWhileEquals(a) {
  return whileInput_(identity(), (x) => a === x);
}
function recurUntil(f) {
  return untilInput_(identity(), f);
}
function recurUntilM(f) {
  return untilInputM_(identity(), f);
}
function recurUntilEquals(a) {
  return untilInput_(identity(), (x) => x === a);
}
function recurs(n) {
  return whileOutput_(forever, (x) => x < n);
}
function right() {
  return (self) => choose_(identity(), self);
}
function runLoop(now, xs, self, acc) {
  if (A.isNonEmpty(xs)) {
    return T.chain_(self(now, NA.head(xs)), (d) => {
      switch (d._tag) {
        case "Done": {
          return T.succeed([...acc, d.out]);
        }
        case "Continue": {
          return runLoop(d.interval, xs, d.next, [...acc, d.out]);
        }
      }
    });
  } else {
    return T.succeed(acc);
  }
}
function run(now, i) {
  return (self) => run_(self, now, i);
}
function run_(self, now, i) {
  return runLoop(now, Array.from(i), self.step, []);
}
function second() {
  return (self) => bothInOut_(identity(), self);
}
function tapInputLoop(self, f) {
  return (now, i) => T.chain_(f(i), () => T.map_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return Decision.makeDone(d.out);
      }
      case "Continue": {
        return Decision.makeContinue(d.out, d.interval, tapInputLoop(d.next, f));
      }
    }
  }));
}
function spaced(duration2) {
  return addDelay_(forever, () => duration2);
}
const stop = /* @__PURE__ */ unit(/* @__PURE__ */ recurs(0));
function succeed(a) {
  return as(a)(forever);
}
function tapInput_(self, f) {
  return new Schedule(tapInputLoop(self.step, f));
}
function tapInput(f) {
  return (self) => new Schedule(tapInputLoop(self.step, f));
}
function tapOutputLoop(self, f) {
  return (now, i) => T.chain_(self(now, i), (d) => {
    switch (d._tag) {
      case "Done": {
        return T.as_(f(d.out), Decision.makeDone(d.out));
      }
      case "Continue": {
        return T.as_(f(d.out), Decision.makeContinue(d.out, d.interval, tapOutputLoop(d.next, f)));
      }
    }
  });
}
function tapOutput(f) {
  return (self) => tapOutput_(self, f);
}
function tapOutput_(self, f) {
  return new Schedule(tapOutputLoop(self.step, f));
}
function unit(self) {
  return as(void 0)(self);
}
function untilInput(f) {
  return (self) => untilInput_(self, f);
}
function untilInput_(self, f) {
  return check_(self, (i) => !f(i));
}
function untilInputM(f) {
  return (self) => untilInputM_(self, f);
}
function untilInputM_(self, f) {
  return checkM_(self, (i) => T.map_(f(i), (b) => !b));
}
function untilOutput(f) {
  return (self) => untilOutput_(self, f);
}
function untilOutput_(self, f) {
  return check_(self, (_, o) => !f(o));
}
function untilOutputM(f) {
  return (self) => untilOutputM_(self, f);
}
function untilOutputM_(self, f) {
  return checkM_(self, (_, o) => T.map_(f(o), (b) => !b));
}
function whileInput(f) {
  return (self) => whileInput_(self, f);
}
function whileInput_(self, f) {
  return check_(self, (i) => f(i));
}
function whileInputM(f) {
  return (self) => whileInputM_(self, f);
}
function whileInputM_(self, f) {
  return checkM_(self, (i) => f(i));
}
function whileOutput(f) {
  return (self) => whileOutput_(self, f);
}
function whileOutput_(self, f) {
  return check_(self, (_, o) => f(o));
}
function whileOutputM(f) {
  return (self) => whileOutputM_(self, f);
}
function whileOutputM_(self, f) {
  return checkM_(self, (_, o) => T.map_(f(o), (b) => !b));
}
function windowedLoop(interval, startMillis, n) {
  return (now, _) => T.succeed(O.fold_(startMillis, () => Decision.makeContinue(n + 1, now + interval, windowedLoop(interval, O.some(now), n + 1)), (startMillis2) => {
    return Decision.makeContinue(n + 1, now + (interval - (now - startMillis2) % interval), windowedLoop(interval, O.some(startMillis2), n + 1));
  }));
}
function windowed(interval) {
  return new Schedule(windowedLoop(interval, O.none, 0));
}
function unfoldLoop(a, f) {
  return (now, _) => T.succeed(Decision.makeContinue(a, now, unfoldLoop(f(a), f)));
}
function unfold(f) {
  return (a) => unfold_(a, f);
}
function unfold_(a, f) {
  return new Schedule((now) => T.succeedWith(() => Decision.makeContinue(a, now, unfoldLoop(f(a), f))));
}
function unfoldM(f) {
  return (a) => unfoldM_(a, f);
}
function unfoldMLoop(a, f) {
  return (now, _) => T.succeed(Decision.makeContinue(a, now, (n, i) => T.chain_(f(a), (x) => unfoldMLoop(x, f)(n, i))));
}
function unfoldM_(a, f) {
  return new Schedule(unfoldMLoop(a, f));
}
function zip_(self, that) {
  return intersectWith_(self, that, (d, d2) => Math.max(d, d2));
}
function zip(that) {
  return (self) => intersectWith_(self, that, (d, d2) => Math.max(d, d2));
}
function zipLeft(that) {
  return (self) => zipLeft_(self, that);
}
function zipLeft_(self, that) {
  return map_(zip_(self, that), (_) => _.get(0));
}
function zipRight(that) {
  return (self) => zipRight_(self, that);
}
function zipRight_(self, that) {
  return map_(zip_(self, that), (_) => _.get(1));
}
function zipWith(that, f) {
  return (self) => zipWith_(self, that, f);
}
function zipWith_(self, that, f) {
  return map_(zip_(self, that), ({
    tuple: [o, o1]
  }) => f(o, o1));
}
module.exports = __toCommonJS(schedule_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Schedule,
  addDelay,
  addDelayM,
  addDelayM_,
  addDelay_,
  andThen,
  andThenEither,
  andThenEither_,
  andThen_,
  as,
  bothInOut,
  bothInOut_,
  check,
  checkM,
  checkM_,
  check_,
  choose,
  chooseMerge,
  chooseMerge_,
  choose_,
  collectAll,
  collectAllIdentity,
  compose,
  compose_,
  contramap,
  contramap_,
  count,
  delayed,
  delayedFrom,
  delayedM,
  delayedM_,
  delayed_,
  dimap,
  dimap_,
  driver,
  duration,
  durations,
  elapsed,
  ensuring,
  ensuring_,
  exponential,
  fibonacci,
  first,
  fixed,
  fold,
  foldM,
  foldM_,
  fold_,
  forever,
  fromFunction,
  identity,
  intersectWith,
  intersectWith_,
  intersection,
  intersection_,
  jittered,
  jittered_,
  left,
  linear,
  map,
  mapM,
  mapM_,
  map_,
  modifyDelay,
  modifyDelayM,
  modifyDelayM_,
  modifyDelay_,
  onDecision,
  onDecision_,
  once,
  provideAll,
  provideAll_,
  provideSome,
  provideSome_,
  reconsider,
  reconsiderM,
  reconsiderM_,
  reconsider_,
  recurUntil,
  recurUntilEquals,
  recurUntilM,
  recurWhile,
  recurWhileEquals,
  recurWhileM,
  recurs,
  repeat,
  repetitions,
  resetAfter,
  resetWhen,
  resetWhen_,
  right,
  run,
  run_,
  second,
  spaced,
  stop,
  succeed,
  tapInput,
  tapInput_,
  tapOutput,
  tapOutput_,
  unfold,
  unfoldM,
  unfoldM_,
  unfold_,
  union,
  unionWith,
  unionWith_,
  union_,
  unit,
  untilInput,
  untilInputM,
  untilInputM_,
  untilInput_,
  untilOutput,
  untilOutputM,
  untilOutputM_,
  untilOutput_,
  whileInput,
  whileInputM,
  whileInputM_,
  whileInput_,
  whileOutput,
  whileOutputM,
  whileOutputM_,
  whileOutput_,
  windowed,
  zip,
  zipLeft,
  zipLeft_,
  zipRight,
  zipRight_,
  zipWith,
  zipWith_,
  zip_
});
