var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  Left: () => Left,
  Right: () => Right,
  alt: () => alt,
  alt_: () => alt_,
  ap: () => ap,
  ap_: () => ap_,
  bimap: () => bimap,
  bimap_: () => bimap_,
  chain: () => chain,
  chain_: () => chain_,
  compact: () => compact,
  duplicate: () => duplicate,
  exists: () => exists,
  exists_: () => exists_,
  extend: () => extend,
  extend_: () => extend_,
  filterOrElse: () => filterOrElse,
  filterOrElse_: () => filterOrElse_,
  flatten: () => flatten,
  fold: () => fold,
  fold_: () => fold_,
  fromNullable: () => fromNullable,
  fromNullable_: () => fromNullable_,
  fromOption: () => fromOption,
  fromOption_: () => fromOption_,
  fromPredicate: () => fromPredicate,
  fromPredicate_: () => fromPredicate_,
  getOrElse: () => getOrElse,
  getOrElse_: () => getOrElse_,
  isLeft: () => isLeft,
  isRight: () => isRight,
  left: () => left,
  leftW: () => leftW,
  map: () => map,
  mapLeft: () => mapLeft,
  mapLeft_: () => mapLeft_,
  map_: () => map_,
  merge: () => merge,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseEither_: () => orElseEither_,
  orElse_: () => orElse_,
  parseJSON: () => parseJSON,
  parseJSON_: () => parseJSON_,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRight_: () => reduceRight_,
  reduce_: () => reduce_,
  right: () => right,
  rightW: () => rightW,
  stringifyJSON: () => stringifyJSON,
  stringifyJSON_: () => stringifyJSON_,
  swap: () => swap,
  tap: () => tap,
  tap_: () => tap_,
  toError: () => toError,
  tryCatch: () => tryCatch,
  widenA: () => widenA,
  widenE: () => widenE,
  zip: () => zip,
  zipFirst: () => zipFirst,
  zipFirst_: () => zipFirst_,
  zipSecond: () => zipSecond,
  zipSecond_: () => zipSecond_,
  zip_: () => zip_
});
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var import_core = require("../Option/core.js");
var St = __toESM(require("../Structural/index.js"));
const _leftHash = /* @__PURE__ */ St.hashString("@effect-ts/system/Either/Left");
const _rightHash = /* @__PURE__ */ St.hashString("@effect-ts/system/Either/Right");
class Left {
  constructor(left2) {
    this.left = left2;
    this._tag = "Left";
  }
  [St.equalsSym](that) {
    return that instanceof Left && St.equals(this.left, that.left);
  }
  get [St.hashSym]() {
    return St.combineHash(_leftHash, St.hash(this.left));
  }
}
class Right {
  constructor(right2) {
    this.right = right2;
    this._tag = "Right";
  }
  [St.equalsSym](that) {
    return that instanceof Right && St.equals(this.right, that.right);
  }
  get [St.hashSym]() {
    return St.combineHash(_rightHash, St.hash(this.right));
  }
}
function right(a) {
  return new Right(a);
}
function rightW(a) {
  return new Right(a);
}
function left(e) {
  return new Left(e);
}
function leftW(e) {
  return new Left(e);
}
function widenE() {
  return (self) => self;
}
function widenA() {
  return (self) => self;
}
function alt_(self, that) {
  return isLeft(self) ? that() : self;
}
function alt(that) {
  return (self) => alt_(self, that);
}
function ap_(fab, fa) {
  return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));
}
function ap(fa) {
  return (fab) => ap_(fab, fa);
}
function zip_(fa, fb) {
  return chain_(fa, (a) => map_(fb, (b) => Tp.tuple(a, b)));
}
function zip(fb) {
  return (fa) => zip_(fa, fb);
}
function zipFirst(fb) {
  return (fa) => zipFirst_(fa, fb);
}
function zipFirst_(fa, fb) {
  return ap_(map_(fa, (a) => () => a), fb);
}
function zipSecond(fb) {
  return (fa) => zipSecond_(fa, fb);
}
function zipSecond_(fa, fb) {
  return ap_(map_(fa, () => (b) => b), fb);
}
function bimap_(fea, f, g) {
  return isLeft(fea) ? left(f(fea.left)) : right(g(fea.right));
}
function bimap(f, g) {
  return (fa) => bimap_(fa, f, g);
}
function chain_(fa, f) {
  return isLeft(fa) ? fa : f(fa.right);
}
function chain(f) {
  return (ma) => chain_(ma, f);
}
function tap(f) {
  return (ma) => chain_(ma, (a) => map_(f(a), () => a));
}
function tap_(ma, f) {
  return chain_(ma, (a) => map_(f(a), () => a));
}
function duplicate(ma) {
  return extend_(ma, (x) => x);
}
function exists(predicate) {
  return (ma) => isLeft(ma) ? false : predicate(ma.right);
}
function exists_(ma, predicate) {
  return isLeft(ma) ? false : predicate(ma.right);
}
function extend_(wa, f) {
  return isLeft(wa) ? wa : right(f(wa));
}
function extend(f) {
  return (ma) => extend_(ma, f);
}
function filterOrElse(predicate, onFalse) {
  return (ma) => chain_(ma, (a) => predicate(a) ? right(a) : left(onFalse(a)));
}
function filterOrElse_(ma, predicate, onFalse) {
  return chain_(ma, (a) => predicate(a) ? right(a) : left(onFalse(a)));
}
function flatten(mma) {
  return chain_(mma, (x) => x);
}
function fold(onLeft, onRight) {
  return (ma) => isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);
}
function fold_(ma, onLeft, onRight) {
  return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);
}
function fromNullable(e) {
  return (a) => a == null ? left(e()) : right(a);
}
function fromNullable_(a, e) {
  return a == null ? left(e()) : right(a);
}
function fromOption(onNone) {
  return (ma) => (0, import_core.isNone)(ma) ? left(onNone()) : right(ma.value);
}
function fromOption_(ma, onNone) {
  return (0, import_core.isNone)(ma) ? left(onNone()) : right(ma.value);
}
function fromPredicate(predicate, onFalse) {
  return (a) => predicate(a) ? right(a) : left(onFalse(a));
}
function fromPredicate_(a, predicate, onFalse) {
  return predicate(a) ? right(a) : left(onFalse(a));
}
function getOrElse(onLeft) {
  return (ma) => getOrElse_(ma, onLeft);
}
function getOrElse_(self, onLeft) {
  return isLeft(self) ? onLeft(self.left) : self.right;
}
function isLeft(ma) {
  switch (ma._tag) {
    case "Left":
      return true;
    case "Right":
      return false;
  }
}
function isRight(ma) {
  return ma._tag === "Right" ? true : false;
}
function map_(fa, f) {
  return isLeft(fa) ? fa : right(f(fa.right));
}
function map(f) {
  return (fa) => map_(fa, f);
}
function mapLeft_(fea, f) {
  return isLeft(fea) ? left(f(fea.left)) : fea;
}
function mapLeft(f) {
  return (fa) => mapLeft_(fa, f);
}
function merge(self) {
  return fold_(self, (x) => x, (x) => x);
}
function orElse(onLeft) {
  return (ma) => orElse_(ma, onLeft);
}
function orElse_(ma, onLeft) {
  return isLeft(ma) ? onLeft(ma.left) : ma;
}
function orElseEither(onLeft) {
  return (ma) => orElseEither_(ma, onLeft);
}
function orElseEither_(ma, onLeft) {
  return orElse_(map_(ma, left), (e) => map_(onLeft(e), right));
}
function parseJSON_(s, onError) {
  return tryCatch(() => JSON.parse(s), onError);
}
function parseJSON(onError) {
  return (s) => tryCatch(() => JSON.parse(s), onError);
}
function stringifyJSON_(u, onError) {
  return tryCatch(() => JSON.stringify(u), onError);
}
function stringifyJSON(onError) {
  return (u) => tryCatch(() => JSON.stringify(u), onError);
}
function swap(ma) {
  return isLeft(ma) ? right(ma.left) : left(ma.right);
}
function toError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function tryCatch(f, onError) {
  try {
    return right(f());
  } catch (e) {
    return left(onError(e));
  }
}
function compact(_) {
  return _;
}
function reduce_(fa, b, f) {
  return isLeft(fa) ? b : f(b, fa.right);
}
function reduce(b, f) {
  return (fa) => reduce_(fa, b, f);
}
function reduceRight(b, f) {
  return (fa) => reduceRight_(fa, b, f);
}
function reduceRight_(fa, b, f) {
  return isLeft(fa) ? b : f(fa.right, b);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Left,
  Right,
  alt,
  alt_,
  ap,
  ap_,
  bimap,
  bimap_,
  chain,
  chain_,
  compact,
  duplicate,
  exists,
  exists_,
  extend,
  extend_,
  filterOrElse,
  filterOrElse_,
  flatten,
  fold,
  fold_,
  fromNullable,
  fromNullable_,
  fromOption,
  fromOption_,
  fromPredicate,
  fromPredicate_,
  getOrElse,
  getOrElse_,
  isLeft,
  isRight,
  left,
  leftW,
  map,
  mapLeft,
  mapLeft_,
  map_,
  merge,
  orElse,
  orElseEither,
  orElseEither_,
  orElse_,
  parseJSON,
  parseJSON_,
  reduce,
  reduceRight,
  reduceRight_,
  reduce_,
  right,
  rightW,
  stringifyJSON,
  stringifyJSON_,
  swap,
  tap,
  tap_,
  toError,
  tryCatch,
  widenA,
  widenE,
  zip,
  zipFirst,
  zipFirst_,
  zipSecond,
  zipSecond_,
  zip_
});
