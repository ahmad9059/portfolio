var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var BoolAlgebra_exports = {};
__export(BoolAlgebra_exports, {
  And: () => And,
  AndTypeId: () => AndTypeId,
  BoolAlgebra: () => BoolAlgebra,
  BoolAlgebraTypeId: () => BoolAlgebraTypeId,
  Not: () => Not,
  NotTypeId: () => NotTypeId,
  Or: () => Or,
  OrTypeId: () => OrTypeId,
  Value: () => Value,
  ValueTypeId: () => ValueTypeId,
  all: () => all,
  and: () => and,
  and_: () => and_,
  any: () => any,
  as: () => as,
  as_: () => as_,
  chain: () => chain,
  chainM: () => chainM,
  chainM_: () => chainM_,
  chain_: () => chain_,
  collectAll: () => collectAll,
  concrete: () => concrete,
  failure: () => failure,
  failures: () => failures,
  fold: () => fold,
  fold_: () => fold_,
  forEach: () => forEach,
  iff: () => iff,
  iff_: () => iff_,
  implies: () => implies,
  implies_: () => implies_,
  isAnd: () => isAnd,
  isBoolAlgebra: () => isBoolAlgebra,
  isFailure: () => isFailure,
  isNot: () => isNot,
  isOr: () => isOr,
  isSuccess: () => isSuccess,
  isValue: () => isValue,
  map: () => map,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  not: () => not,
  or: () => or,
  or_: () => or_,
  success: () => success,
  unit: () => unit
});
var A = __toESM(require("../../Collections/Immutable/Array/index.js"));
var NEA = __toESM(require("../../Collections/Immutable/NonEmptyArray/index.js"));
var T = __toESM(require("../../Effect/index.js"));
var E = __toESM(require("../../Either/index.js"));
var import_Function = require("../../Function/index.js");
var O = __toESM(require("../../Option/index.js"));
var ST = __toESM(require("../../Structural/index.js"));
var PR = __toESM(require("../Primitives/index.js"));
var _a;
const BoolAlgebraTypeId = /* @__PURE__ */ Symbol();
const ValueTypeId = /* @__PURE__ */ Symbol();
const AndTypeId = /* @__PURE__ */ Symbol();
const OrTypeId = /* @__PURE__ */ Symbol();
const NotTypeId = /* @__PURE__ */ Symbol();
function concrete(_) {
}
class BoolAlgebra {
  constructor() {
    this[_a] = BoolAlgebraTypeId;
  }
  get [(_a = BoolAlgebraTypeId, PR._A, PR._C, ST.hashSym)]() {
    return fold_(this, (a) => ST.hash(a), (a, b) => a & b, (a, b) => a | b, (a) => ~a);
  }
  ["&&"](that) {
    return and_(this, that);
  }
  ["||"](that) {
    return or_(this, that);
  }
  get ["!"]() {
    return not(this);
  }
}
class Value extends BoolAlgebra {
  constructor(value) {
    super();
    this.value = value;
    this.typeId = ValueTypeId;
  }
  [ST.equalsSym](that) {
    if (isBoolAlgebra(that)) {
      return this.equal(that) || doubleNegative(this, that);
    }
    return false;
  }
  get [ST.hashSym]() {
    return fold_(this, (a) => ST.hash(a), (a, b) => a & b, (a, b) => a | b, (a) => ~a);
  }
  equal(that) {
    if (isValue(that)) {
      return ST.equals(this.value, that.value);
    }
    return false;
  }
}
function isValue(a) {
  concrete(a);
  return a.typeId === ValueTypeId;
}
class And extends BoolAlgebra {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this.typeId = AndTypeId;
  }
  [ST.equalsSym](that) {
    if (isBoolAlgebra(that)) {
      return this.equal(that) || this.commutative(that) || symmetric(And.associative)(this, that) || symmetric(And.distributive)(this, that) || doubleNegative(this, that) || this.deMorgansLaws(that);
    }
    return false;
  }
  equal(that) {
    if (isAnd(that)) {
      return ST.equals(this.left, that.left) && ST.equals(this.right, that.right);
    }
    return false;
  }
  static associative(left, right) {
    if (isAnd(left) && isAnd(right)) {
      if (isAnd(left.left) && isAnd(right.right)) {
        const {
          left: a1,
          right: b1
        } = left.left;
        const c1 = left.right;
        const {
          left: b2,
          right: c2
        } = right.right;
        const a2 = right.left;
        return ST.equals(a1, a2) && ST.equals(b1, b2) && ST.equals(c1, c2);
      }
    }
    return false;
  }
  commutative(that) {
    if (isAnd(that)) {
      const {
        left: al,
        right: bl
      } = this;
      const {
        left: ar,
        right: br
      } = that;
      return ST.equals(al, br) && ST.equals(bl, ar);
    }
    return false;
  }
  static distributive(left, right) {
    if (isAnd(left) && isOr(right)) {
      if (isOr(left.right) && isAnd(right.left) && isAnd(right.right)) {
        const a1 = left.left;
        const {
          left: b1,
          right: c1
        } = left.right;
        const {
          left: a2,
          right: b2
        } = right.left;
        const {
          left: a3,
          right: c2
        } = right.right;
        return ST.equals(a1, a2) && ST.equals(a1, a3) && ST.equals(b1, b2) && ST.equals(c1, c2);
      }
    }
    return false;
  }
  deMorgansLaws(that) {
    if (isNot(that)) {
      if (isNot(this.left) && isNot(this.right)) {
        if (isOr(that.result)) {
          const a = this.left.result;
          const b = this.right.result;
          const {
            left: c,
            right: d
          } = that.result;
          return ST.equals(a, c) && ST.equals(b, d);
        }
      }
    }
    return false;
  }
}
function isAnd(a) {
  concrete(a);
  return a.typeId === AndTypeId;
}
class Or extends BoolAlgebra {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this.typeId = OrTypeId;
  }
  [ST.equalsSym](that) {
    if (isBoolAlgebra(that)) {
      return this.equal(that) || this.commutative(that) || symmetric(Or.associative)(this, that) || symmetric(Or.distributive)(this, that) || doubleNegative(this, that) || this.deMorgansLaws(that);
    }
    return false;
  }
  equal(that) {
    if (isOr(that)) {
      return ST.equals(this.left, that.left) && ST.equals(this.right, that.right);
    }
    return false;
  }
  static associative(left, right) {
    if (isOr(left) && isOr(left.left)) {
      if (isOr(right) && isOr(right.right)) {
        const {
          left: a1,
          right: b1
        } = left.left;
        const c1 = left.right;
        const a2 = right.left;
        const {
          left: b2,
          right: c2
        } = right.right;
        return ST.equals(a1, a2) && ST.equals(b1, b2) && ST.equals(c1, c2);
      }
    }
    return false;
  }
  commutative(that) {
    if (isOr(that)) {
      const {
        left: al,
        right: bl
      } = this;
      const {
        left: ar,
        right: br
      } = that;
      return ST.equals(al, br) && ST.equals(bl, ar);
    }
    return false;
  }
  static distributive(left, right) {
    if (isOr(left) && isAnd(left.right)) {
      if (isAnd(right) && isOr(right.left) && isOr(right.right)) {
        const a1 = left.left;
        const {
          left: b1,
          right: c1
        } = left.right;
        const {
          left: a2,
          right: b2
        } = right.left;
        const {
          left: a3,
          right: c2
        } = right.right;
        return ST.equals(a1, a2) && ST.equals(a1, a3) && ST.equals(b1, b2) && ST.equals(c1, c2);
      }
    }
    return false;
  }
  deMorgansLaws(that) {
    if (isNot(this.left) && isNot(this.right)) {
      if (isNot(that) && isAnd(that.result)) {
        const a = this.left.result;
        const b = this.right.result;
        const {
          left: c,
          right: d
        } = that.result;
        return ST.equals(a, c) && ST.equals(b, d);
      }
    }
    return false;
  }
}
function isOr(a) {
  concrete(a);
  return a.typeId === OrTypeId;
}
class Not extends BoolAlgebra {
  constructor(result) {
    super();
    this.result = result;
    this.typeId = NotTypeId;
  }
  [ST.equalsSym](that) {
    if (isBoolAlgebra(that)) {
      return this.equal(that) || doubleNegative(that, this) || this.deMorgansLaws(that);
    }
    return false;
  }
  equal(that) {
    if (isNot(that)) {
      return ST.equals(this.result, that.result);
    }
    return false;
  }
  deMorgansLaws(that) {
    if (isAnd(that)) {
      if (isOr(this.result) && isNot(that.left) && isNot(that.right)) {
        const {
          left: a,
          right: b
        } = this.result;
        const c = that.left.result;
        const d = that.right.result;
        return ST.equals(a, c) && ST.equals(b, d);
      }
    }
    if (isOr(that)) {
      if (isAnd(this.result) && isNot(that.left) && isNot(that.right)) {
        const {
          left: a,
          right: b
        } = this.result;
        const c = that.left.result;
        const d = that.right.result;
        return ST.equals(a, c) && ST.equals(b, d);
      }
    }
    return false;
  }
}
function isNot(a) {
  concrete(a);
  return a.typeId === NotTypeId;
}
function isBoolAlgebra(a) {
  return typeof a === "object" && a !== null && BoolAlgebraTypeId in a;
}
function doubleNegative(left, right) {
  if (isNot(right) && isNot(right.result)) {
    return ST.equals(left, right.result.result);
  }
  return false;
}
function symmetric(f) {
  return (a1, a2) => f(a1, a2) || f(a2, a1);
}
function as_(self, b) {
  return map_(self, (_) => b);
}
function as(b) {
  return (self) => as_(self, b);
}
function failures(self) {
  return E.fold_(fold_(self, (a) => E.right(success(a)), (l, r) => {
    if (E.isRight(l)) {
      if (E.isRight(r)) {
        return E.right(and_(l.right, r.right));
      } else {
        return E.left(r.left);
      }
    } else {
      if (E.isRight(r)) {
        return E.left(l.left);
      } else {
        return E.left(and_(l.left, r.left));
      }
    }
  }, (l, r) => {
    if (E.isRight(l)) {
      if (E.isRight(r)) {
        return E.right(or_(l.right, r.right));
      } else {
        return E.right(l.right);
      }
    } else {
      if (E.isRight(r)) {
        return E.right(r.right);
      } else {
        return E.left(or_(l.left, r.left));
      }
    }
  }, (r) => E.swap(r)), (_) => O.some(_), (_) => O.none);
}
function chain_(self, f) {
  return fold_(self, f, and_, or_, not);
}
function chain(f) {
  return (self) => chain_(self, f);
}
function chainM_(self, f) {
  return fold_(self, f, (_) => T.zipWith_(_, _, and_), (_) => T.zipWith_(_, _, or_), (_) => T.map_(_, not));
}
function chainM(f) {
  return (self) => chainM_(self, f);
}
function fold_(self, caseValue, caseAnd, caseOr, caseNot) {
  concrete(self);
  switch (self.typeId) {
    case ValueTypeId:
      return caseValue(self.value);
    case AndTypeId:
      return caseAnd(fold_(self.left, caseValue, caseAnd, caseOr, caseNot), fold_(self.right, caseValue, caseAnd, caseOr, caseNot));
    case OrTypeId:
      return caseOr(fold_(self.left, caseValue, caseAnd, caseOr, caseNot), fold_(self.right, caseValue, caseAnd, caseOr, caseNot));
    case NotTypeId:
      return caseNot(fold_(self.result, caseValue, caseAnd, caseOr, caseNot));
  }
}
function fold(caseValue, caseAnd, caseOr, caseNot) {
  return (self) => fold_(self, caseValue, caseAnd, caseOr, caseNot);
}
function implies_(self, that) {
  return or_(not(self), that);
}
function implies(that) {
  return (self) => implies_(self, that);
}
function iff_(self, that) {
  return and_(implies_(self, that), implies_(that, self));
}
function iff(that) {
  return (self) => iff_(self, that);
}
function isFailure(self) {
  return !isSuccess(self);
}
function isSuccess(self) {
  return fold_(self, (_) => true, (a, b) => a && b, (a, b) => a || b, (a) => !a);
}
function map_(self, f) {
  return chain_(self, (0, import_Function.flow)(f, success));
}
function map(f) {
  return (self) => map_(self, f);
}
function mapM_(self, f) {
  return chainM_(self, (a) => T.map_(f(a), success));
}
function mapM(f) {
  return (self) => mapM_(self, f);
}
function all(as2) {
  const arr = A.from(as2);
  if (A.isNonEmpty(arr)) {
    return O.some(A.reduce_(A.drop_(arr, 1), arr[0], and_));
  }
  return O.none;
}
function and_(left, right) {
  return new And(left, right);
}
function and(right) {
  return (left) => and_(left, right);
}
function any(as2) {
  const arr = A.from(as2);
  if (A.isNonEmpty(arr)) {
    const [init, ...rest] = arr;
    return O.some(A.reduce_(rest, init, or_));
  }
  return O.none;
}
function collectAll(as2) {
  return forEach(as2, import_Function.identity);
}
function failure(a) {
  return not(success(a));
}
function forEach(as2, f) {
  const arr = A.from(as2);
  if (A.isNonEmpty(arr)) {
    const result = NEA.map_(arr, f);
    return O.some(A.reduce_(NEA.tail(result), NEA.head(result), and_));
  }
  return O.none;
}
function not(result) {
  return new Not(result);
}
function or_(left, right) {
  return new Or(left, right);
}
function or(right) {
  return (left) => or_(left, right);
}
function success(a) {
  return new Value(a);
}
const unit = /* @__PURE__ */ success(void 0);
module.exports = __toCommonJS(BoolAlgebra_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  And,
  AndTypeId,
  BoolAlgebra,
  BoolAlgebraTypeId,
  Not,
  NotTypeId,
  Or,
  OrTypeId,
  Value,
  ValueTypeId,
  all,
  and,
  and_,
  any,
  as,
  as_,
  chain,
  chainM,
  chainM_,
  chain_,
  collectAll,
  concrete,
  failure,
  failures,
  fold,
  fold_,
  forEach,
  iff,
  iff_,
  implies,
  implies_,
  isAnd,
  isBoolAlgebra,
  isFailure,
  isNot,
  isOr,
  isSuccess,
  isValue,
  map,
  mapM,
  mapM_,
  map_,
  not,
  or,
  or_,
  success,
  unit
});
