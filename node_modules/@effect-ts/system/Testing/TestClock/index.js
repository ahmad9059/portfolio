var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var TestClock_exports = {};
__export(TestClock_exports, {
  Data: () => Data,
  Done: () => Done,
  Duration: () => Duration,
  Pending: () => Pending,
  Start: () => Start,
  Test: () => Test,
  TestClock: () => TestClock,
  defaultTestClock: () => defaultTestClock,
  live: () => live
});
var import_Case = require("../../Case/index.js");
var ClockId = __toESM(require("../../Clock/id.js"));
var Clock = __toESM(require("../../Clock/index.js"));
var Chunk = __toESM(require("../../Collections/Immutable/Chunk/index.js"));
var HashMap = __toESM(require("../../Collections/Immutable/HashMap/index.js"));
var List = __toESM(require("../../Collections/Immutable/List/index.js"));
var SortedSet = __toESM(require("../../Collections/Immutable/SortedSet/index.js"));
var Tuple = __toESM(require("../../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../../Effect/index.js"));
var Fiber = __toESM(require("../../Fiber/index.js"));
var import_Function = require("../../Function/index.js");
var import_Has = require("../../Has/index.js");
var L = __toESM(require("../../Layer/index.js"));
var M = __toESM(require("../../Managed/index.js"));
var O = __toESM(require("../../Option/index.js"));
var Ord = __toESM(require("../../Ord/index.js"));
var Promise2 = __toESM(require("../../Promise/index.js"));
var Ref = __toESM(require("../../Ref/index.js"));
var RefM = __toESM(require("../../RefM/index.js"));
var St = __toESM(require("../../Structural/index.js"));
var import_Annotations = require("../Annotations/index.js");
var import_FiberSet = require("../FiberSet/index.js");
var import_Live = require("../Live/index.js");
var import_TestAnnotation = require("../TestAnnotation/index.js");
function Duration(n) {
  return n;
}
const TestClock = /* @__PURE__ */ (0, import_Has.tag)(Clock.ClockId);
class Data extends (0, import_Case.Tagged)("Data") {
}
class Start extends (0, import_Case.TaggedADT)()("Start") {
}
class Done extends (0, import_Case.TaggedADT)()("Done") {
}
class Pending extends (0, import_Case.TaggedADT)()("Pending") {
}
class Test {
  constructor(clockState, live2, annotations, warningState) {
    this.clockState = clockState;
    this.live = live2;
    this.annotations = annotations;
    this.warningState = warningState;
    this.serviceId = ClockId.ClockId;
    this.adjust = (duration) => {
      return T.zipRight_(this.warningDone, this.run((_) => Duration(_ + duration)));
    };
    this.currentTime = T.map_(Ref.get(this.clockState), (d) => d.duration);
    this.save = T.map_(T.bind_(T.do, "clockData", () => Ref.get(this.clockState)), ({
      clockData
    }) => Ref.set_(this.clockState, clockData));
    this.setTime = (dateTime) => T.zipRight_(this.warningDone, this.run(() => Duration(dateTime)));
    this.sleep = (duration) => T.map_(T.tap_(T.bind_(T.bind_(T.do, "promise", () => Promise2.make()), "shouldAwait", ({
      promise
    }) => Ref.modify_(this.clockState, (data) => {
      const end = Duration(data.duration + duration);
      if (end > data.duration) {
        return Tuple.tuple(true, data.copy({
          sleeps: List.prepend(Tuple.tuple(end, promise))(data.sleeps)
        }));
      } else {
        return Tuple.tuple(false, data);
      }
    })), ({
      promise,
      shouldAwait
    }) => shouldAwait ? T.zipRight_(this.warningStart, Promise2.await(promise)) : Promise2.succeed_(promise, void 0)), () => void 0);
    this.sleeps = T.map_(Ref.get(this.clockState), (d) => List.map((_) => _.get(0))(d.sleeps));
    this.warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
    this.warningStart = RefM.updateSome((_) => {
      switch (_._tag) {
        case "Start": {
          return O.some(T.map_(T.bind_(T.do, "fiber", () => this.live.provide(T.fork(T.interruptible(T.delay_(T.succeedWith(() => {
            console.log(this.warning);
          }), 5e3))))), ({
            fiber
          }) => Pending.make({
            fiber
          })));
        }
        default:
          return O.none;
      }
    })(this.warningState);
    this.warningDone = RefM.updateSome((_) => {
      switch (_._tag) {
        case "Start": {
          return O.some(T.succeed(Done.make()));
        }
        case "Pending": {
          return O.some(T.as_(Fiber.interrupt(_.fiber), Done.make()));
        }
        default:
          return O.none;
      }
    })(this.warningState);
    this.supervisedFibers = T.descriptorWith((d) => T.chain_(this.annotations.get(import_TestAnnotation.fibers), (fa) => {
      switch (fa._tag) {
        case "Left": {
          return T.succeed(import_FiberSet.fiberSet);
        }
        case "Right": {
          return T.map_(T.map_(T.forEach_(fa.right, (ref) => T.succeedWith(() => ref.get)), Chunk.reduce(import_FiberSet.fiberSet, SortedSet.union_)), SortedSet.filter((_) => !St.equals(_.id, d.id)));
        }
      }
    }));
    this.freeze = T.chain_(this.supervisedFibers, T.reduce(HashMap.make(), (map, fiber) => T.chain_(fiber.status, (status) => {
      switch (status._tag) {
        case "Done": {
          return T.succeed(HashMap.set_(map, fiber.id, status));
        }
        case "Suspended": {
          return T.succeed(HashMap.set_(map, fiber.id, status));
        }
        default:
          return T.fail(void 0);
      }
    })));
    this.delay = this.live.provide(T.sleep(5));
    this.suspended = T.chain_(T.zip_(this.freeze, T.zipRight_(this.delay, this.freeze)), ({
      tuple: [first, last]
    }) => St.equals(first, last) ? T.succeed(first) : T.fail(void 0));
    this.awaitSuspended = T.asUnit(T.eventually(T.filterOrFail_(T.zipWith_(this.suspended, T.zipRight_(this.live.provide(T.sleep(10)), this.suspended), St.equals), import_Function.identity, () => void 0)));
    this.run = (f) => T.zipRight_(this.awaitSuspended, T.chain_(Ref.modify_(this.clockState, (data) => {
      const end = f(data.duration);
      const sorted = List.sortWith_(data.sleeps, Ord.contramap_(Ord.number, (_) => _.get(0)));
      if (!List.isEmpty(sorted)) {
        const {
          tuple: [duration, promise]
        } = List.unsafeFirst(sorted);
        const sleeps = List.tail(sorted);
        if (duration <= end) {
          return Tuple.tuple(O.some(Tuple.tuple(end, promise)), new Data({
            duration,
            sleeps
          }));
        }
      }
      return Tuple.tuple(O.none, new Data({
        duration: end,
        sleeps: data.sleeps
      }));
    }), (o) => {
      switch (o._tag) {
        case "None": {
          return T.unit;
        }
        case "Some": {
          return T.zipRight_(T.zipRight_(Promise2.succeed_(o.value.get(1), void 0), T.yieldNow), this.run(() => o.value.get(0)));
        }
      }
    }));
  }
}
function live(data) {
  return L.fromRawManaged(M.gen(function* (_) {
    const live2 = yield* _(import_Live.Live);
    const annotations = yield* _(import_Annotations.Annotations);
    const ref = yield* _(Ref.makeRef(data));
    const refM = yield* _(RefM.makeRefM(Start.make()));
    const test = yield* _(M.make_(T.succeedWith(() => new Test(ref, live2, annotations, refM)), (_2) => _2.warningDone));
    const testClock = TestClock.has(test);
    return testClock;
  }));
}
const defaultTestClock = /* @__PURE__ */ live(/* @__PURE__ */ new Data({
  duration: /* @__PURE__ */ Duration(0),
  sleeps: /* @__PURE__ */ List.empty()
}));
module.exports = __toCommonJS(TestClock_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Data,
  Done,
  Duration,
  Pending,
  Start,
  Test,
  TestClock,
  defaultTestClock,
  live
});
