var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Annotations_exports = {};
__export(Annotations_exports, {
  Annotations: () => Annotations,
  AnnotationsId: () => AnnotationsId,
  annotate: () => annotate,
  get: () => get,
  live: () => live,
  supervisedFibers: () => supervisedFibers,
  withAnnotation: () => withAnnotation
});
var Chunk = __toESM(require("../../Collections/Immutable/Chunk/index.js"));
var SortedSet = __toESM(require("../../Collections/Immutable/SortedSet/index.js"));
var Tuple = __toESM(require("../../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../../Effect/index.js"));
var FiberRef = __toESM(require("../../FiberRef/index.js"));
var import_Function = require("../../Function/index.js");
var import_Has = require("../../Has/index.js");
var L = __toESM(require("../../Layer/index.js"));
var St = __toESM(require("../../Structural/index.js"));
var import_FiberSet = require("../FiberSet/index.js");
var TestAnnotation = __toESM(require("../TestAnnotation/index.js"));
var TAM = __toESM(require("../TestAnnotationMap/index.js"));
const AnnotationsId = /* @__PURE__ */ Symbol();
const Annotations = /* @__PURE__ */ (0, import_Has.tag)(AnnotationsId);
const live = /* @__PURE__ */ L.fromEffect_(/* @__PURE__ */ T.gen(function* (_) {
  const fiberRef = yield* _(FiberRef.make(TAM.TestAnnotationMap.empty));
  const annotate2 = (key, value) => FiberRef.update_(fiberRef, TAM.annotate(key, value));
  const get2 = (key) => T.map_(FiberRef.get(fiberRef), TAM.get(key));
  const withAnnotation2 = (effect) => FiberRef.locally_(fiberRef, TAM.TestAnnotationMap.empty)(T.foldM_(effect, (e) => T.flip(T.map_(FiberRef.get(fiberRef), (_2) => Tuple.tuple(e, _2))), (a) => T.map_(FiberRef.get(fiberRef), (_2) => Tuple.tuple(a, _2))));
  const supervisedFibers2 = T.descriptorWith((d) => T.chain_(get2(TestAnnotation.fibers), (fa) => {
    switch (fa._tag) {
      case "Left": {
        return T.succeed(import_FiberSet.fiberSet);
      }
      case "Right": {
        return T.map_(T.map_(T.forEach_(fa.right, (ref) => T.succeedWith(() => ref.get)), Chunk.reduce(import_FiberSet.fiberSet, SortedSet.union_)), SortedSet.filter((_2) => !St.equals(_2.id, d.id)));
      }
    }
  }));
  const annotations = {
    serviceId: AnnotationsId,
    annotate: annotate2,
    get: get2,
    supervisedFibers: supervisedFibers2,
    withAnnotation: withAnnotation2
  };
  return annotations;
}), Annotations);
function withAnnotation(effect) {
  return T.accessServiceM(Annotations)((_) => _.withAnnotation(effect));
}
function annotate(key, value) {
  return T.accessServiceM(Annotations)((_) => _.annotate(key, value));
}
function get(key) {
  return T.accessServiceM(Annotations)((_) => _.get(key));
}
const supervisedFibers = /* @__PURE__ */ T.accessServiceM(Annotations)((_) => _.supervisedFibers);
module.exports = __toCommonJS(Annotations_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Annotations,
  AnnotationsId,
  annotate,
  get,
  live,
  supervisedFibers,
  withAnnotation
});
