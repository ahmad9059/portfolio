var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Transducer_exports = {};
__export(Transducer_exports, {
  Transducer: () => Transducer,
  branchAfter: () => branchAfter,
  collectAllN: () => collectAllN,
  collectAllToMapN: () => collectAllToMapN,
  collectAllWhile: () => collectAllWhile,
  collectAllWhileM: () => collectAllWhileM,
  die: () => die,
  dropWhile: () => dropWhile,
  dropWhileM: () => dropWhileM,
  fail: () => fail,
  filter: () => filter,
  filterInput: () => filterInput,
  filterInputM: () => filterInputM,
  filterInputM_: () => filterInputM_,
  filterInput_: () => filterInput_,
  filter_: () => filter_,
  fold: () => fold,
  foldLeft: () => foldLeft,
  foldLeftM: () => foldLeftM,
  foldM: () => foldM,
  foldUntil: () => foldUntil,
  foldUntilM: () => foldUntilM,
  foldWeighted: () => foldWeighted,
  foldWeightedDecompose: () => foldWeightedDecompose,
  foldWeightedDecomposeM: () => foldWeightedDecomposeM,
  fromEffect: () => fromEffect,
  fromFunction: () => fromFunction,
  fromFunctionM: () => fromFunctionM,
  fromPush: () => fromPush,
  halt: () => halt,
  head: () => head,
  identity: () => identity,
  last: () => last,
  map: () => map,
  mapChunks: () => mapChunks,
  mapChunksM: () => mapChunksM,
  mapChunksM_: () => mapChunksM_,
  mapChunks_: () => mapChunks_,
  mapError: () => mapError,
  mapError_: () => mapError_,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  prepend: () => prepend,
  then: () => then,
  transducer: () => transducer,
  unwrap: () => unwrap,
  unwrapManaged: () => unwrapManaged
});
var import_Operator = require("../../Operator/index.js");
var Chunk = __toESM(require("../../Collections/Immutable/Chunk/index.js"));
var Map = __toESM(require("../../Collections/Immutable/Map/index.js"));
var Tp = __toESM(require("../../Collections/Immutable/Tuple/index.js"));
var Ex = __toESM(require("../../Exit/index.js"));
var import_Function = require("../../Function/index.js");
var O = __toESM(require("../../Option/index.js"));
var RM = __toESM(require("../../RefM/index.js"));
var T = __toESM(require("../_internal/effect.js"));
var M = __toESM(require("../_internal/managed.js"));
var R = __toESM(require("../_internal/ref.js"));
class Transducer {
  constructor(push) {
    this.push = push;
  }
}
const transducer = (push) => new Transducer(push);
const then = (that) => (self) => transducer(M.zipWith_(self.push, that.push, (pushLeft, pushRight) => O.fold(() => T.chain_(pushLeft(O.none), (cl) => Chunk.isEmpty(cl) ? pushRight(O.none) : T.zipWith_(pushRight(O.some(cl)), pushRight(O.none), Chunk.concat_)), (inputs) => T.chain_(pushLeft(O.some(inputs)), (cl) => pushRight(O.some(cl))))));
function map_(fa, f) {
  return new Transducer(M.map_(fa.push, (push) => (input) => T.map_(push(input), Chunk.map(f))));
}
function map(f) {
  return (fa) => map_(fa, f);
}
function mapChunks_(fa, f) {
  return new Transducer(M.map_(fa.push, (push) => (input) => T.map_(push(input), f)));
}
function mapChunks(f) {
  return (fa) => mapChunks_(fa, f);
}
function mapChunksM_(fa, f) {
  return new Transducer(M.map_(fa.push, (push) => (input) => T.chain_(push(input), f)));
}
function mapChunksM(f) {
  return (fa) => mapChunksM_(fa, f);
}
function mapM_(fa, f) {
  return new Transducer(M.map_(fa.push, (push) => (input) => T.chain_(push(input), Chunk.mapEffect(f))));
}
function mapM(f) {
  return (fa) => mapM_(fa, f);
}
function mapError_(pab, f) {
  return new Transducer(M.map_(pab.push, (push) => (is) => T.mapError_(push(is), f)));
}
function mapError(f) {
  return (pab) => mapError_(pab, f);
}
function fail(e) {
  return new Transducer(M.succeed((_) => T.fail(e)));
}
function die(error) {
  return new Transducer(M.succeed((_) => T.die(error)));
}
function halt(c) {
  return new Transducer(M.succeed((_) => T.halt(c)));
}
function identity() {
  return fromPush(O.fold(() => T.succeed(Chunk.empty()), T.succeed));
}
function fromPush(push) {
  return new Transducer(M.succeed(push));
}
function fromEffect(task) {
  return new Transducer(M.succeed((_) => T.map_(task, Chunk.single)));
}
function fromFunction(f) {
  return map_(identity(), f);
}
function fromFunctionM(f) {
  return mapM_(identity(), f);
}
function head() {
  return foldLeft(O.none, (acc, o) => O.fold_(acc, () => O.some(o), () => acc));
}
function last() {
  return foldLeft(O.none, (_, o) => O.some(o));
}
function prepend(values) {
  return new Transducer(M.map_(R.makeManagedRef(values), (state) => (is) => O.fold_(is, () => R.getAndSet_(state, Chunk.empty()), (os) => T.map_(R.getAndSet_(state, Chunk.empty()), (c) => Chunk.isEmpty(c) ? os : Chunk.concat_(c, os)))));
}
function branchAfter(n, f) {
  const initialState = {
    _tag: "Collecting",
    data: Chunk.empty()
  };
  const toCollect = Math.max(0, n);
  return new Transducer(M.chain_(M.scope, (allocate) => M.map_(RM.makeManagedRefM(initialState), (state) => (is) => O.fold_(is, () => T.chain_(RM.getAndSet_(state, initialState), (s) => {
    switch (s._tag) {
      case "Collecting": {
        return M.use_(f(s.data).push, (f2) => f2(O.none));
      }
      case "Emitting": {
        return T.zipLeft_(s.push(O.none), s.finalizer(Ex.unit));
      }
    }
  }), (data) => RM.modify_(state, (s) => {
    switch (s._tag) {
      case "Emitting": {
        return T.map_(s.push(O.some(data)), (_) => Tp.tuple(_, s));
      }
      case "Collecting": {
        if (Chunk.isEmpty(data)) {
          return T.succeed(Tp.tuple(Chunk.empty(), s));
        } else {
          const remaining = toCollect - Chunk.size(s.data);
          if (remaining <= Chunk.size(data)) {
            const {
              tuple: [newCollected, remainder]
            } = Chunk.splitAt_(data, remaining);
            return T.chain_(allocate(f(Chunk.concat_(s.data, newCollected)).push), ({
              tuple: [finalizer, push]
            }) => T.map_(push(O.some(remainder)), (_) => Tp.tuple(_, {
              _tag: "Emitting",
              finalizer,
              push
            })));
          } else {
            return T.succeed(Tp.tuple(Chunk.empty(), {
              _tag: "Collecting",
              data: Chunk.concat_(s.data, data)
            }));
          }
        }
      }
    }
  })))));
}
function dropWhile(predicate) {
  return new Transducer(M.map_(R.makeManagedRef(true), (dropping) => (is) => O.fold_(is, () => T.succeed(Chunk.empty()), (is2) => R.modify_(dropping, (b) => {
    switch (b) {
      case true: {
        const is1 = Chunk.dropWhile_(is2, predicate);
        return Tp.tuple(is1, Chunk.isEmpty(is1));
      }
      case false: {
        return Tp.tuple(is2, false);
      }
    }
  }))));
}
function dropWhileM(p) {
  return new Transducer(M.map_(M.let_(M.bind_(M.do, "dropping", () => R.makeManagedRef(true)), "push", ({
    dropping
  }) => (is) => O.fold_(is, () => T.succeed(Chunk.empty()), (is2) => T.chain_(T.chain_(dropping.get, (b) => b ? T.map_(Chunk.dropWhileEffect_(is2, p), (l) => [l, Chunk.isEmpty(l)]) : T.succeed([is2, false])), ([is3, pt]) => T.as_(dropping.set(pt), is3)))), ({
    push
  }) => push));
}
function foldGo(in_, state, progress, initial, contFn, f) {
  return Chunk.reduce_(in_, [Chunk.empty(), state, progress], ([os0, state2, _], i) => {
    const o = f(state2, i);
    if (contFn(o)) {
      return [os0, o, true];
    } else {
      return [Chunk.append_(os0, o), initial, false];
    }
  });
}
function fold(initial, contFn, f) {
  return new Transducer(M.map_(R.makeManagedRef(O.some(initial)), (state) => (is) => O.fold_(is, () => T.map_(R.getAndSet_(state, O.none), O.fold(() => Chunk.empty(), Chunk.single)), (in_) => R.modify_(state, (s) => {
    const [o, s2, progress] = foldGo(in_, O.getOrElse_(s, () => initial), O.isSome(s), initial, contFn, f);
    if (progress) {
      return Tp.tuple(o, O.some(s2));
    } else {
      return Tp.tuple(o, O.none);
    }
  }))));
}
function foldLeft(initial, f) {
  return fold(initial, () => true, f);
}
function foldM(initial, contFn, f) {
  const init = O.some(initial);
  const go = (in_, state, progress) => Chunk.reduce_(in_, T.succeed([Chunk.empty(), state, progress]), (b, i) => T.chain_(b, ([os0, state2, _]) => T.map_(f(state2, i), (o) => {
    if (contFn(o)) {
      return [os0, o, true];
    } else {
      return [Chunk.append_(os0, o), initial, false];
    }
  })));
  return new Transducer(M.map_(R.makeManagedRef(init), (state) => (is) => O.fold_(is, () => T.map_(R.getAndSet_(state, O.none), O.fold(() => Chunk.empty(), Chunk.single)), (in_) => T.chain_(T.chain_(state.get, (s) => go(in_, O.getOrElse_(s, () => initial), O.isSome(s))), ([os, s, progress]) => progress ? T.zipRight_(state.set(O.some(s)), T.succeed(os)) : T.zipRight_(state.set(O.none), T.succeed(os))))));
}
function foldLeftM(initial, f) {
  return foldM(initial, () => true, f);
}
function foldUntil(initial, max, f) {
  return map((t) => t[0])(fold((0, import_Function.tuple)(initial, 0), ([_, n]) => n < max, ([o, count], i) => [f(o, i), count + 1]));
}
function foldUntilM(initial, max, f) {
  return map((t) => t[0])(foldM((0, import_Function.tuple)(initial, 0), ([_, n]) => n < max, ([o, count], i) => T.map_(f(o, i), (o2) => [o2, count + 1])));
}
function foldWeightedDecompose(initial, costFn, max, decompose, f) {
  const initialState = {
    result: initial,
    cost: 0
  };
  const go = (in_, os0, state, dirty) => Chunk.reduce_(in_, [os0, state, dirty], ([os02, state2, _], i) => {
    const total = state2.cost + costFn(state2.result, i);
    if (total > max) {
      const is = decompose(i);
      if (Chunk.size(is) <= 1 && !dirty) {
        return [Chunk.append_(os02, f(state2.result, !Chunk.isEmpty(is) ? Chunk.unsafeGet_(is, 0) : i)), initialState, false];
      } else if (Chunk.size(is) <= 1 && dirty) {
        const elem = !Chunk.isEmpty(is) ? Chunk.unsafeGet_(is, 0) : i;
        return [Chunk.append_(os02, state2.result), {
          result: f(initialState.result, elem),
          cost: costFn(initialState.result, elem)
        }, true];
      } else {
        return go(is, os02, state2, dirty);
      }
    } else {
      return [os02, {
        result: f(state2.result, i),
        cost: total
      }, true];
    }
  });
  return new Transducer(M.map_(R.makeManagedRef(O.some(initialState)), (state) => (is) => O.fold_(is, () => T.map_(R.getAndSet_(state, O.none), O.fold(() => Chunk.empty(), (s) => Chunk.single(s.result))), (in_) => R.modify_(state, (s) => {
    const [o, s2, dirty] = go(in_, Chunk.empty(), O.getOrElse_(s, () => initialState), O.isSome(s));
    if (dirty) {
      return Tp.tuple(o, O.some(s2));
    } else {
      return Tp.tuple(o, O.none);
    }
  }))));
}
function foldWeightedDecomposeM(initial, costFn, max, decompose, f) {
  const initialState = {
    result: initial,
    cost: 0
  };
  const go = (in_, os, state, dirty) => Chunk.reduce_(in_, T.succeed([os, state, dirty]), (o, i) => T.chain_(o, ([os2, state2, _]) => T.chain_(costFn(state2.result, i), (cost) => {
    const total = cost + state2.cost;
    if (total > max) {
      return T.chain_(decompose(i), (is) => {
        if (Chunk.size(is) <= 1 && !dirty) {
          return T.map_(f(state2.result, !Chunk.isEmpty(is) ? Chunk.unsafeGet_(is, 0) : i), (o2) => [Chunk.append_(os2, o2), initialState, false]);
        } else if (Chunk.size(is) <= 1 && dirty) {
          const elem = !Chunk.isEmpty(is) ? Chunk.unsafeGet_(is, 0) : i;
          return T.zipWith_(f(initialState.result, elem), costFn(initialState.result, elem), (result, cost2) => [Chunk.append_(os2, state2.result), {
            result,
            cost: cost2
          }, true]);
        } else {
          return go(is, os2, state2, dirty);
        }
      });
    } else {
      return T.map_(f(state2.result, i), (o2) => [os2, {
        result: o2,
        cost: total
      }, true]);
    }
  })));
  return new Transducer(M.map_(R.makeManagedRef(O.some(initialState)), (state) => (is) => O.fold_(is, () => T.map_(R.getAndSet_(state, O.none), O.fold(() => Chunk.empty(), (s) => Chunk.single(s.result))), (in_) => T.chain_(T.chain_(state.get, (s) => go(in_, Chunk.empty(), O.getOrElse_(s, () => initialState), O.isSome(s))), ([os, s, dirty]) => dirty ? T.zipRight_(state.set(O.some(s)), T.succeed(os)) : T.zipRight_(state.set(O.none), T.succeed(os))))));
}
function foldWeighted(initial, costFn, max, f) {
  return foldWeightedDecompose(initial, costFn, max, Chunk.single, f);
}
function collectAllNGo(n, in_, leftover, acc) {
  while (1) {
    const {
      tuple: [left, nextIn]
    } = Chunk.splitAt_(in_, n - Chunk.size(leftover));
    if (Chunk.size(leftover) + Chunk.size(left) < n)
      return Tp.tuple(acc, Chunk.concat_(leftover, left));
    else {
      const nextOut = !Chunk.isEmpty(leftover) ? Chunk.append_(acc, Chunk.concat_(leftover, left)) : Chunk.append_(acc, left);
      in_ = nextIn;
      leftover = Chunk.empty();
      acc = nextOut;
    }
  }
  throw new Error("Bug");
}
function collectAllN(n) {
  return new Transducer(M.map_(R.makeManagedRef(Chunk.empty()), (state) => (is) => O.fold_(is, () => T.map_(R.getAndSet_(state, Chunk.empty()), (leftover) => !Chunk.isEmpty(leftover) ? Chunk.single(leftover) : Chunk.empty()), (in_) => R.modify_(state, (leftover) => collectAllNGo(n, in_, leftover, Chunk.empty())))));
}
function collectAllToMapN(n, key, merge) {
  return filter((0, import_Function.not)(Map.isEmpty))(foldWeighted(Map.empty, (acc, i) => acc.has(key(i)) ? 0 : 1, n, (acc, i) => {
    const k = key(i);
    if (acc.has(k))
      return Map.insert(k, merge(acc.get(k), i))(acc);
    else
      return Map.insert(k, i)(acc);
  }));
}
function collectAllWhile(p) {
  return filter((x) => !Chunk.isEmpty(x))(map((t) => t[0])(fold([Chunk.empty(), true], (t) => t[1], ([is, _], i) => p(i) ? [Chunk.append_(is, i), true] : [is, false])));
}
function collectAllWhileM(p) {
  return filter((x) => !Chunk.isEmpty(x))(map((t) => t[0])(foldM([Chunk.empty(), true], (t) => t[1], ([is, _], i) => T.map_(p(i), (b) => b ? [Chunk.append_(is, i), true] : [is, false]))));
}
function filter_(fa, predicate) {
  return new Transducer(M.map_(fa.push, (push) => (is) => T.map_(push(is), Chunk.filter(predicate))));
}
function filter(predicate) {
  return (fa) => filter_(fa, predicate);
}
function filterInput_(fa, predicate) {
  return new Transducer(M.map_(fa.push, (push) => (is) => push(O.map_(is, Chunk.filter(predicate)))));
}
function filterInput(predicate) {
  return (fa) => filterInput_(fa, predicate);
}
function filterInputM_(fa, predicate) {
  return new Transducer(M.map_(fa.push, (push) => (is) => O.fold_(is, () => push(O.none), (x) => T.chain_(Chunk.filterEffect_(x, predicate), (in_) => push(O.some(in_))))));
}
function filterInputM(predicate) {
  return (fa) => filterInputM_(fa, predicate);
}
function unwrap(effect) {
  return unwrapManaged(T.toManaged(effect));
}
function unwrapManaged(managed) {
  return new Transducer(M.chain_(M.fold_(managed, (err) => fail(err), (_) => _), (_) => _.push));
}
module.exports = __toCommonJS(Transducer_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Transducer,
  branchAfter,
  collectAllN,
  collectAllToMapN,
  collectAllWhile,
  collectAllWhileM,
  die,
  dropWhile,
  dropWhileM,
  fail,
  filter,
  filterInput,
  filterInputM,
  filterInputM_,
  filterInput_,
  filter_,
  fold,
  foldLeft,
  foldLeftM,
  foldM,
  foldUntil,
  foldUntilM,
  foldWeighted,
  foldWeightedDecompose,
  foldWeightedDecomposeM,
  fromEffect,
  fromFunction,
  fromFunctionM,
  fromPush,
  halt,
  head,
  identity,
  last,
  map,
  mapChunks,
  mapChunksM,
  mapChunksM_,
  mapChunks_,
  mapError,
  mapError_,
  mapM,
  mapM_,
  map_,
  prepend,
  then,
  transducer,
  unwrap,
  unwrapManaged
});
