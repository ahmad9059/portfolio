var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Sink_exports = {};
__export(Sink_exports, {
  Sink: () => Sink,
  accessM: () => accessM,
  as: () => as,
  as_: () => as_,
  chain: () => chain,
  chain_: () => chain_,
  collectAll: () => collectAll,
  collectAllToList: () => collectAllToList,
  collectAllToMap: () => collectAllToMap,
  collectAllToSet: () => collectAllToSet,
  collectAllWhileWith: () => collectAllWhileWith,
  contramap: () => contramap,
  contramapChunks: () => contramapChunks,
  contramapChunksM: () => contramapChunksM,
  contramapChunksM_: () => contramapChunksM_,
  contramapChunks_: () => contramapChunks_,
  contramapM: () => contramapM,
  contramapM_: () => contramapM_,
  contramap_: () => contramap_,
  count: () => count,
  die: () => die,
  dieMessage: () => dieMessage,
  dimap: () => dimap,
  dimapChunks: () => dimapChunks,
  dimapChunksM: () => dimapChunksM,
  dimapChunksM_: () => dimapChunksM_,
  dimapChunks_: () => dimapChunks_,
  dimapM: () => dimapM,
  dimapM_: () => dimapM_,
  dimap_: () => dimap_,
  drain: () => drain,
  dropLeftover: () => dropLeftover,
  exposeLeftover: () => exposeLeftover,
  fail: () => fail,
  foldM: () => foldM,
  foldM_: () => foldM_,
  forEach: () => forEach,
  forEachChunk: () => forEachChunk,
  forEachWhile: () => forEachWhile,
  foreachChunk: () => foreachChunk,
  fromEffect: () => fromEffect,
  fromHub: () => fromHub,
  fromHubWithShutdown: () => fromHubWithShutdown,
  fromPush: () => fromPush,
  fromQueue: () => fromQueue,
  fromQueueWithShutdown: () => fromQueueWithShutdown,
  halt: () => halt,
  head: () => head,
  last: () => last,
  managed: () => managed,
  managedPush: () => managedPush,
  managed_: () => managed_,
  map: () => map,
  mapError: () => mapError,
  mapError_: () => mapError_,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  provideLayer: () => provideLayer,
  provideLayer_: () => provideLayer_,
  provideSome: () => provideSome,
  provideSomeLayer: () => provideSomeLayer,
  provideSome_: () => provideSome_,
  race: () => race,
  raceBoth: () => raceBoth,
  raceBoth_: () => raceBoth_,
  race_: () => race_,
  reduce: () => reduce,
  reduceChunks: () => reduceChunks,
  reduceChunksM: () => reduceChunksM,
  reduceLeft: () => reduceLeft,
  reduceLeftChunks: () => reduceLeftChunks,
  reduceLeftChunksM: () => reduceLeftChunksM,
  reduceLeftM: () => reduceLeftM,
  reduceM: () => reduceM,
  succeed: () => succeed,
  sum: () => sum,
  take: () => take,
  timed: () => timed,
  timedDrain: () => timedDrain,
  toTransducer: () => toTransducer,
  untilOutputM: () => untilOutputM,
  untilOutputM_: () => untilOutputM_,
  unwrap: () => unwrap,
  unwrapManaged: () => unwrapManaged,
  zip: () => zip,
  zipLeft: () => zipLeft,
  zipLeft_: () => zipLeft_,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParLeft_: () => zipParLeft_,
  zipParRight: () => zipParRight,
  zipParRight_: () => zipParRight_,
  zipPar_: () => zipPar_,
  zipRight: () => zipRight,
  zipRight_: () => zipRight_,
  zipWith: () => zipWith,
  zipWithPar: () => zipWithPar,
  zipWithPar_: () => zipWithPar_,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var import_Operator = require("../../Operator/index.js");
var C = __toESM(require("../../Cause/index.js"));
var import_Clock = require("../../Clock/index.js");
var A = __toESM(require("../../Collections/Immutable/Chunk/index.js"));
var List = __toESM(require("../../Collections/Immutable/List/index.js"));
var Tp = __toESM(require("../../Collections/Immutable/Tuple/index.js"));
var E = __toESM(require("../../Either/index.js"));
var Ex = __toESM(require("../../Exit/api.js"));
var import_Function = require("../../Function/index.js");
var H = __toESM(require("../../Hub/index.js"));
var L = __toESM(require("../../Layer/index.js"));
var O = __toESM(require("../../Option/index.js"));
var Q = __toESM(require("../../Queue/index.js"));
var import_Utils = require("../../Utils/index.js");
var T = __toESM(require("../_internal/effect.js"));
var F = __toESM(require("../_internal/fiber.js"));
var M = __toESM(require("../_internal/managed.js"));
var R = __toESM(require("../_internal/ref.js"));
var Push = __toESM(require("../Push/index.js"));
var import_Transducer = require("../Transducer/index.js");
class Sink {
  constructor(push) {
    this.push = push;
  }
}
function as_(self, z) {
  return map_(self, (_) => z);
}
function as(z) {
  return (self) => as_(self, z);
}
function collectAllWhileWith(z) {
  return (p) => (f) => (self) => new Sink(M.chain_(R.makeManagedRef(z), (acc) => {
    return M.map_(Push.restartable(self.push), ({
      tuple: [push, restart]
    }) => {
      const go = (s, in_, end) => T.catchAll_(T.as_(push(in_), s), ({
        tuple: [e, leftover]
      }) => E.fold_(e, (e2) => Push.fail(e2, leftover), (z2) => {
        if (p(z2)) {
          const s1 = f(s, z2);
          if (A.isEmpty(leftover)) {
            if (end) {
              return Push.emit(s1, A.empty());
            } else {
              return T.as_(restart, s1);
            }
          } else {
            return T.zipRight_(restart, go(s1, O.some(leftover), end));
          }
        } else {
          return Push.emit(s, leftover);
        }
      }));
      return (in_) => T.chain_(acc.get, (s) => T.chain_(go(s, in_, O.isNone(in_)), (s1) => acc.set(s1)));
    });
  }));
}
function contramap_(self, f) {
  return contramapChunks_(self, A.map(f));
}
function contramap(f) {
  return (self) => contramap_(self, f);
}
function contramapM_(self, f) {
  return contramapChunksM_(self, A.mapEffect(f));
}
function contramapM(f) {
  return (self) => contramapM_(self, f);
}
function contramapChunks_(self, f) {
  return new Sink(M.map_(self.push, (push) => (input) => push(O.map_(input, f))));
}
function contramapChunks(f) {
  return (self) => contramapChunks_(self, f);
}
function contramapChunksM_(self, f) {
  return new Sink(M.map_(self.push, (push) => {
    return (input) => O.fold_(input, () => push(O.none), (value) => T.chain_(T.mapError_(f(value), (e) => Tp.tuple(E.left(e), A.empty())), (is) => push(O.some(is))));
  }));
}
function contramapChunksM(f) {
  return (self) => contramapChunksM_(self, f);
}
function dimap_(self, f, g) {
  return map_(contramap_(self, f), g);
}
function dimap(f, g) {
  return (self) => dimap_(self, f, g);
}
function dimapM_(self, f, g) {
  return mapM_(contramapM_(self, f), g);
}
function dimapM(f, g) {
  return (self) => dimapM_(self, f, g);
}
function dimapChunks_(self, f, g) {
  return map_(contramapChunks_(self, f), g);
}
function dimapChunks(f, g) {
  return (self) => dimapChunks_(self, f, g);
}
function dimapChunksM_(self, f, g) {
  return mapM_(contramapChunksM_(self, f), g);
}
function dimapChunksM(f, g) {
  return (self) => dimapChunksM_(self, f, g);
}
function chain_(self, f) {
  return foldM_(self, (e) => fail(e)(), f);
}
function chain(f) {
  return (self) => chain_(self, f);
}
function foldM_(self, failure, success) {
  return new Sink(M.map_(M.bind_(M.bind_(M.bind_(M.bind_(M.do, "switched", () => T.toManaged(R.makeRef(false))), "thisPush", () => self.push), "thatPush", () => T.toManaged(R.makeRef((_) => T.unit))), "openThatPush", () => M.switchable()), ({
    openThatPush,
    switched,
    thatPush,
    thisPush
  }) => {
    return (in_) => T.chain_(switched.get, (sw) => {
      if (!sw) {
        return T.catchAll_(thisPush(in_), (v) => {
          const leftover = v[1];
          const nextSink = E.fold_(v[0], failure, success);
          return T.chain_(T.tap_(openThatPush(nextSink.push), thatPush.set), (p) => T.zipRight_(switched.set(true), O.fold_(in_, () => T.zipRight_(T.when_(p(O.some(leftover)), () => !A.isEmpty(leftover)), p(O.none)), () => T.when_(p(O.some(leftover)), () => !A.isEmpty(leftover)))));
        });
      } else {
        return T.chain_(thatPush.get, (p) => p(in_));
      }
    });
  }));
}
function foldM(failure, success) {
  return (self) => foldM_(self, failure, success);
}
function map_(self, f) {
  return new Sink(M.map_(self.push, (sink) => (inputs) => T.mapError_(sink(inputs), (e) => Tp.tuple(E.map_(e.get(0), f), e.get(1)))));
}
function map(f) {
  return (self) => map_(self, f);
}
function mapError_(self, f) {
  return new Sink(M.map_(self.push, (p) => {
    return (in_) => T.mapError_(p(in_), (e) => Tp.tuple(E.mapLeft_(e.get(0), f), e.get(1)));
  }));
}
function mapError(f) {
  return (self) => mapError_(self, f);
}
function mapM_(self, f) {
  return new Sink(M.map_(self.push, (push) => {
    return (inputs) => T.catchAll_(push(inputs), ({
      tuple: [e, left]
    }) => E.fold_(e, (e2) => Push.fail(e2, left), (z) => T.foldM_(f(z), (e2) => Push.fail(e2, left), (z2) => Push.emit(z2, left))));
  }));
}
function mapM(f) {
  return (self) => mapM_(self, f);
}
function race_(self, that) {
  return map_(raceBoth_(self, that), E.merge);
}
function race(that) {
  return (self) => race_(self, that);
}
function raceBoth_(self, that) {
  return new Sink(M.map_(M.bind_(M.bind_(M.do, "p1", () => self.push), "p2", () => that.push), ({
    p1,
    p2
  }) => (i) => T.raceWith_(p1(i), p2(i), (res1, fib2) => Ex.foldM_(res1, (f) => T.zipRight_(F.interrupt(fib2), T.halt(C.map(({
    tuple: [r, leftover]
  }) => Tp.tuple(E.map_(r, E.left), leftover))(f))), () => T.mapError_(F.join(fib2), ({
    tuple: [r, leftover]
  }) => Tp.tuple(E.map_(r, E.right), leftover))), (res2, fib1) => Ex.foldM_(res2, (f) => T.zipRight_(F.interrupt(fib1), T.halt(C.map(({
    tuple: [r, leftover]
  }) => Tp.tuple(E.map_(r, E.right), leftover))(f))), () => T.mapError_(F.join(fib1), ({
    tuple: [r, leftover]
  }) => Tp.tuple(E.map_(r, E.left), leftover))))));
}
function raceBoth(that) {
  return (self) => raceBoth_(self, that);
}
function timed(self) {
  return new Sink(M.zipWith_(self.push, T.toManaged(import_Clock.currentTime), (push, start) => {
    return (in_) => T.catchAll_(push(in_), ({
      tuple: [e, leftover]
    }) => E.fold_(e, (e2) => Push.fail(e2, leftover), (z) => T.chain_(import_Clock.currentTime, (stop) => Push.emit(Tp.tuple(z, stop - start), leftover))));
  }));
}
function toTransducer(self) {
  return (0, import_Transducer.transducer)(M.map_(Push.restartable(self.push), ({
    tuple: [push, restart]
  }) => {
    const go = (input) => T.foldM_(push(input), ({
      tuple: [e, leftover]
    }) => E.fold_(e, (e2) => T.fail(e2), (z) => T.zipRight_(restart, A.isEmpty(leftover) || O.isNone(input) ? T.succeed(A.single(z)) : T.map_(go(O.some(leftover)), (more) => A.prepend_(more, z)))), (_) => T.succeed(A.empty()));
    return (input) => go(input);
  }));
}
function zip_(self, that) {
  return zipWith_(self, that, Tp.tuple);
}
function zip(that) {
  return (self) => zip_(self, that);
}
function zipLeft_(self, that) {
  return zipWith_(self, that, (z) => z);
}
function zipLeft(that) {
  return (self) => zipLeft_(self, that);
}
function zipPar_(self, that) {
  return zipWithPar_(self, that, Tp.tuple);
}
function zipPar(that) {
  return (self) => zipPar_(self, that);
}
function zipParLeft_(self, that) {
  return zipWithPar_(self, that, (b, _) => b);
}
function zipParLeft(that) {
  return (self) => zipParLeft_(self, that);
}
function zipParRight_(self, that) {
  return zipWithPar_(self, that, (_, c) => c);
}
function zipParRight(that) {
  return (self) => zipParRight_(self, that);
}
function zipRight_(self, that) {
  return zipWith_(self, that, (_, z1) => z1);
}
function zipRight(that) {
  return (self) => zipRight_(self, that);
}
function zipWith_(self, that, f) {
  return chain_(self, (z) => map_(that, (_) => f(z, _)));
}
function zipWith(that, f) {
  return (self) => zipWith_(self, that, f);
}
class BothRunning {
  constructor() {
    this._tag = "BothRunning";
  }
}
const bothRunning = /* @__PURE__ */ new BothRunning();
class LeftDone {
  constructor(value) {
    this.value = value;
    this._tag = "LeftDone";
  }
}
class RightDone {
  constructor(value) {
    this.value = value;
    this._tag = "RightDone";
  }
}
function zipWithPar_(self, that, f) {
  return new Sink(M.map_(M.bind_(M.bind_(M.bind_(M.do, "ref", () => T.toManaged(R.makeRef(bothRunning))), "p1", () => self.push), "p2", () => that.push), ({
    p1,
    p2,
    ref
  }) => {
    return (in_) => T.chain_(ref.get, (state) => {
      const newState = (0, import_Utils.matchTag)({
        BothRunning: () => {
          const l = T.foldM_(p1(in_), ({
            tuple: [e, l2]
          }) => E.fold_(e, (e2) => Push.fail(e2, l2), (z) => T.succeed(O.some(Tp.tuple(z, l2)))), (_) => T.succeed(O.none));
          const r = T.foldM_(p2(in_), ({
            tuple: [e, l2]
          }) => E.fold_(e, (e2) => Push.fail(e2, l2), (z) => T.succeed(O.some(Tp.tuple(z, l2)))), (_) => T.succeed(O.none));
          return T.chain_(T.zipPar_(l, r), ({
            tuple: [lr, rr]
          }) => {
            if (O.isSome(lr)) {
              const [z, l2] = lr.value.tuple;
              if (O.isSome(rr)) {
                const [z1, l1] = rr.value.tuple;
                return T.fail(Tp.tuple(E.right(f(z, z1)), A.size(l2) > A.size(l1) ? l1 : l2));
              } else {
                return T.succeed(new LeftDone(z));
              }
            } else {
              if (O.isSome(rr)) {
                const [z1] = rr.value.tuple;
                return T.succeed(new RightDone(z1));
              } else {
                return T.succeed(bothRunning);
              }
            }
          });
        },
        LeftDone: ({
          value: z
        }) => T.as_(T.catchAll_(p2(in_), ({
          tuple: [e, leftover]
        }) => E.fold_(e, (e2) => Push.fail(e2, leftover), (z1) => Push.emit(f(z, z1), leftover))), state),
        RightDone: ({
          value: z1
        }) => T.as_(T.catchAll_(p1(in_), ({
          tuple: [e, leftover]
        }) => E.fold_(e, (e2) => Push.fail(e2, leftover), (z) => Push.emit(f(z, z1), leftover))), state)
      })(state);
      return T.chain_(newState, (ns) => ns === state ? T.unit : ref.set(ns));
    });
  }));
}
function zipWithPar(that, f) {
  return (self) => zipWithPar_(self, that, f);
}
function exposeLeftover(self) {
  return new Sink(M.map_(self.push, (p) => {
    return (in_) => T.mapError_(p(in_), ({
      tuple: [v, leftover]
    }) => Tp.tuple(E.map_(v, (z) => Tp.tuple(z, leftover)), A.empty()));
  }));
}
function dropLeftover(self) {
  return new Sink(M.map_(self.push, (p) => (in_) => T.mapError_(p(in_), ({
    tuple: [v, _]
  }) => Tp.tuple(v, A.empty()))));
}
function untilOutputMGo(in_, end, push, restart, f) {
  return T.catchAll_(push(in_), ({
    tuple: [e, leftover]
  }) => E.fold_(e, (e2) => Push.fail(e2, leftover), (z) => T.chain_(T.mapError_(f(z), (err) => Tp.tuple(E.left(err), leftover)), (satisfied) => {
    if (satisfied) {
      return Push.emit(O.some(z), leftover);
    } else if (A.isEmpty(leftover)) {
      return end ? Push.emit(O.none, A.empty()) : T.zipRight_(restart, Push.more);
    } else {
      return untilOutputMGo(O.some(leftover), end, push, restart, f);
    }
  })));
}
function untilOutputM_(self, f) {
  return new Sink(M.map_(Push.restartable(self.push), ({
    tuple: [push, restart]
  }) => (is) => untilOutputMGo(is, O.isNone(is), push, restart, f)));
}
function untilOutputM(f) {
  return (self) => untilOutputM_(self, f);
}
function provideAll_(self, r) {
  return new Sink(M.map_(M.provideAll_(self.push, r), (push) => (i) => T.provideAll_(push(i), r)));
}
function provideAll(r) {
  return (self) => provideAll_(self, r);
}
function provideSome_(self, f) {
  return new Sink(M.map_(M.provideSome_(self.push, f), (push) => (i) => T.provideSome_(push(i), f)));
}
function provideSome(f) {
  return (self) => provideSome_(self, f);
}
function provideLayer(layer) {
  return (self) => provideLayer_(self, layer);
}
function provideLayer_(self, layer) {
  return new Sink(M.chain_(L.build(layer), (r) => M.map_(M.provideAll_(self.push, r), (push) => (i) => T.provideAll_(push(i), r))));
}
function provideSomeLayer(layer) {
  return (self) => provideLayer(layer["+++"](L.identity()))(self);
}
function managedPush(push) {
  return new Sink(push);
}
function accessM(f) {
  return new Sink(M.chain_(M.environment(), (env) => f(env).push));
}
function collectAll() {
  return reduceLeftChunks(A.empty())((s, i) => A.concat_(s, i));
}
function collectAllToList() {
  return reduceLeftChunks(List.empty())((s, i) => List.concat_(s, List.from(i)));
}
function collectAllToMap(key) {
  return (f) => new Sink(M.suspend(() => reduceLeftChunks(/* @__PURE__ */ new Map())((acc, as2) => A.reduce_(as2, acc, (acc2, a) => {
    const k = key(a);
    const v = acc2.get(k);
    return acc2.set(k, v ? f(v, a) : a);
  })).push));
}
function collectAllToSet() {
  return map_(collectAll(), (as2) => new Set(as2));
}
const count = /* @__PURE__ */ reduceLeft(0)((s, _) => s + 1);
function die(e) {
  return halt(C.die(e));
}
function dieMessage(m) {
  return halt(C.die(new C.RuntimeError(m)));
}
const drain = /* @__PURE__ */ dropLeftover(/* @__PURE__ */ forEach((_) => T.unit));
function fail(e) {
  return () => fromPush((c) => {
    const leftover = O.fold_(c, () => A.empty(), (x) => x);
    return Push.fail(e, leftover);
  });
}
const reduceChunkGo = (s, chunk, idx, len, contFn, f) => {
  if (idx === len) {
    return [s, O.none];
  } else {
    const s1 = f(s, A.unsafeGet_(chunk, idx));
    if (contFn(s1)) {
      return reduceChunkGo(s1, chunk, idx + 1, len, contFn, f);
    } else {
      return [s1, O.some(A.drop_(chunk, idx + 1))];
    }
  }
};
function reduce(z, contFn, f) {
  if (contFn(z)) {
    return new Sink(M.map_(M.bind_(M.do, "state", () => T.toManaged(R.makeRef(z))), ({
      state
    }) => (is) => O.fold_(is, () => T.chain_(state.get, (s) => Push.emit(s, A.empty())), (is2) => T.chain_(state.get, (s) => {
      const [st, l] = reduceChunkGo(s, is2, 0, A.size(is2), contFn, f);
      return O.fold_(l, () => T.zipRight_(state.set(st), Push.more), (leftover) => Push.emit(st, leftover));
    }))));
  } else {
    return succeed(z);
  }
}
function reduceChunks(z) {
  return (contFn) => (f) => reduceChunksM(z)(contFn)((z2, i) => T.succeed(f(z2, i)));
}
function reduceChunksM(z) {
  return (contFn) => (f) => {
    if (contFn(z)) {
      return new Sink(M.map_(M.bind_(M.do, "state", () => T.toManaged(R.makeRef(z))), ({
        state
      }) => {
        return (is) => O.fold_(is, () => T.chain_(state.get, (s) => Push.emit(s, A.empty())), (is2) => T.chain_(T.mapError_(T.chain_(state.get, (_) => f(_, is2)), (e) => Tp.tuple(E.left(e), A.empty())), (s) => {
          if (contFn(s)) {
            return T.zipRight_(state.set(s), Push.more);
          } else {
            return Push.emit(s, A.empty());
          }
        }));
      }));
    } else {
      return succeed(z);
    }
  };
}
function reduceMGo(s, chunk, idx, len, contFn, f) {
  if (idx === len) {
    return T.succeed([s, O.none]);
  } else {
    return T.foldM_(f(s, A.unsafeGet_(chunk, idx)), (e) => T.fail([e, A.drop_(chunk, idx + 1)]), (s1) => contFn(s1) ? reduceMGo(s1, chunk, idx + 1, len, contFn, f) : T.succeed([s1, O.some(A.drop_(chunk, idx + 1))]));
  }
}
function reduceM(z, contFn, f) {
  if (contFn(z)) {
    return new Sink(M.map_(M.bind_(M.do, "state", () => T.toManaged(R.makeRef(z))), ({
      state
    }) => (is) => O.fold_(is, () => T.chain_(state.get, (s) => Push.emit(s, A.empty())), (is2) => T.chain_(state.get, (s) => T.foldM_(reduceMGo(s, is2, 0, A.size(is2), contFn, f), (err) => Push.fail(...err), ([st, l]) => O.fold_(l, () => T.zipRight_(state.set(st), Push.more), (leftover) => Push.emit(st, leftover)))))));
  } else {
    return succeed(z);
  }
}
function reduceLeft(z) {
  return (f) => dropLeftover(reduce(z, (_) => true, f));
}
function reduceLeftChunks(z) {
  return (f) => dropLeftover(reduceChunks(z)(() => true)(f));
}
function reduceLeftChunksM(z) {
  return (f) => dropLeftover(reduceChunksM(z)((_) => true)(f));
}
function reduceLeftM(z) {
  return (f) => dropLeftover(reduceM(z, (_) => true, f));
}
function forEachGo(chunk, idx, len, f) {
  if (idx === len) {
    return Push.more;
  } else {
    return T.foldM_(f(A.unsafeGet_(chunk, idx)), (e) => Push.fail(e, A.drop_(chunk, idx + 1)), () => forEachGo(chunk, idx + 1, len, f));
  }
}
function forEach(f) {
  return fromPush(O.fold(() => Push.emit(void 0, A.empty()), (is) => forEachGo(is, 0, A.size(is), f)));
}
function forEachChunk(f) {
  return fromPush((in_) => O.fold_(in_, () => Push.emit(void 0, A.empty()), (is) => T.zipRight_(T.mapError_(f(is), (e) => Tp.tuple(E.left(e), A.empty())), Push.more)));
}
function forEachWhile(f) {
  const go = (chunk, idx, len) => {
    if (idx === len) {
      return Push.more;
    } else {
      return T.foldM_(f(A.unsafeGet_(chunk, idx)), (e) => Push.fail(e, A.drop_(chunk, idx + 1)), (b) => {
        if (b) {
          return go(chunk, idx + 1, len);
        } else {
          return Push.emit(void 0, A.drop_(chunk, idx));
        }
      });
    }
  };
  return fromPush((in_) => O.fold_(in_, () => Push.emit(void 0, A.empty()), (is) => go(is, 0, A.size(is))));
}
function fromEffect(b) {
  return () => fromPush((in_) => {
    const leftover = O.fold_(in_, () => A.empty(), import_Function.identity);
    return T.foldM_(b, (e) => Push.fail(e, leftover), (z) => Push.emit(z, leftover));
  });
}
function fromPush(push) {
  return new Sink(M.succeed(push));
}
function halt(e) {
  return fromPush((_) => Push.halt(e));
}
function head() {
  return new Sink(M.succeed((in_) => O.fold_(in_, () => Push.emit(O.none, A.empty()), (ch) => A.isEmpty(ch) ? Push.more : Push.emit(A.head(ch), A.empty()))));
}
function last() {
  return new Sink(M.map_(M.bind_(M.do, "state", () => T.toManaged(R.makeRef(O.none))), ({
    state
  }) => (is) => T.chain_(state.get, (last2) => O.fold_(is, () => Push.emit(last2, A.empty()), (ch) => O.fold_(A.last(ch), () => Push.more, (l) => T.zipRight_(state.set(O.some(l)), Push.more))))));
}
function managed_(resource, fn) {
  return M.chain_(M.fold_(resource, (err) => fail(err)(), (m) => fn(m)), (_) => _.push);
}
function managed(resource) {
  return (fn) => managed_(resource, fn);
}
function succeed(z) {
  return fromPush((c) => {
    const leftover = O.fold_(c, () => A.empty(), (x) => x);
    return Push.emit(z, leftover);
  });
}
const sum = /* @__PURE__ */ reduceLeft(0)((a, b) => a + b);
function take(n) {
  return new Sink(M.map_(M.bind_(M.do, "state", () => T.toManaged(R.makeRef(A.empty()))), ({
    state
  }) => {
    return (is) => T.chain_(state.get, (take2) => O.fold_(is, () => {
      if (n >= 0) {
        return Push.emit(take2, A.empty());
      } else {
        return Push.emit(A.empty(), take2);
      }
    }, (ch) => {
      const remaining = n - A.size(take2);
      if (remaining <= A.size(ch)) {
        const {
          tuple: [chunk, leftover]
        } = A.splitAt_(ch, remaining);
        return T.zipRight_(state.set(A.empty()), Push.emit(A.concat_(take2, chunk), leftover));
      } else {
        return T.zipRight_(state.set(A.concat_(take2, ch)), Push.more);
      }
    }));
  }));
}
const timedDrain = /* @__PURE__ */ map_(/* @__PURE__ */ timed(drain), (_) => _.get(1));
function foreachChunk(f) {
  return fromPush((o) => O.fold_(o, () => Push.emit(void 0, A.empty()), (is) => T.zipRight_(T.mapError_(f(is), (e) => Tp.tuple(E.left(e), A.empty())), Push.more)));
}
function fromQueue(queue) {
  return forEachChunk((x) => Q.offerAll_(queue, x));
}
function fromQueueWithShutdown(queue) {
  return new Sink(M.chain_(M.map_(M.make_(T.succeed(queue), Q.shutdown), fromQueue), (_) => _.push));
}
function fromHub(hub) {
  return fromQueue(H.toQueue(hub));
}
function fromHubWithShutdown(hub) {
  return fromQueueWithShutdown(H.toQueue(hub));
}
function unwrap(effect) {
  return unwrapManaged(T.toManaged(effect));
}
function unwrapManaged(managed2) {
  return new Sink(M.chain_(M.fold_(managed2, (err) => fail(err)(), (_) => _), (_) => _.push));
}
module.exports = __toCommonJS(Sink_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Sink,
  accessM,
  as,
  as_,
  chain,
  chain_,
  collectAll,
  collectAllToList,
  collectAllToMap,
  collectAllToSet,
  collectAllWhileWith,
  contramap,
  contramapChunks,
  contramapChunksM,
  contramapChunksM_,
  contramapChunks_,
  contramapM,
  contramapM_,
  contramap_,
  count,
  die,
  dieMessage,
  dimap,
  dimapChunks,
  dimapChunksM,
  dimapChunksM_,
  dimapChunks_,
  dimapM,
  dimapM_,
  dimap_,
  drain,
  dropLeftover,
  exposeLeftover,
  fail,
  foldM,
  foldM_,
  forEach,
  forEachChunk,
  forEachWhile,
  foreachChunk,
  fromEffect,
  fromHub,
  fromHubWithShutdown,
  fromPush,
  fromQueue,
  fromQueueWithShutdown,
  halt,
  head,
  last,
  managed,
  managedPush,
  managed_,
  map,
  mapError,
  mapError_,
  mapM,
  mapM_,
  map_,
  provideAll,
  provideAll_,
  provideLayer,
  provideLayer_,
  provideSome,
  provideSomeLayer,
  provideSome_,
  race,
  raceBoth,
  raceBoth_,
  race_,
  reduce,
  reduceChunks,
  reduceChunksM,
  reduceLeft,
  reduceLeftChunks,
  reduceLeftChunksM,
  reduceLeftM,
  reduceM,
  succeed,
  sum,
  take,
  timed,
  timedDrain,
  toTransducer,
  untilOutputM,
  untilOutputM_,
  unwrap,
  unwrapManaged,
  zip,
  zipLeft,
  zipLeft_,
  zipPar,
  zipParLeft,
  zipParLeft_,
  zipParRight,
  zipParRight_,
  zipPar_,
  zipRight,
  zipRight_,
  zipWith,
  zipWithPar,
  zipWithPar_,
  zipWith_,
  zip_
});
