var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var debounce_exports = {};
__export(debounce_exports, {
  debounce: () => debounce,
  debounce_: () => debounce_
});
var C = __toESM(require("../../Cause/index.js"));
var CL = __toESM(require("../../Clock/index.js"));
var A = __toESM(require("../../Collections/Immutable/Chunk/index.js"));
var Ex = __toESM(require("../../Exit/index.js"));
var import_Function = require("../../Function/index.js");
var O = __toESM(require("../../Option/index.js"));
var Scope = __toESM(require("../../Scope/index.js"));
var T = __toESM(require("../_internal/effect.js"));
var F = __toESM(require("../_internal/fiber.js"));
var M = __toESM(require("../_internal/managed.js"));
var Ref = __toESM(require("../_internal/ref.js"));
var Pull = __toESM(require("../Pull/index.js"));
var import_definitions = require("./definitions.js");
function debounce_(self, d) {
  class NotStarted {
    constructor() {
      this._tag = "NotStarted";
    }
  }
  class Previous {
    constructor(fiber) {
      this.fiber = fiber;
      this._tag = "Previous";
    }
  }
  class Current {
    constructor(fiber) {
      this.fiber = fiber;
      this._tag = "Current";
    }
  }
  class Done {
    constructor() {
      this._tag = "Done";
    }
  }
  return new import_definitions.Stream(M.map_(M.let_(M.bind_(M.bind_(M.do, "chunks", () => self.proc), "ref", () => T.toManagedRelease_(Ref.makeRef(new NotStarted()), (_) => T.chain_(_.get, (state) => {
    switch (state._tag) {
      case "Previous":
        return F.interrupt(state.fiber);
      case "Current":
        return F.interrupt(state.fiber);
      default:
        return T.unit;
    }
  }))), "pull", ({
    chunks,
    ref
  }) => {
    const store = (chunk) => T.as_(O.getOrElse_(O.map_(A.last(chunk), (last) => T.chain_(T.forkDaemon(T.as_(CL.sleep(d), last)), (f) => ref.set(new Previous(f)))), () => ref.set(new NotStarted())), A.empty());
    return T.chain_(ref.get, (state) => {
      switch (state._tag) {
        case "Previous":
          return T.transplant((graft) => T.raceWithScope_(F.join(state.fiber), graft(chunks), (ex, current) => {
            if (Ex.succeeded(ex)) {
              return T.as_(ref.set(new Current(current)), A.single(ex.value));
            } else {
              return T.zipRight_(F.interrupt(current), Pull.halt(ex.cause));
            }
          }, (ex, previous) => {
            if (Ex.succeeded(ex)) {
              const chunk = ex.value;
              if (A.isEmpty(chunk)) {
                return Pull.empty();
              } else {
                return T.zipRight_(F.interrupt(previous), store(chunk));
              }
            } else {
              return O.fold_(C.sequenceCauseOption(ex.cause), () => T.zipLeft_(T.map_(F.join(previous), A.single), ref.set(new Done())), (e) => T.zipRight_(F.interrupt(previous), Pull.halt(e)));
            }
          }, Scope.globalScope));
        case "Current":
          return T.chain_(F.join(state.fiber), store);
        case "NotStarted":
          return T.chain_(chunks, store);
        case "Done":
          return Pull.end;
      }
    });
  }), ({
    pull
  }) => pull));
}
function debounce(d) {
  return (self) => debounce_(self, d);
}
module.exports = __toCommonJS(debounce_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  debounce,
  debounce_
});
