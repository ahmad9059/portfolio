var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var groupBy_exports = {};
__export(groupBy_exports, {
  groupBy: () => groupBy,
  groupBy_: () => groupBy_
});
var MP = __toESM(require("../../Collections/Immutable/Map/index.js"));
var Tp = __toESM(require("../../Collections/Immutable/Tuple/index.js"));
var Ex = __toESM(require("../../Exit/index.js"));
var import_Function = require("../../Function/index.js");
var O = __toESM(require("../../Option/index.js"));
var P = __toESM(require("../../Promise/index.js"));
var Q = __toESM(require("../../Queue/index.js"));
var T = __toESM(require("../_internal/effect.js"));
var M = __toESM(require("../_internal/managed.js"));
var Ref = __toESM(require("../_internal/ref.js"));
var GB = __toESM(require("../GroupBy/index.js"));
var import_distributedWithDynamic = require("./distributedWithDynamic.js");
var import_flattenExitOption = require("./flattenExitOption.js");
var import_fromQueueWithShutdown = require("./fromQueueWithShutdown.js");
var import_mapM = require("./mapM.js");
var import_unwrapManaged = require("./unwrapManaged.js");
function groupBy_(self, f, buffer = 16) {
  const qstream = (0, import_unwrapManaged.unwrapManaged)(M.map_(M.tap_(M.bind_(M.bind_(M.bind_(M.bind_(M.do, "decider", () => T.toManaged(P.make())), "out", () => T.toManagedRelease_(Q.makeBounded(buffer), Q.shutdown)), "ref", () => T.toManaged(Ref.makeRef(MP.empty))), "add", ({
    decider,
    out
  }) => (0, import_distributedWithDynamic.distributedWithDynamic)(buffer, (kv) => T.chain_(P.await(decider), (_) => _(...kv.tuple)), (x) => Q.offer_(out, x))((0, import_mapM.mapM_)(self, f))), ({
    add,
    decider,
    out,
    ref
  }) => T.toManaged(P.succeed_(decider, (k, _) => T.chain_(T.map_(ref.get, MP.lookup(k)), O.fold(() => T.chain_(add, ({
    tuple: [idx, q]
  }) => T.as_(T.zipRight_(Ref.update_(ref, MP.insert(k, idx)), Q.offer_(out, Ex.succeed(Tp.tuple(k, Q.map_(q, (ex) => Ex.map_(ex, (_2) => _2.get(1))))))), (_2) => _2 === idx)), (idx) => T.succeed((_2) => _2 === idx)))))), ({
    out
  }) => (0, import_flattenExitOption.flattenExitOption)((0, import_fromQueueWithShutdown.fromQueueWithShutdown)(out))));
  return new GB.GroupBy(qstream, buffer);
}
function groupBy(f, buffer = 16) {
  return (self) => groupBy_(self, f, buffer);
}
module.exports = __toCommonJS(groupBy_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  groupBy,
  groupBy_
});
