var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var api_exports = {};
__export(api_exports, {
  collect: () => collect,
  collect_: () => collect_,
  contramap: () => contramap,
  contramapEither: () => contramapEither,
  contramapEither_: () => contramapEither_,
  contramap_: () => contramap_,
  dimap: () => dimap,
  dimapEither: () => dimapEither,
  dimapEither_: () => dimapEither_,
  dimapError: () => dimapError,
  dimapError_: () => dimapError_,
  dimap_: () => dimap_,
  filterInput: () => filterInput,
  filterInput_: () => filterInput_,
  filterOutput: () => filterOutput,
  filterOutput_: () => filterOutput_,
  fold: () => fold,
  foldAll: () => foldAll,
  foldAll_: () => foldAll_,
  fold_: () => fold_,
  get: () => get,
  getAndSet: () => getAndSet,
  getAndSet_: () => getAndSet_,
  getAndUpdate: () => getAndUpdate,
  getAndUpdateSome: () => getAndUpdateSome,
  getAndUpdateSome_: () => getAndUpdateSome_,
  getAndUpdate_: () => getAndUpdate_,
  makeRef: () => makeRef,
  map: () => map,
  mapEither: () => mapEither,
  mapEither_: () => mapEither_,
  map_: () => map_,
  modify: () => modify,
  modifySome: () => modifySome,
  modifySome_: () => modifySome_,
  modify_: () => modify_,
  readOnly: () => readOnly,
  set: () => set,
  set_: () => set_,
  unsafeMakeRef: () => unsafeMakeRef,
  update: () => update,
  updateAndGet: () => updateAndGet,
  updateAndGet_: () => updateAndGet_,
  updateSome: () => updateSome,
  updateSomeAndGet: () => updateSomeAndGet,
  updateSomeAndGet_: () => updateSomeAndGet_,
  updateSome_: () => updateSome_,
  update_: () => update_,
  writeOnly: () => writeOnly
});
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var absolve = __toESM(require("../Effect/absolve.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var O = __toESM(require("../Option/index.js"));
var import_AtomicReference = require("../Support/AtomicReference/index.js");
var import_Utils = require("../Utils/index.js");
var A = __toESM(require("./atomic.js"));
var T = __toESM(require("./effect.js"));
var import_XRef = require("./XRef.js");
function makeRef(a) {
  return T.succeedWith(() => new import_XRef.Atomic(new import_AtomicReference.AtomicReference(a)));
}
function unsafeMakeRef(a) {
  return new import_XRef.Atomic(new import_AtomicReference.AtomicReference(a));
}
function collect(pf) {
  return (self) => collect_(self, pf);
}
function collect_(self, pf) {
  return self.fold(import_Function.identity, O.some, E.right, (b) => E.fromOption_(pf(b), () => O.none));
}
function contramap(f) {
  return (self) => contramap_(self, f);
}
function contramap_(self, f) {
  return contramapEither_(self, (c) => E.right(f(c)));
}
function contramapEither(f) {
  return (self) => contramapEither_(self, f);
}
function contramapEither_(self, f) {
  return dimapEither_(self, f, (x) => E.right(x));
}
function dimap(f, g) {
  return (self) => dimap_(self, f, g);
}
function dimap_(self, f, g) {
  return dimapEither_(self, (c) => E.right(f(c)), (b) => E.right(g(b)));
}
function dimapEither(f, g) {
  return (self) => dimapEither_(self, f, g);
}
function dimapEither_(self, f, g) {
  return self.fold((ea) => ea, (eb) => eb, f, g);
}
function dimapError(f, g) {
  return (self) => dimapError_(self, f, g);
}
function dimapError_(self, f, g) {
  return self.fold(f, g, E.right, E.right);
}
function filterInput(f) {
  return (self) => filterInput_(self, f);
}
function filterInput_(self, f) {
  return self.fold(O.some, import_Function.identity, (a) => f(a) ? E.right(a) : E.left(O.none), E.right);
}
function filterOutput(f) {
  return (_) => filterOutput_(_, f);
}
function filterOutput_(_, f) {
  return _.fold(import_Function.identity, O.some, E.right, (b) => f(b) ? E.right(b) : E.left(O.none));
}
function map(f) {
  return (_) => map_(_, f);
}
function map_(_, f) {
  return mapEither_(_, (b) => E.right(f(b)));
}
function mapEither(f) {
  return (_) => mapEither_(_, f);
}
function mapEither_(_, f) {
  return dimapEither_(_, (a) => E.right(a), f);
}
function readOnly(_) {
  return _;
}
function writeOnly(_) {
  return _.fold(import_Function.identity, () => void 0, E.right, () => E.left(void 0));
}
function modify(f) {
  return (self) => modify_(self, f);
}
function modify_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.modify(_, f),
    Derived: (self2) => self2.use((value, getEither, setEither) => absolve.absolve(A.modify(value, (s) => E.fold_(getEither(s), (e) => Tp.tuple(E.left(e), s), (a1) => (({
      tuple: [b, a2]
    }) => E.fold_(setEither(a2), (e) => Tp.tuple(E.left(e), s), (s2) => Tp.tuple(E.right(b), s2)))(f(a1)))))),
    DerivedAll: (self2) => self2.use((value, getEither, setEither) => absolve.absolve(A.modify(value, (s) => E.fold_(getEither(s), (e) => Tp.tuple(E.left(e), s), (a1) => (({
      tuple: [b, a2]
    }) => E.fold_(setEither(a2)(s), (e) => Tp.tuple(E.left(e), s), (s2) => Tp.tuple(E.right(b), s2)))(f(a1))))))
  })(self);
}
function modifySome(def, f) {
  return (self) => modifySome_(self, def, f);
}
function modifySome_(self, def, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.modifySome(_, def, f)
  }, (_) => modify_(_, (a) => O.getOrElse_(f(a), () => Tp.tuple(def, a))))(self);
}
function getAndSet(a) {
  return (self) => getAndSet_(self, a);
}
function getAndSet_(self, a) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.getAndSet(_, a)
  }, (_) => modify_(_, (v) => Tp.tuple(v, a)))(self);
}
function getAndUpdate(f) {
  return (self) => getAndUpdate_(self, f);
}
function getAndUpdate_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.getAndUpdate(_, f)
  }, modify((v) => Tp.tuple(v, f(v))))(self);
}
function getAndUpdateSome(f) {
  return (self) => getAndUpdateSome_(self, f);
}
function getAndUpdateSome_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.getAndUpdateSome(_, f)
  }, (_) => modify_(_, (v) => ((a) => Tp.tuple(v, a))(O.getOrElse_(f(v), () => v))))(self);
}
function update(f) {
  return (self) => update_(self, f);
}
function update_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.update(_, f)
  }, (_) => modify_(_, (v) => Tp.tuple(void 0, f(v))))(self);
}
function updateAndGet(f) {
  return (self) => updateAndGet_(self, f);
}
function updateAndGet_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.updateAndGet(_, f)
  }, (self2) => T.chain_(modify_(self2, (v) => ((result) => Tp.tuple(result, result))(f(v))), () => self2.get))(self);
}
function updateSome(f) {
  return (self) => updateSome_(self, f);
}
function updateSome_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.updateSome(_, f)
  }, modify((v) => ((a) => Tp.tuple(void 0, a))(O.getOrElse_(f(v), () => v))))(self);
}
function updateSomeAndGet(f) {
  return (self) => updateSomeAndGet_(self, f);
}
function updateSomeAndGet_(self, f) {
  return (0, import_Utils.matchTag)({
    Atomic: (_) => A.updateSomeAndGet(_, f)
  }, (_) => modify_(_, (v) => ((result) => Tp.tuple(result, result))(O.getOrElse_(f(v), () => v))))(self);
}
function fold(ea, eb, ca, bd) {
  return (self) => self.fold(ea, eb, ca, bd);
}
function fold_(self, ea, eb, ca, bd) {
  return self.fold(ea, eb, ca, bd);
}
function foldAll(ea, eb, ec, ca, bd) {
  return (self) => self.foldAll(ea, eb, ec, ca, bd);
}
function foldAll_(self, ea, eb, ec, ca, bd) {
  return self.foldAll(ea, eb, ec, ca, bd);
}
function get(self) {
  return self.get;
}
function set(a) {
  return (self) => self.set(a);
}
function set_(self, a) {
  return self.set(a);
}
module.exports = __toCommonJS(api_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  collect,
  collect_,
  contramap,
  contramapEither,
  contramapEither_,
  contramap_,
  dimap,
  dimapEither,
  dimapEither_,
  dimapError,
  dimapError_,
  dimap_,
  filterInput,
  filterInput_,
  filterOutput,
  filterOutput_,
  fold,
  foldAll,
  foldAll_,
  fold_,
  get,
  getAndSet,
  getAndSet_,
  getAndUpdate,
  getAndUpdateSome,
  getAndUpdateSome_,
  getAndUpdate_,
  makeRef,
  map,
  mapEither,
  mapEither_,
  map_,
  modify,
  modifySome,
  modifySome_,
  modify_,
  readOnly,
  set,
  set_,
  unsafeMakeRef,
  update,
  updateAndGet,
  updateAndGet_,
  updateSome,
  updateSomeAndGet,
  updateSomeAndGet_,
  updateSome_,
  update_,
  writeOnly
});
