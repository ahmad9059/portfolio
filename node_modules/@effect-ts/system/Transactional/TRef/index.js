var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var TRef_exports = {};
__export(TRef_exports, {
  Atomic: () => Atomic,
  Derived: () => Derived,
  DerivedAll: () => DerivedAll,
  TRefTypeId: () => TRefTypeId,
  concrete: () => concrete,
  fold: () => fold,
  foldAll: () => foldAll,
  foldAll_: () => foldAll_,
  fold_: () => fold_,
  get: () => get,
  getAndSet: () => getAndSet,
  getAndSet_: () => getAndSet_,
  getAndUpdate: () => getAndUpdate,
  getAndUpdateSome: () => getAndUpdateSome,
  getAndUpdateSome_: () => getAndUpdateSome_,
  getAndUpdate_: () => getAndUpdate_,
  make: () => make,
  makeCommit: () => makeCommit,
  makeCommitWith: () => makeCommitWith,
  makeWith: () => makeWith,
  modify: () => modify,
  modifySome: () => modifySome,
  modifySome_: () => modifySome_,
  modify_: () => modify_,
  set: () => set,
  set_: () => set_,
  unsafeGet_: () => unsafeGet_,
  unsafeMake: () => unsafeMake,
  update: () => update,
  updateAndGet: () => updateAndGet,
  updateAndGet_: () => updateAndGet_,
  updateSome: () => updateSome,
  updateSomeAndGet: () => updateSomeAndGet,
  updateSomeAndGet_: () => updateSomeAndGet_,
  updateSome_: () => updateSome_,
  update_: () => update_
});
var import_Operator = require("../../Operator/index.js");
var E = __toESM(require("../../Either/index.js"));
var import_Function = require("../../Function/index.js");
var O = __toESM(require("../../Option/index.js"));
var import_AtomicReference = require("../../Support/AtomicReference/index.js");
var import_primitives = require("../STM/_internal/primitives.js");
var STM = __toESM(require("../STM/core.js"));
var import_Entry = require("../STM/Entry/index.js");
var import_Journal = require("../STM/Journal/index.js");
var import_Versioned = require("../STM/Versioned/index.js");
const TRefTypeId = /* @__PURE__ */ Symbol();
class Atomic {
  constructor(versioned, todo) {
    this.versioned = versioned;
    this.todo = todo;
    this._typeId = TRefTypeId;
    this._tag = "Atomic";
    this.atomic = this;
  }
  fold(_ea, _eb, ca, bd) {
    return new Derived(bd, ca, this, this.atomic);
  }
  foldAll(_ea, _eb, _ec, ca, bd) {
    return new DerivedAll(bd, ca, this, this.atomic);
  }
}
class Derived {
  constructor(getEither, setEither, value, atomic) {
    this.getEither = getEither;
    this.setEither = setEither;
    this.value = value;
    this.atomic = atomic;
    this._typeId = TRefTypeId;
    this._tag = "Derived";
  }
  fold(ea, eb, ca, bd) {
    return new Derived((s) => E.fold_(this.getEither(s), (e) => E.left(eb(e)), bd), (c) => E.chain_(ca(c), (a) => E.fold_(this.setEither(a), (e) => E.left(ea(e)), E.right)), this.value, this.atomic);
  }
  foldAll(ea, eb, ec, ca, bd) {
    return new DerivedAll((s) => E.fold_(this.getEither(s), (e) => E.left(eb(e)), bd), (c) => (s) => E.chain_(E.fold_(this.getEither(s), (e) => E.left(ec(e)), ca(c)), (a) => E.fold_(this.setEither(a), (e) => E.left(ea(e)), E.right)), this.value, this.atomic);
  }
}
class DerivedAll {
  constructor(getEither, setEither, value, atomic) {
    this.getEither = getEither;
    this.setEither = setEither;
    this.value = value;
    this.atomic = atomic;
    this._typeId = TRefTypeId;
    this._tag = "DerivedAll";
  }
  fold(ea, eb, ca, bd) {
    return new DerivedAll((s) => E.fold_(this.getEither(s), (e) => E.left(eb(e)), bd), (c) => (s) => E.chain_(ca(c), (a) => E.fold_(this.setEither(a)(s), (e) => E.left(ea(e)), E.right)), this.value, this.atomic);
  }
  foldAll(ea, eb, ec, ca, bd) {
    return new DerivedAll((s) => E.fold_(this.getEither(s), (e) => E.left(eb(e)), bd), (c) => (s) => E.chain_(E.fold_(this.getEither(s), (e) => E.left(ec(e)), ca(c)), (a) => E.fold_(this.setEither(a)(s), (e) => E.left(ea(e)), E.right)), this.value, this.atomic);
  }
}
function getOrMakeEntry(self, journal) {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = (0, import_Entry.makeEntry)(self, false);
  journal.set(self, entry);
  return entry;
}
function get(self) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        return entry.use((_) => _.unsafeGet());
      });
    }
    case "Derived": {
      return STM.chain_(get(self.value), (s) => E.fold_(self.getEither(s), STM.fail, STM.succeed));
    }
    case "DerivedAll": {
      return STM.chain_(get(self.value), (s) => E.fold_(self.getEither(s), STM.fail, STM.succeed));
    }
  }
}
function unsafeGet_(self, journal) {
  return getOrMakeEntry(self.atomic, journal).use((_) => _.unsafeGet());
}
function set_(self, a) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        return entry.use((_) => _.unsafeSet(a));
      });
    }
    case "Derived": {
      return E.fold_(self.setEither(a), STM.fail, (s) => set_(self.value, s));
    }
    case "DerivedAll": {
      return STM.absolve(modify_(self.value, (s) => E.fold_(self.setEither(a)(s), (e) => [E.leftW(e), s], (s2) => [E.right(void 0), s2])));
    }
  }
}
function modify_(self, f) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        const oldValue = entry.use((_) => _.unsafeGet());
        const [retValue, newValue] = f(oldValue);
        entry.use((_) => _.unsafeSet(newValue));
        return retValue;
      });
    }
    case "Derived": {
      return STM.absolve(modify_(self.value, (s) => E.fold_(self.getEither(s), (e) => [E.leftW(e), s], (a1) => {
        const [b, a2] = f(a1);
        return E.fold_(self.setEither(a2), (e) => [E.left(e), s], (s2) => [E.right(b), s2]);
      })));
    }
    case "DerivedAll": {
      return STM.absolve(modify_(self.value, (s) => E.fold_(self.getEither(s), (e) => [E.leftW(e), s], (a1) => {
        const [b, a2] = f(a1);
        return E.fold_(self.setEither(a2)(s), (e) => [E.left(e), s], (s2) => [E.right(b), s2]);
      })));
    }
  }
}
function modify(f) {
  return (self) => modify_(self, f);
}
function modifySome_(self, b, f) {
  return modify_(self, (a) => O.fold_(f(a), () => [b, a], import_Function.identity));
}
function modifySome(b, f) {
  return (self) => modifySome_(self, b, f);
}
function getAndSet_(self, a) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        const oldValue = entry.use((_) => _.unsafeGet());
        entry.use((_) => _.unsafeSet(a));
        return oldValue;
      });
    }
    default: {
      return modify_(self, (_) => [_, a]);
    }
  }
}
function getAndSet(a) {
  return (self) => getAndSet_(self, a);
}
function getAndUpdate_(self, f) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        const oldValue = entry.use((_) => _.unsafeGet());
        entry.use((_) => _.unsafeSet(f(oldValue)));
        return oldValue;
      });
    }
    default: {
      return modify_(self, (_) => [_, f(_)]);
    }
  }
}
function getAndUpdate(f) {
  return (self) => getAndUpdate_(self, f);
}
function getAndUpdateSome_(self, f) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        const oldValue = entry.use((_) => _.unsafeGet());
        const v = f(oldValue);
        if (O.isSome(v)) {
          entry.use((_) => _.unsafeSet(v.value));
        }
        return oldValue;
      });
    }
    default: {
      return modify_(self, (_) => O.fold_(f(_), () => [_, _], (v) => [_, v]));
    }
  }
}
function getAndUpdateSome(f) {
  return (self) => getAndUpdateSome_(self, f);
}
function set(a) {
  return (self) => set_(self, a);
}
function update_(self, f) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        const newValue = f(entry.use((_) => _.unsafeGet()));
        entry.use((_) => _.unsafeSet(newValue));
      });
    }
    default:
      return modify_(self, (a) => [void 0, f(a)]);
  }
}
function update(f) {
  return (self) => update_(self, f);
}
function updateSome_(self, f) {
  return update_(self, (a) => O.fold_(f(a), () => a, import_Function.identity));
}
function updateSome(f) {
  return (self) => updateSome_(self, f);
}
function updateSomeAndGet_(self, f) {
  return updateAndGet_(self, (a) => O.fold_(f(a), () => a, import_Function.identity));
}
function updateSomeAndGet(f) {
  return (self) => updateSomeAndGet_(self, f);
}
function updateAndGet_(self, f) {
  ;
  switch (self._tag) {
    case "Atomic": {
      return new import_primitives.STMEffect((journal) => {
        const entry = getOrMakeEntry(self, journal);
        const oldValue = entry.use((_) => _.unsafeGet());
        const x = f(oldValue);
        entry.use((_) => _.unsafeSet(x));
        return x;
      });
    }
    default: {
      return modify_(self, (_) => {
        const x = f(_);
        return [x, x];
      });
    }
  }
}
function updateAndGet(f) {
  return (self) => updateAndGet_(self, f);
}
function concrete(_) {
}
function makeWith(a) {
  return new import_primitives.STMEffect((journal) => {
    const value = a();
    const versioned = new import_Versioned.Versioned(value);
    const todo = new import_AtomicReference.AtomicReference(import_Journal.emptyTodoMap);
    const tref = new Atomic(versioned, todo);
    journal.set(tref, (0, import_Entry.makeEntry)(tref, true));
    return tref;
  });
}
function make(a) {
  return new import_primitives.STMEffect((journal) => {
    const value = a;
    const versioned = new import_Versioned.Versioned(value);
    const todo = new import_AtomicReference.AtomicReference(import_Journal.emptyTodoMap);
    const tref = new Atomic(versioned, todo);
    journal.set(tref, (0, import_Entry.makeEntry)(tref, true));
    return tref;
  });
}
function unsafeMake(a) {
  const value = a;
  const versioned = new import_Versioned.Versioned(value);
  const todo = new import_AtomicReference.AtomicReference(import_Journal.emptyTodoMap);
  return new Atomic(versioned, todo);
}
function makeCommitWith(a) {
  return STM.commit(makeWith(a));
}
function makeCommit(a) {
  return STM.commit(make(a));
}
function fold_(self, ea, eb, ca, bd) {
  return self.fold(ea, eb, ca, bd);
}
function fold(ea, eb, ca, bd) {
  return (self) => fold_(self, ea, eb, ca, bd);
}
function foldAll_(self, ea, eb, ec, ca, bd) {
  return self.foldAll(ea, eb, ec, ca, bd);
}
function foldAll(ea, eb, ec, ca, bd) {
  return (self) => self.foldAll(ea, eb, ec, ca, bd);
}
module.exports = __toCommonJS(TRef_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Atomic,
  Derived,
  DerivedAll,
  TRefTypeId,
  concrete,
  fold,
  foldAll,
  foldAll_,
  fold_,
  get,
  getAndSet,
  getAndSet_,
  getAndUpdate,
  getAndUpdateSome,
  getAndUpdateSome_,
  getAndUpdate_,
  make,
  makeCommit,
  makeCommitWith,
  makeWith,
  modify,
  modifySome,
  modifySome_,
  modify_,
  set,
  set_,
  unsafeGet_,
  unsafeMake,
  update,
  updateAndGet,
  updateAndGet_,
  updateSome,
  updateSomeAndGet,
  updateSomeAndGet_,
  updateSome_,
  update_
});
