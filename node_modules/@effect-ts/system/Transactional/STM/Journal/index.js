var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Journal_exports = {};
__export(Journal_exports, {
  addTodo: () => addTodo,
  analyzeJournal: () => analyzeJournal,
  collectTodos: () => collectTodos,
  commitJournal: () => commitJournal,
  completeTodos: () => completeTodos,
  emptyTodoMap: () => emptyTodoMap,
  execTodos: () => execTodos,
  isInvalid: () => isInvalid,
  isValid: () => isValid,
  prepareResetJournal: () => prepareResetJournal,
  tryCommit: () => tryCommit,
  tryCommitAsync: () => tryCommitAsync,
  untrackedTodoTargets: () => untrackedTodoTargets
});
var import_Operator = require("../../../Operator/index.js");
var HM = __toESM(require("../../../Collections/Immutable/HashMap/index.js"));
var T = __toESM(require("../../../Effect/index.js"));
var import_Scheduler = require("../../../Support/Scheduler/index.js");
var import_driver = require("../_internal/driver.js");
var import_TExit = require("../TExit/index.js");
var import_TryCommit = require("../TryCommit/index.js");
function prepareResetJournal(journal) {
  const saved = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    saved.set(entry[0], entry[1].use((_) => _.copy()));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
}
function commitJournal(journal) {
  for (const entry of journal) {
    entry[1].use((_) => _.commit());
  }
}
function analyzeJournal(journal) {
  let val = "RO";
  for (const entry of journal) {
    val = entry[1].use((_) => _.isInvalid() ? "I" : _.isChanged() ? "RW" : val);
    if (val === "I") {
      return val;
    }
  }
  return val;
}
const emptyTodoMap = /* @__PURE__ */ HM.make();
function collectTodos(journal) {
  const allTodos = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    const tref = entry[1].use((_) => _.tref);
    const todos = tref.todo.get;
    for (const todo of todos) {
      allTodos.set(todo[0], todo[1]);
    }
    tref.todo.set(emptyTodoMap);
  }
  return allTodos;
}
function execTodos(todos) {
  for (const todo of todos) {
    todo[1]();
  }
}
function completeTodos(io, journal) {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    (0, import_Scheduler.defaultScheduler)(() => execTodos(todos));
  }
  return new import_TryCommit.Done(io);
}
function addTodo(txnId, journal, todoEffect) {
  let added = false;
  for (const entry of journal) {
    const tref = entry[1].use((_) => _.tref);
    const oldTodo = tref.todo.get;
    if (!HM.has_(oldTodo, txnId)) {
      const newTodo = HM.set_(oldTodo, txnId, todoEffect);
      tref.todo.set(newTodo);
      added = true;
    }
  }
  return added;
}
function untrackedTodoTargets(oldJournal, newJournal) {
  const untracked = /* @__PURE__ */ new Map();
  for (const entry of newJournal) {
    const key = entry[0];
    const value = entry[1];
    if (!oldJournal.has(key) && !value.use((_) => _.isNew)) {
      untracked.set(key, value);
    }
  }
  return untracked;
}
function tryCommit(fiberId, stm, r) {
  const journal = /* @__PURE__ */ new Map();
  const value = new import_driver.STMDriver(stm, journal, fiberId, r).run();
  const analysis = analyzeJournal(journal);
  if (analysis === "RW") {
    commitJournal(journal);
  } else if (analysis === "I") {
    throw new Error("Bug: invalid journal");
  }
  switch (value._typeId) {
    case import_TExit.RetryTypeId: {
      return new import_TryCommit.Suspend(journal);
    }
    case import_TExit.SucceedTypeId: {
      return completeTodos(T.succeed(value.value), journal);
    }
    case import_TExit.FailTypeId: {
      return completeTodos(T.fail(value.value), journal);
    }
    case import_TExit.DieTypeId: {
      return completeTodos(T.die(value.value), journal);
    }
  }
}
function completeTryCommit(io, k, done) {
  done.set(true);
  k(io);
}
function suspendTryCommit(fiberId, stm, txnId, done, r, k, accum, journal) {
  while (1) {
    addTodo(txnId, journal, () => tryCommitAsync(void 0, fiberId, stm, txnId, done, r)(k));
    if (isInvalid(journal)) {
      const v = tryCommit(fiberId, stm, r);
      switch (v._typeId) {
        case import_TryCommit.DoneTypeId: {
          completeTryCommit(v.io, k, done);
          return;
        }
        case import_TryCommit.SuspendTypeId: {
          const untracked = untrackedTodoTargets(accum, v.journal);
          if (untracked.size > 0) {
            for (const entry of untracked) {
              accum.set(entry[0], entry[1]);
            }
            journal = untracked;
          }
          break;
        }
      }
    } else {
      return;
    }
  }
}
function tryCommitAsync(journal, fiberId, stm, txnId, done, r) {
  return (k) => {
    if (!done.get) {
      if (journal == null) {
        const v = tryCommit(fiberId, stm, r);
        switch (v._typeId) {
          case import_TryCommit.DoneTypeId: {
            completeTryCommit(v.io, k, done);
            break;
          }
          case import_TryCommit.SuspendTypeId: {
            suspendTryCommit(fiberId, stm, txnId, done, r, k, v.journal, v.journal);
            break;
          }
        }
      } else {
        suspendTryCommit(fiberId, stm, txnId, done, r, k, journal, journal);
      }
    }
  };
}
function isValid(journal) {
  let valid = true;
  for (const entry of journal) {
    valid = entry[1].use((_) => _.isValid());
    if (!valid) {
      return valid;
    }
  }
  return valid;
}
function isInvalid(journal) {
  return !isValid(journal);
}
module.exports = __toCommonJS(Journal_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addTodo,
  analyzeJournal,
  collectTodos,
  commitJournal,
  completeTodos,
  emptyTodoMap,
  execTodos,
  isInvalid,
  isValid,
  prepareResetJournal,
  tryCommit,
  tryCommitAsync,
  untrackedTodoTargets
});
