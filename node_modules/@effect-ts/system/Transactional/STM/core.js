var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  MaxFrames: () => MaxFrames,
  STM: () => import_primitives.STM,
  STMEffect: () => import_primitives.STMEffect,
  STMFailException: () => import_primitives.STMFailException,
  STMRetryException: () => import_primitives.STMRetryException,
  absolve: () => absolve,
  access: () => access,
  accessM: () => accessM,
  andThen: () => andThen,
  andThen_: () => andThen_,
  as: () => as,
  asSome: () => asSome,
  asSomeError: () => asSomeError,
  as_: () => as_,
  bimap: () => bimap,
  bimap_: () => bimap_,
  catch: () => _catch,
  catchAll: () => import_primitives.catchAll,
  catchAll_: () => import_primitives.catchAll_,
  catchSome: () => catchSome,
  catchSome_: () => catchSome_,
  catchTag: () => catchTag,
  catchTag_: () => catchTag_,
  catch_: () => catch_,
  chain: () => import_primitives.chain,
  chainError: () => chainError,
  chainError_: () => chainError_,
  chain_: () => import_primitives.chain_,
  check: () => check,
  checkWith: () => checkWith,
  commit: () => commit,
  commitEither: () => commitEither,
  compose: () => compose,
  compose_: () => compose_,
  continueOrFail: () => continueOrFail,
  continueOrFailM: () => continueOrFailM,
  continueOrFailM_: () => continueOrFailM_,
  continueOrFailWith: () => continueOrFailWith,
  continueOrFailWithM: () => continueOrFailWithM,
  continueOrFailWithM_: () => continueOrFailWithM_,
  continueOrFailWith_: () => continueOrFailWith_,
  continueOrFail_: () => continueOrFail_,
  continueOrRetry: () => continueOrRetry,
  continueOrRetryM: () => continueOrRetryM,
  continueOrRetryM_: () => continueOrRetryM_,
  continueOrRetry_: () => continueOrRetry_,
  die: () => import_primitives.die,
  dieMessage: () => dieMessage,
  dieMessageWith: () => dieMessageWith,
  dieWith: () => import_primitives.dieWith,
  either: () => either,
  ensuring: () => import_primitives.ensuring,
  ensuring_: () => import_primitives.ensuring_,
  environment: () => environment,
  eventually: () => eventually,
  fail: () => import_primitives.fail,
  failWith: () => import_primitives.failWith,
  filterOrDie: () => filterOrDie,
  filterOrDieMessage: () => filterOrDieMessage,
  filterOrDieMessage_: () => filterOrDieMessage_,
  filterOrDie_: () => filterOrDie_,
  filterOrElse: () => filterOrElse,
  filterOrElse_: () => filterOrElse_,
  filterOrFail: () => filterOrFail,
  filterOrFail_: () => filterOrFail_,
  flatten: () => flatten,
  flattenErrorOption: () => flattenErrorOption,
  flattenErrorOptionWith: () => flattenErrorOptionWith,
  flattenErrorOptionWith_: () => flattenErrorOptionWith_,
  flattenErrorOption_: () => flattenErrorOption_,
  flip: () => flip,
  flipWith: () => flipWith,
  flipWith_: () => flipWith_,
  fold: () => fold,
  foldM: () => import_primitives.foldM,
  foldM_: () => import_primitives.foldM_,
  fold_: () => fold_,
  forEach: () => forEach,
  forEach_: () => forEach_,
  fromEither: () => fromEither,
  fromEitherWith: () => fromEitherWith,
  get: () => get,
  head: () => head,
  ignore: () => ignore,
  isFailure: () => isFailure,
  isSuccess: () => isSuccess,
  join: () => join,
  joinEither: () => joinEither,
  joinEither_: () => joinEither_,
  join_: () => join_,
  left: () => left,
  leftOrFail: () => leftOrFail,
  leftOrFailException: () => leftOrFailException,
  leftOrFail_: () => leftOrFail_,
  map: () => import_primitives.map,
  mapError: () => mapError,
  mapError_: () => mapError_,
  map_: () => import_primitives.map_,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  provideSome: () => import_primitives.provideSome,
  provideSome_: () => import_primitives.provideSome_,
  repeatUntil: () => repeatUntil,
  repeatUntil_: () => repeatUntil_,
  repeatWhile: () => repeatWhile,
  repeatWhile_: () => repeatWhile_,
  retry: () => import_primitives.retry,
  succeed: () => import_primitives.succeed,
  succeedWith: () => import_primitives.succeedWith,
  suspend: () => suspend,
  tap: () => tap,
  tap_: () => tap_,
  toLeft: () => toLeft,
  toLeftWith: () => toLeftWith,
  unit: () => import_primitives.unit,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_
});
var import_Operator = require("../../Operator/index.js");
var import_Cause = require("../../Cause/index.js");
var T = __toESM(require("../../Effect/index.js"));
var E = __toESM(require("../../Either/index.js"));
var import_Function = require("../../Function/index.js");
var import_GlobalExceptions = require("../../GlobalExceptions/index.js");
var O = __toESM(require("../../Option/index.js"));
var import_AtomicBoolean = require("../../Support/AtomicBoolean/index.js");
var P = __toESM(require("./_internal/primitives.js"));
var import_Journal = require("./Journal/index.js");
var import_TryCommit = require("./TryCommit/index.js");
var import_TxnId = require("./TxnId/index.js");
var import_primitives = require("./_internal/primitives.js");
const MaxFrames = 200;
function access(f) {
  return P.map_(environment(), f);
}
function accessM(f) {
  return P.chain_(environment(), f);
}
function absolve(z) {
  return P.chain_(z, fromEither);
}
function andThen_(self, that) {
  return P.chain_(self, (a) => provideAll_(that, a));
}
function andThen(that) {
  return (self) => andThen_(self, that);
}
function as_(self, b) {
  return P.map_(self, () => b);
}
function as(b) {
  return (self) => as_(self, b);
}
function asSome(self) {
  return P.map_(self, O.some);
}
function asSomeError(self) {
  return mapError_(self, O.some);
}
function bimap_(self, g, f) {
  return P.foldM_(self, (e) => P.fail(g(e)), (a) => P.succeed(f(a)));
}
function bimap(g, f) {
  return (self) => bimap_(self, g, f);
}
function _catch(tag, k, f, __trace) {
  return (self) => P.catchAll_(self, (e) => {
    if (tag in e && e[tag] === k) {
      return f(e);
    }
    return P.fail(e);
  });
}
function catch_(self, tag, k, f) {
  return P.catchAll_(self, (e) => {
    if (tag in e && e[tag] === k) {
      return f(e);
    }
    return P.fail(e);
  });
}
function catchTag(k, f, __trace) {
  return (self) => catchTag_(self, k, f);
}
function catchTag_(self, k, f) {
  return P.catchAll_(self, (e) => {
    if ("_tag" in e && e["_tag"] === k) {
      return f(e);
    }
    return P.fail(e);
  });
}
function catchSome_(self, f) {
  return P.catchAll_(self, (e) => O.fold_(f(e), () => P.fail(e), import_Function.identity));
}
function catchSome(f) {
  return (self) => catchSome_(self, f);
}
function continueOrRetryM_(fa, pf) {
  return P.chain_(fa, (a) => O.getOrElse_(pf(a), () => P.retry));
}
function continueOrRetryM(pf) {
  return (fa) => continueOrRetryM_(fa, pf);
}
function continueOrRetry_(fa, pf) {
  return continueOrRetryM_(fa, (x) => O.map_(pf(x), P.succeed));
}
function continueOrRetry(pf) {
  return (fa) => continueOrRetry_(fa, pf);
}
function continueOrFailM_(fa, e, pf) {
  return P.chain_(fa, (a) => O.getOrElse_(pf(a), () => P.fail(e)));
}
function continueOrFailM(e, pf) {
  return (fa) => continueOrFailM_(fa, e, pf);
}
function continueOrFail_(fa, e, pf) {
  return continueOrFailM_(fa, e, (x) => O.map_(pf(x), P.succeed));
}
function continueOrFail(e, pf) {
  return (fa) => continueOrFail_(fa, e, pf);
}
function continueOrFailWithM_(fa, e, pf) {
  return P.chain_(fa, (a) => O.getOrElse_(pf(a), () => P.failWith(e)));
}
function continueOrFailWithM(e, pf) {
  return (fa) => continueOrFailWithM_(fa, e, pf);
}
function continueOrFailWith_(fa, e, pf) {
  return continueOrFailWithM_(fa, e, (x) => O.map_(pf(x), P.succeed));
}
function continueOrFailWith(e, pf) {
  return (fa) => continueOrFailWith_(fa, e, pf);
}
function chainError(f) {
  return (self) => chainError_(self, f);
}
function chainError_(self, f) {
  return flipWith_(self, (x) => P.chain_(x, f));
}
function checkWith(predicate) {
  return suspend(() => predicate() ? P.unit : P.retry);
}
function check(predicate) {
  return checkWith(() => predicate);
}
function compose_(self, that) {
  return andThen_(that, self);
}
function compose(that) {
  return (self) => andThen_(that, self);
}
function commit(self) {
  return T.accessM((r) => T.suspend((_, fiberId) => {
    const v = (0, import_Journal.tryCommit)(fiberId, self, r);
    switch (v._typeId) {
      case import_TryCommit.DoneTypeId: {
        return v.io;
      }
      case import_TryCommit.SuspendTypeId: {
        const txnId = (0, import_TxnId.makeTxnId)();
        const done = new import_AtomicBoolean.AtomicBoolean(false);
        const interrupt = T.succeedWith(() => done.set(true));
        const io = T.effectAsync((0, import_Journal.tryCommitAsync)(v.journal, fiberId, self, txnId, done, r));
        return T.ensuring_(io, interrupt);
      }
    }
  }));
}
function commitEither(self) {
  return T.absolve(commit(either(self)));
}
function dieMessage(message) {
  return P.dieWith(() => new import_Cause.RuntimeError(message));
}
function dieMessageWith(message) {
  return P.succeedWith(() => {
    throw new import_Cause.RuntimeError(message());
  });
}
function either(self) {
  return fold_(self, (x) => E.left(x), (x) => E.right(x));
}
function environment() {
  return new P.STMEffect((_, __, r) => r);
}
function eventually(self) {
  return P.foldM_(self, () => eventually(self), P.succeed);
}
function filterOrDie(p, dieWith2) {
  return (fa) => filterOrDie_(fa, p, dieWith2);
}
function filterOrDie_(fa, p, dieWith2) {
  return filterOrElse_(fa, p, (x) => P.dieWith(() => dieWith2(x)));
}
function filterOrFail(p, failWith2) {
  return (fa) => filterOrFail_(fa, p, failWith2);
}
function filterOrFail_(fa, p, failWith2) {
  return filterOrElse_(fa, p, (x) => fail(failWith2(x)));
}
function filterOrElse(p, or) {
  return (fa) => filterOrElse_(fa, p, or);
}
function filterOrElse_(fa, p, or) {
  return P.chain_(fa, (a) => p(a) ? P.succeed(a) : suspend(() => or(a)));
}
function filterOrDieMessage(p, message) {
  return (fa) => filterOrDieMessage_(fa, p, message);
}
function filterOrDieMessage_(fa, p, message) {
  return filterOrDie_(fa, p, (a) => new import_Cause.RuntimeError(message(a)));
}
function flip(self) {
  return P.foldM_(self, P.succeed, P.fail);
}
function flipWith(f) {
  return (self) => flipWith_(self, f);
}
function flipWith_(self, f) {
  return flip(f(flip(self)));
}
function fold_(self, g, f) {
  return P.foldM_(self, (e) => P.succeed(g(e)), (a) => P.succeed(f(a)));
}
function fold(g, f) {
  return (self) => fold_(self, g, f);
}
function flatten(self) {
  return P.chain_(self, import_Function.identity);
}
function flattenErrorOptionWith(def) {
  return (self) => flattenErrorOptionWith_(self, def);
}
function flattenErrorOptionWith_(self, def) {
  return mapError_(self, O.fold(def, import_Function.identity));
}
function flattenErrorOption(def) {
  return (self) => flattenErrorOption_(self, def);
}
function flattenErrorOption_(self, def) {
  return mapError_(self, O.fold(() => def, import_Function.identity));
}
function forEach_(it, f) {
  return suspend(() => {
    let stm = P.succeed([]);
    for (const a of it) {
      stm = zipWith_(stm, f(a), (acc, b) => {
        acc.push(b);
        return acc;
      });
    }
    return stm;
  });
}
function forEach(f) {
  return (self) => forEach_(self, f);
}
function fromEitherWith(e) {
  return suspend(() => {
    return E.fold_(e(), P.fail, P.succeed);
  });
}
function fromEither(e) {
  return E.fold_(e, P.fail, P.succeed);
}
function get(self) {
  return P.foldM_(self, (x) => P.fail(O.some(x)), O.fold(() => P.fail(O.none), P.succeed));
}
function head(self) {
  return P.foldM_(self, (x) => P.fail(O.some(x)), (x) => {
    const it = x[Symbol.iterator]();
    const next = it.next();
    return next.done ? P.fail(O.none) : P.succeed(next.value);
  });
}
function ignore(self) {
  return fold_(self, import_Function.constVoid, import_Function.constVoid);
}
function isFailure(self) {
  return fold_(self, () => true, () => false);
}
function isSuccess(self) {
  return fold_(self, () => false, () => true);
}
function left(self) {
  return P.foldM_(self, (e) => P.fail(O.some(e)), E.fold(P.succeed, () => P.fail(O.none)));
}
function leftOrFail_(self, orFail) {
  return P.chain_(self, E.fold(P.succeed, (x) => P.failWith(() => orFail(x))));
}
function leftOrFail(orFail) {
  return (self) => leftOrFail_(self, orFail);
}
function leftOrFailException(self) {
  return leftOrFail_(self, () => new import_GlobalExceptions.NoSuchElementException());
}
function join(that) {
  return (self) => {
    return join_(self, that);
  };
}
function join_(self, that) {
  return accessM((_) => E.fold_(_, (r) => provideAll_(self, r), (r1) => provideAll_(that, r1)));
}
function joinEither_(self, that) {
  return accessM((_) => E.fold_(_, (r) => P.map_(provideAll_(self, r), E.left), (r1) => P.map_(provideAll_(that, r1), E.right)));
}
function joinEither(that) {
  return (self) => joinEither_(self, that);
}
function mapError_(self, f) {
  return P.foldM_(self, (e) => P.fail(f(e)), P.succeed);
}
function mapError(f) {
  return (self) => mapError_(self, f);
}
function provideAll_(self, r) {
  return P.provideSome_(self, () => r);
}
function provideAll(r) {
  return (self) => provideAll_(self, r);
}
function repeatUntil_(self, f) {
  return P.chain_(self, (a) => f(a) ? P.succeed(a) : repeatUntil_(self, f));
}
function repeatUntil(f) {
  return (self) => repeatUntil_(self, f);
}
function repeatWhile_(self, f) {
  return P.chain_(self, (a) => f(a) ? repeatWhile_(self, f) : P.succeed(a));
}
function repeatWhile(f) {
  return (self) => repeatWhile_(self, f);
}
function suspend(f) {
  return flatten(P.succeedWith(f));
}
function tap_(self, f) {
  return P.chain_(self, (a) => as_(f(a), a));
}
function tap(f) {
  return (self) => tap_(self, f);
}
function toLeftWith(a) {
  return P.chain_(P.succeedWith(a), (x) => P.succeed(E.left(x)));
}
function toLeft(a) {
  return P.succeed(E.left(a));
}
function zipWith_(self, that, f) {
  return P.chain_(self, (a) => P.map_(that, (b) => f(a, b)));
}
function zipWith(that, f) {
  return (self) => P.chain_(self, (a) => P.map_(that, (b) => f(a, b)));
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MaxFrames,
  STM,
  STMEffect,
  STMFailException,
  STMRetryException,
  absolve,
  access,
  accessM,
  andThen,
  andThen_,
  as,
  asSome,
  asSomeError,
  as_,
  bimap,
  bimap_,
  catch: null,
  catchAll,
  catchAll_,
  catchSome,
  catchSome_,
  catchTag,
  catchTag_,
  catch_,
  chain,
  chainError,
  chainError_,
  chain_,
  check,
  checkWith,
  commit,
  commitEither,
  compose,
  compose_,
  continueOrFail,
  continueOrFailM,
  continueOrFailM_,
  continueOrFailWith,
  continueOrFailWithM,
  continueOrFailWithM_,
  continueOrFailWith_,
  continueOrFail_,
  continueOrRetry,
  continueOrRetryM,
  continueOrRetryM_,
  continueOrRetry_,
  die,
  dieMessage,
  dieMessageWith,
  dieWith,
  either,
  ensuring,
  ensuring_,
  environment,
  eventually,
  fail,
  failWith,
  filterOrDie,
  filterOrDieMessage,
  filterOrDieMessage_,
  filterOrDie_,
  filterOrElse,
  filterOrElse_,
  filterOrFail,
  filterOrFail_,
  flatten,
  flattenErrorOption,
  flattenErrorOptionWith,
  flattenErrorOptionWith_,
  flattenErrorOption_,
  flip,
  flipWith,
  flipWith_,
  fold,
  foldM,
  foldM_,
  fold_,
  forEach,
  forEach_,
  fromEither,
  fromEitherWith,
  get,
  head,
  ignore,
  isFailure,
  isSuccess,
  join,
  joinEither,
  joinEither_,
  join_,
  left,
  leftOrFail,
  leftOrFailException,
  leftOrFail_,
  map,
  mapError,
  mapError_,
  map_,
  provideAll,
  provideAll_,
  provideSome,
  provideSome_,
  repeatUntil,
  repeatUntil_,
  repeatWhile,
  repeatWhile_,
  retry,
  succeed,
  succeedWith,
  suspend,
  tap,
  tap_,
  toLeft,
  toLeftWith,
  unit,
  zipWith,
  zipWith_
});
