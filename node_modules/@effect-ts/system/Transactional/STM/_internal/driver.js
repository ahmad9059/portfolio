var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var driver_exports = {};
__export(driver_exports, {
  STMDriver: () => STMDriver
});
var import_Stack = require("../../../Stack/index.js");
var TExit = __toESM(require("../TExit/index.js"));
var STM = __toESM(require("./primitives.js"));
class STMDriver {
  constructor(self, journal, fiberId, r0) {
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId;
    this.envStack = new import_Stack.Stack(r0);
  }
  unwindStack(error, isRetry) {
    let result = void 0;
    while (this.contStack && !result) {
      const cont = this.contStack.value;
      this.contStack = this.contStack.previous;
      if (cont._typeId === STM.STMOnFailureTypeId) {
        if (!isRetry) {
          result = cont.onFailure(error);
        }
      }
      if (cont._typeId === STM.STMOnRetryTypeId) {
        if (isRetry) {
          result = cont.onRetry;
        }
      }
    }
    return result;
  }
  run() {
    let curr = this.self;
    let exit = void 0;
    while (!exit && curr) {
      const k = curr;
      ;
      switch (k._typeId) {
        case STM.STMSucceedTypeId: {
          const a = k.a();
          if (!this.contStack) {
            exit = TExit.succeed(a);
          } else {
            const cont = this.contStack.value;
            this.contStack = this.contStack.previous;
            curr = cont.apply(a);
          }
          break;
        }
        case STM.STMSucceedNowTypeId: {
          const a = k.a;
          if (!this.contStack) {
            exit = TExit.succeed(a);
          } else {
            const cont = this.contStack.value;
            this.contStack = this.contStack.previous;
            curr = cont.apply(a);
          }
          break;
        }
        case STM.STMProvideSomeTypeId: {
          this.envStack = new import_Stack.Stack(k.f(this.envStack.value), this.envStack);
          curr = STM.ensuring_(k.stm, STM.succeedWith(() => {
            this.envStack = this.envStack.previous;
          }));
          break;
        }
        case STM.STMOnRetryTypeId: {
          this.contStack = new import_Stack.Stack(k, this.contStack);
          curr = k.stm;
          break;
        }
        case STM.STMOnFailureTypeId: {
          this.contStack = new import_Stack.Stack(k, this.contStack);
          curr = k.stm;
          break;
        }
        case STM.STMOnSuccessTypeId: {
          this.contStack = new import_Stack.Stack(k, this.contStack);
          curr = k.stm;
          break;
        }
        case STM.STMEffectTypeId: {
          try {
            const a = k.f(this.journal, this.fiberId, this.envStack.value);
            if (!this.contStack) {
              exit = TExit.succeed(a);
            } else {
              const cont = this.contStack.value;
              this.contStack = this.contStack.previous;
              curr = cont.apply(a);
            }
          } catch (e) {
            if (STM.isFailException(e)) {
              curr = this.unwindStack(e.e, false);
              if (!curr) {
                exit = TExit.fail(e.e);
              }
            } else if (STM.isRetryException(e)) {
              curr = this.unwindStack(void 0, true);
              if (!curr) {
                exit = TExit.retry;
              }
            } else if (STM.isDieException(e)) {
              curr = this.unwindStack(e.e, false);
              if (!curr) {
                exit = TExit.die(e.e);
              }
            } else {
              throw e;
            }
          }
        }
      }
    }
    return exit;
  }
}
module.exports = __toCommonJS(driver_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  STMDriver
});
