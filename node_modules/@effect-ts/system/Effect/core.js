var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  access: () => access,
  accessM: () => accessM,
  chain: () => chain,
  chain_: () => chain_,
  checkInterruptible: () => checkInterruptible,
  checkPlatform: () => checkPlatform,
  checkTraced: () => checkTraced,
  descriptorWith: () => descriptorWith,
  effectAsyncOption: () => effectAsyncOption,
  effectAsyncOptionBlockingOn: () => effectAsyncOptionBlockingOn,
  foldCauseM: () => foldCauseM,
  foldCauseM_: () => foldCauseM_,
  fork: () => fork,
  forkReport: () => forkReport,
  forkReport_: () => forkReport_,
  halt: () => halt,
  haltWith: () => haltWith,
  interruptStatus: () => interruptStatus,
  interruptStatus_: () => interruptStatus_,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  result: () => result,
  succeed: () => succeed,
  succeedWith: () => succeedWith,
  supervised: () => supervised,
  supervised_: () => supervised_,
  suspend: () => suspend,
  trace: () => trace,
  traced: () => traced,
  tracingStatus: () => tracingStatus,
  tracingStatus_: () => tracingStatus_,
  try: () => try_,
  tryCatch: () => tryCatch,
  tryCatchSuspend: () => tryCatchSuspend,
  tryOrElse: () => tryOrElse,
  tryOrElse_: () => tryOrElse_,
  unit: () => unit,
  unitTraced: () => unitTraced,
  untraced: () => untraced,
  yieldNow: () => yieldNow
});
var import_core = require("../Cause/core.js");
var Exit = __toESM(require("../Exit/core.js"));
var import_Function = require("../Function/index.js");
var O = __toESM(require("../Option/index.js"));
var import_primitives = require("./primitives.js");
function access(f, __trace) {
  return new import_primitives.IRead((_) => new import_primitives.ISucceed(f(_)), __trace);
}
function accessM(f, __trace) {
  return new import_primitives.IRead(f, __trace);
}
function chain(f, __trace) {
  return (val) => new import_primitives.IFlatMap(val, f, __trace);
}
function chain_(val, f, __trace) {
  return new import_primitives.IFlatMap(val, f, __trace);
}
function descriptorWith(f, __trace) {
  return new import_primitives.IDescriptor(f, __trace);
}
function checkInterruptible(f, __trace) {
  return new import_primitives.ICheckInterrupt(f, __trace);
}
const trace = /* @__PURE__ */ new import_primitives.ITrace();
function checkTraced(f) {
  return new import_primitives.ICheckTracingStatus(f);
}
function untraced(self) {
  return new import_primitives.ITracingStatus(self, false);
}
function traced(self) {
  return new import_primitives.ITracingStatus(self, true);
}
function effectAsyncOption(register, __trace) {
  return new import_primitives.IEffectAsync(register, [], __trace);
}
function effectAsyncOptionBlockingOn(register, blockingOn, __trace) {
  return new import_primitives.IEffectAsync(register, blockingOn, __trace);
}
function tryCatch(effect, onThrow, __trace) {
  return new import_primitives.IEffectPartial(effect, onThrow, __trace);
}
function try_(effect, __trace) {
  return new import_primitives.IEffectPartial(effect, import_Function.identity, __trace);
}
function succeedWith(effect, __trace) {
  return new import_primitives.IEffectTotal(effect, __trace);
}
function foldCauseM(failure, success, __trace) {
  return (value) => new import_primitives.IFold(value, failure, success, __trace);
}
function foldCauseM_(value, failure, success, __trace) {
  return new import_primitives.IFold(value, failure, success, __trace);
}
function fork(value, __trace) {
  return new import_primitives.IFork(value, O.none, O.none, __trace);
}
function forkReport(reportFailure, __trace) {
  return (value) => new import_primitives.IFork(value, O.none, O.some(reportFailure), __trace);
}
function forkReport_(value, reportFailure, __trace) {
  return new import_primitives.IFork(value, O.none, O.some(reportFailure), __trace);
}
function halt(cause, __trace) {
  return new import_primitives.IFail(() => cause, __trace);
}
function haltWith(cause, __trace) {
  return new import_primitives.IFail(cause, __trace);
}
function interruptStatus(flag, __trace) {
  return (effect) => new import_primitives.IInterruptStatus(effect, flag, __trace);
}
function interruptStatus_(effect, flag, __trace) {
  return new import_primitives.IInterruptStatus(effect, flag, __trace);
}
function tracingStatus(flag) {
  return (effect) => new import_primitives.ITracingStatus(effect, flag);
}
function tracingStatus_(effect, flag) {
  return new import_primitives.ITracingStatus(effect, flag);
}
function provideAll(r, __trace) {
  return (next) => new import_primitives.IProvide(r, next, __trace);
}
function provideAll_(next, r, __trace) {
  return new import_primitives.IProvide(r, next, __trace);
}
function result(value, __trace) {
  return new import_primitives.IFold(value, (cause) => succeed(Exit.halt(cause)), (succ) => succeed(Exit.succeed(succ)), __trace);
}
function succeed(a, __trace) {
  return new import_primitives.ISucceed(a, __trace);
}
function supervised(supervisor, __trace) {
  return (fa) => new import_primitives.ISupervise(fa, supervisor, __trace);
}
function supervised_(fa, supervisor, __trace) {
  return new import_primitives.ISupervise(fa, supervisor, __trace);
}
function suspend(factory, __trace) {
  return new import_primitives.ISuspend(factory, __trace);
}
function tryCatchSuspend(factory, onThrow, __trace) {
  return new import_primitives.ISuspendPartial(factory, onThrow, __trace);
}
function tryOrElse_(self, that, success, __trace) {
  return new import_primitives.IFold(self, (cause) => O.fold_((0, import_core.keepDefects)(cause), that, halt), success, __trace);
}
function tryOrElse(that, success, __trace) {
  return (self) => tryOrElse_(self, that, success, __trace);
}
const unit = /* @__PURE__ */ new import_primitives.ISucceed(void 0);
const unitTraced = (__trace) => new import_primitives.ISucceed(void 0, __trace);
const yieldNow = /* @__PURE__ */ new import_primitives.IYield();
function checkPlatform(f, __trace) {
  return new import_primitives.IPlatform(f, __trace);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  access,
  accessM,
  chain,
  chain_,
  checkInterruptible,
  checkPlatform,
  checkTraced,
  descriptorWith,
  effectAsyncOption,
  effectAsyncOptionBlockingOn,
  foldCauseM,
  foldCauseM_,
  fork,
  forkReport,
  forkReport_,
  halt,
  haltWith,
  interruptStatus,
  interruptStatus_,
  provideAll,
  provideAll_,
  result,
  succeed,
  succeedWith,
  supervised,
  supervised_,
  suspend,
  trace,
  traced,
  tracingStatus,
  tracingStatus_,
  try: null,
  tryCatch,
  tryCatchSuspend,
  tryOrElse,
  tryOrElse_,
  unit,
  unitTraced,
  untraced,
  yieldNow
});
