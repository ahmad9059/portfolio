var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var excl_forEach_exports = {};
__export(excl_forEach_exports, {
  BackPressureStrategy: () => BackPressureStrategy,
  collectAll: () => collectAll,
  collectAllPar: () => collectAllPar,
  collectAllParN: () => collectAllParN,
  collectAllParN_: () => collectAllParN_,
  collectAllSuccesses: () => collectAllSuccesses,
  collectAllSuccessesPar: () => collectAllSuccessesPar,
  collectAllSuccessesParN: () => collectAllSuccessesParN,
  collectAllSuccessesParN_: () => collectAllSuccessesParN_,
  collectAllUnit: () => collectAllUnit,
  collectAllUnitPar: () => collectAllUnitPar,
  collectAllUnitParN: () => collectAllUnitParN,
  collectAllUnitParN_: () => collectAllUnitParN_,
  collectAllWith: () => collectAllWith,
  collectAllWithPar: () => collectAllWithPar,
  collectAllWithParN: () => collectAllWithParN,
  collectAllWithParN_: () => collectAllWithParN_,
  collectAllWithPar_: () => collectAllWithPar_,
  collectAllWith_: () => collectAllWith_,
  createQueue: () => createQueue,
  createQueue_: () => createQueue_,
  fiberJoinAll: () => fiberJoinAll,
  fiberWaitAll: () => fiberWaitAll,
  forEach: () => forEach,
  forEachExec: () => forEachExec,
  forEachExec_: () => forEachExec_,
  forEachPar: () => forEachPar,
  forEachParN: () => forEachParN,
  forEachParN_: () => forEachParN_,
  forEachParWithIndex: () => forEachParWithIndex,
  forEachParWithIndexN: () => forEachParWithIndexN,
  forEachParWithIndexN_: () => forEachParWithIndexN_,
  forEachParWithIndex_: () => forEachParWithIndex_,
  forEachPar_: () => forEachPar_,
  forEachUnit: () => forEachUnit,
  forEachUnitPar: () => forEachUnitPar,
  forEachUnitParN: () => forEachUnitParN,
  forEachUnitParN_: () => forEachUnitParN_,
  forEachUnitPar_: () => forEachUnitPar_,
  forEachUnit_: () => forEachUnit_,
  forEachWithIndex: () => forEachWithIndex,
  forEachWithIndex_: () => forEachWithIndex_,
  forEach_: () => forEach_,
  forkManaged: () => forkManaged,
  makeBoundedQueue: () => makeBoundedQueue,
  managedFork: () => managedFork,
  managedUse_: () => managedUse_,
  releaseMapReleaseAll: () => releaseMapReleaseAll,
  unsafeCreateQueue: () => unsafeCreateQueue
});
var cause = __toESM(require("../Cause/index.js"));
var ChunkCollect = __toESM(require("../Collections/Immutable/Chunk/api/collect.js"));
var ChunkFilter = __toESM(require("../Collections/Immutable/Chunk/api/filter.js"));
var ChunkForEach = __toESM(require("../Collections/Immutable/Chunk/api/forEach.js"));
var ChunkIndexWhere = __toESM(require("../Collections/Immutable/Chunk/api/indexWhere.js"));
var ChunkSplitAt = __toESM(require("../Collections/Immutable/Chunk/api/splitAt.js"));
var ChunkZip = __toESM(require("../Collections/Immutable/Chunk/api/zip.js"));
var Chunk = __toESM(require("../Collections/Immutable/Chunk/core.js"));
var L = __toESM(require("../Collections/Immutable/List/core.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var Ex = __toESM(require("../Exit/index.js"));
var import_interrupt = require("../Fiber/interrupt.js");
var import_Function = require("../Function/index.js");
var I = __toESM(require("../Iterable/index.js"));
var import_managed = require("../Managed/managed.js");
var import_add = require("../Managed/ReleaseMap/add.js");
var import_Exited = require("../Managed/ReleaseMap/Exited.js");
var import_makeReleaseMap = require("../Managed/ReleaseMap/makeReleaseMap.js");
var O = __toESM(require("../Option/index.js"));
var Q = __toESM(require("../Queue/core.js"));
var import_xqueue = require("../Queue/xqueue.js");
var import_AtomicBoolean = require("../Support/AtomicBoolean/index.js");
var import_MutableQueue = require("../Support/MutableQueue/index.js");
var asUnit = __toESM(require("./asUnit.js"));
var bracket = __toESM(require("./bracket.js"));
var import_bracketExit = require("./bracketExit.js");
var catchAll = __toESM(require("./catchAll.js"));
var core = __toESM(require("./core.js"));
var coreScope = __toESM(require("./core-scope.js"));
var Do = __toESM(require("./do.js"));
var import_done = require("./done.js");
var ensuring = __toESM(require("./ensuring.js"));
var import_environment = require("./environment.js");
var Ref = __toESM(require("./excl-deps-ref.js"));
var promise = __toESM(require("./excl-forEach-promise.js"));
var import_ExecutionStrategy = require("./ExecutionStrategy.js");
var fiberId = __toESM(require("./fiberId.js"));
var flatten = __toESM(require("./flatten.js"));
var ifM = __toESM(require("./ifM.js"));
var interruption = __toESM(require("./interruption.js"));
var map = __toESM(require("./map.js"));
var import_provideSome = require("./provideSome.js");
var tap = __toESM(require("./tap.js"));
var tapCause = __toESM(require("./tapCause.js"));
var import_toManaged = require("./toManaged.js");
var whenM = __toESM(require("./whenM.js"));
var zips = __toESM(require("./zips.js"));
function forEach_(as, f, __trace) {
  return core.suspend(() => {
    const acc = [];
    return map.map_(forEachUnit_(as, (a) => map.map_(f(a), (b) => {
      acc.push(b);
    })), () => Chunk.from(acc));
  }, __trace);
}
function forEachWithIndex_(as, f, __trace) {
  return core.suspend(() => {
    let index = 0;
    const acc = [];
    return map.map_(forEachUnit_(as, (a) => map.map_(f(a, index), (b) => {
      acc.push(b);
      index++;
    })), () => Chunk.from(acc));
  }, __trace);
}
function forEach(f, __trace) {
  return (as) => forEach_(as, f, __trace);
}
function forEachWithIndex(f, __trace) {
  return (as) => forEachWithIndex_(as, f, __trace);
}
function forEachUnitLoop(iterator, f) {
  const next = iterator.next();
  return next.done ? core.unit : core.chain_(f(next.value), () => forEachUnitLoop(iterator, f));
}
function forEachUnit_(as, f, __trace) {
  return core.suspend(() => forEachUnitLoop(as[Symbol.iterator](), f), __trace);
}
function forEachUnit(f, __trace) {
  return (as) => forEachUnit_(as, f, __trace);
}
function forEachUnitPar_(as, f, __trace) {
  const collection = L.from(as);
  const size = L.size(collection);
  if (L.isEmpty(collection)) {
    return core.unit;
  }
  return core.suspend(() => asUnit.asUnit(tap.tap_(tap.tap_(Do.let_(Do.bind_(Do.let_(Do.let_(Do.let_(Do.bind_(Do.bind_(Do.bind_(Do.bind_(Do.do, "parentId", () => fiberId.fiberId), "causes", () => Ref.makeRef(cause.empty)), "result", () => promise.make()), "status", () => Ref.makeRef(Tp.tuple(0, 0, false))), "startTask", ({
    status
  }) => Ref.modify_(status, ({
    tuple: [started, done2, failing]
  }) => {
    if (failing) {
      return Tp.tuple(false, Tp.tuple(started, done2, failing));
    }
    return Tp.tuple(true, Tp.tuple(started + 1, done2, failing));
  })), "startFailure", ({
    result,
    status
  }) => zips.zipRight_(Ref.update_(status, ({
    tuple: [started, done2, _]
  }) => Tp.tuple(started, done2, true)), promise.fail(void 0)(result))), "task", ({
    causes,
    parentId,
    result,
    startFailure,
    startTask,
    status
  }) => (a) => interruption.uninterruptible(ifM.ifM_(startTask, () => ensuring.ensuring_(tapCause.tapCause_(interruption.interruptible(core.suspend(() => f(a))), (c) => zips.zipRight_(Ref.update_(causes, (_) => cause.both(_, c)), startFailure)), (() => {
    const isComplete = Ref.modify_(status, ({
      tuple: [started, done2, failing]
    }) => {
      const newDone = done2 + 1;
      return Tp.tuple((failing ? started : size) === newDone, Tp.tuple(started, newDone, failing));
    });
    return whenM.whenM_(promise.succeed(void 0)(result), isComplete);
  })()), () => Ref.update_(causes, (_) => cause.both(_, cause.interrupt(parentId)))))), "fibers", ({
    task
  }) => coreScope.transplant((graft) => forEach_(collection, (a) => core.fork(graft(task(a)))))), "interrupter", ({
    fibers,
    parentId,
    result
  }) => forkManaged(catchAll.catchAll_(promise.await(result), () => core.chain_(forEach_(fibers, (_) => core.fork(_.interruptAs(parentId))), fiberJoinAll)))), ({
    causes,
    fibers,
    interrupter,
    result
  }) => managedUse_(interrupter, () => whenM.whenM_(zips.zipRight_(promise.fail(void 0)(result), core.chain_(causes.get, core.halt)), map.map_(forEach_(fibers, (_) => _.await), (_) => ChunkIndexWhere.indexWhere_(_, (ex) => !Ex.succeeded(ex)) !== -1)))), ({
    fibers
  }) => forEach_(fibers, (_) => _.inheritRefs))), __trace);
}
function forkManaged(self, __trace) {
  return managedFork((0, import_toManaged.toManaged)(self), __trace);
}
function forEachUnitPar(f, __trace) {
  return (as) => forEachUnitPar_(as, f, __trace);
}
function forEachPar_(as, f, __trace) {
  return core.suspend(() => core.chain_(core.succeedWith(() => []), (array) => map.map_(forEachUnitPar_(I.map_(as, (a, n) => [a, n]), ([a, n]) => core.chain_(core.suspend(() => f(a)), (b) => core.succeedWith(() => {
    array[n] = b;
  }))), () => Chunk.from(array))), __trace);
}
function forEachParWithIndex_(as, f, __trace) {
  return core.suspend(() => core.chain_(core.succeedWith(() => []), (array) => map.map_(forEachUnitPar_(I.map_(as, (a, n) => [a, n]), ([a, n]) => core.chain_(core.suspend(() => f(a, n)), (b) => core.succeedWith(() => {
    array[n] = b;
  }))), () => Chunk.from(array))), __trace);
}
function forEachPar(f, __trace) {
  return (as) => forEachPar_(as, f, __trace);
}
function forEachParWithIndex(f, __trace) {
  return (as) => forEachParWithIndex_(as, f, __trace);
}
function forEachUnitParN_(as, n, f, __trace) {
  const as_ = L.from(as);
  const size = L.size(as_);
  function worker(q, ref) {
    return whenM.whenM_(core.chain_(core.chain_(Q.take(q), f), () => worker(q, ref)), Ref.modify_(ref, (n2) => Tp.tuple(n2 > 0, n2 - 1)));
  }
  return core.suspend(() => bracket.bracket_(makeBoundedQueue(n), (q) => tap.tap_(Do.bind_(tap.tap_(Do.bind_(Do.do, "ref", () => Ref.makeRef(size)), () => core.fork(forEachUnit_(as, (x) => Q.offer_(q, x)))), "fibers", ({
    ref
  }) => collectAll(L.map_(L.range_(0, n), () => core.fork(worker(q, ref))))), ({
    fibers
  }) => forEach_(fibers, (_) => _.await)), (q) => Q.shutdown(q)), __trace);
}
function forEachUnitParN(n, f, __trace) {
  return (as) => forEachUnitParN_(as, n, f, __trace);
}
function forEachParN_(as, n, f, __trace) {
  function worker(q, pairs, ref) {
    return whenM.whenM_(core.chain_(core.chain_(Q.take(q), ({
      tuple: [p, a]
    }) => core.foldCauseM_(core.suspend(() => f(a)), (c) => forEach_(pairs, (_) => promise.halt(c)(_.get(0))), (b) => promise.succeed(b)(p))), () => worker(q, pairs, ref)), Ref.modify_(ref, (n2) => Tp.tuple(n2 > 0, n2 - 1)));
  }
  return core.suspend(() => bracket.bracket_(makeBoundedQueue(n), (q) => core.chain_(tap.tap_(tap.tap_(Do.bind_(Do.bind_(Do.do, "pairs", () => forEach_(as, (a) => map.map_(promise.make(), (p) => Tp.tuple(p, a)))), "ref", ({
    pairs
  }) => Ref.makeRef(Chunk.size(pairs))), ({
    pairs
  }) => core.fork(forEach_(pairs, (pair) => Q.offer_(q, pair)))), ({
    pairs,
    ref
  }) => collectAllUnit(L.map(() => core.fork(worker(q, pairs, ref)))(L.range_(0, n)))), ({
    pairs
  }) => forEach_(pairs, (_) => promise.await(_.get(0)))), Q.shutdown), __trace);
}
function forEachParWithIndexN_(as, n, f, __trace) {
  function worker(q, pairs, ref) {
    return whenM.whenM_(core.chain_(core.chain_(Q.take(q), ({
      tuple: [p, a, i]
    }) => core.foldCauseM_(core.suspend(() => f(a, i)), (c) => forEach_(pairs, (_) => promise.halt(c)(_.get(0))), (b) => promise.succeed(b)(p))), () => worker(q, pairs, ref)), Ref.modify_(ref, (n2) => Tp.tuple(n2 > 0, n2 - 1)));
  }
  return core.suspend(() => bracket.bracket_(makeBoundedQueue(n), (q) => core.chain_(tap.tap_(tap.tap_(Do.bind_(Do.bind_(Do.do, "pairs", () => forEachWithIndex_(as, (a, i) => map.map_(promise.make(), (p) => Tp.tuple(p, a, i)))), "ref", ({
    pairs
  }) => Ref.makeRef(Chunk.size(pairs))), ({
    pairs
  }) => core.fork(forEach_(pairs, (pair) => Q.offer_(q, pair)))), ({
    pairs,
    ref
  }) => collectAllUnit(L.map(() => core.fork(worker(q, pairs, ref)))(L.range_(0, n)))), ({
    pairs
  }) => forEach_(pairs, (_) => promise.await(_.get(0)))), Q.shutdown), __trace);
}
function forEachParN(n, f, __trace) {
  return (as) => forEachParN_(as, n, f, __trace);
}
function forEachParWithIndexN(n, f, __trace) {
  return (as) => forEachParWithIndexN_(as, n, f, __trace);
}
function forEachExec_(as, es, f, __trace) {
  switch (es._tag) {
    case "Sequential": {
      return forEach_(as, f, __trace);
    }
    case "Parallel": {
      return forEachPar_(as, f, __trace);
    }
    case "ParallelN": {
      return forEachParN_(as, es.n, f, __trace);
    }
  }
}
function forEachExec(es, f, __trace) {
  return (as) => forEachExec_(as, es, f, __trace);
}
function collectAll(as, __trace) {
  return forEach_(as, import_Function.identity, __trace);
}
function collectAllPar(as, __trace) {
  return forEachPar_(as, import_Function.identity, __trace);
}
function collectAllParN(n, __trace) {
  return (as) => forEachParN_(as, n, import_Function.identity, __trace);
}
function collectAllParN_(as, n, __trace) {
  return forEachParN_(as, n, import_Function.identity, __trace);
}
function collectAllUnit(as, __trace) {
  return forEachUnit_(as, import_Function.identity, __trace);
}
function collectAllUnitPar(as, __trace) {
  return forEachUnitPar_(as, import_Function.identity, __trace);
}
function collectAllUnitParN(n, __trace) {
  return (as) => forEachUnitParN_(as, n, import_Function.identity, __trace);
}
function collectAllUnitParN_(as, n, __trace) {
  return forEachUnitParN_(as, n, import_Function.identity, __trace);
}
function collectAllWith_(as, pf, __trace) {
  return map.map_(collectAll(as, __trace), ChunkCollect.collect(pf));
}
function collectAllWith(pf, __trace) {
  return (as) => collectAllWith_(as, pf, __trace);
}
function collectAllWithPar_(as, pf, __trace) {
  return map.map_(collectAllPar(as, __trace), ChunkCollect.collect(pf));
}
function collectAllWithPar(pf, __trace) {
  return (as) => collectAllWithPar_(as, pf, __trace);
}
function collectAllWithParN_(as, n, pf, __trace) {
  return map.map_(collectAllParN_(as, n, __trace), ChunkCollect.collect(pf));
}
function collectAllWithParN(n, pf, __trace) {
  return (as) => collectAllWithParN_(as, n, pf, __trace);
}
function collectAllSuccesses(as, __trace) {
  return collectAllWith_(I.map_(as, (x) => core.result(x)), (e) => e._tag === "Success" ? O.some(e.value) : O.none, __trace);
}
function collectAllSuccessesPar(as, __trace) {
  return collectAllWithPar_(I.map_(as, (x) => core.result(x)), (e) => e._tag === "Success" ? O.some(e.value) : O.none, __trace);
}
function collectAllSuccessesParN_(as, n, __trace) {
  return collectAllWithParN_(I.map_(as, (x) => core.result(x)), n, (e) => e._tag === "Success" ? O.some(e.value) : O.none, __trace);
}
function collectAllSuccessesParN(n, __trace) {
  return (as) => collectAllSuccessesParN_(as, n, __trace);
}
function fiberJoinAll(as, __trace) {
  return tap.tap_(core.chain_(fiberWaitAll(as), import_done.done), () => forEach_(as, (f) => f.inheritRefs), __trace);
}
function fiberWaitAll(as, __trace) {
  return core.result(forEachPar_(as, (f) => core.chain_(f.await, import_done.done)), __trace);
}
function releaseMapReleaseAll(exit, execStrategy, __trace) {
  return (_) => flatten.flatten(Ref.modify_(_.ref, (s) => {
    switch (s._tag) {
      case "Exited": {
        return Tp.tuple(core.unit, s);
      }
      case "Running": {
        switch (execStrategy._tag) {
          case "Sequential": {
            return Tp.tuple(core.chain_(forEach_(Array.from(s.finalizers()).reverse(), ([_2, f]) => core.result(f(exit)), __trace), (e) => (0, import_done.done)(O.getOrElse_(Ex.collectAll(...e), () => Ex.succeed([])))), new import_Exited.Exited(s.nextKey, exit));
          }
          case "Parallel": {
            return Tp.tuple(core.chain_(forEachPar_(Array.from(s.finalizers()).reverse(), ([_2, f]) => core.result(f(exit)), __trace), (e) => (0, import_done.done)(O.getOrElse_(Ex.collectAllPar(...e), () => Ex.succeed([])))), new import_Exited.Exited(s.nextKey, exit));
          }
          case "ParallelN": {
            return Tp.tuple(core.chain_(forEachParN_(Array.from(s.finalizers()).reverse(), execStrategy.n, ([_2, f]) => core.result(f(exit)), __trace), (e) => (0, import_done.done)(O.getOrElse_(Ex.collectAllPar(...e), () => Ex.succeed([])))), new import_Exited.Exited(s.nextKey, exit));
          }
        }
      }
    }
  }));
}
function managedFork(self, __trace) {
  return (0, import_managed.managedApply)(interruption.uninterruptibleMask(({
    restore
  }) => map.map_(Do.bind_(Do.bind_(Do.bind_(Do.let_(Do.let_(Do.bind_(Do.do, "tp", () => (0, import_environment.environment)()), "r", ({
    tp
  }) => tp.get(0)), "outerReleaseMap", ({
    tp
  }) => tp.get(1)), "innerReleaseMap", () => import_makeReleaseMap.makeReleaseMap), "fiber", ({
    innerReleaseMap,
    r
  }) => restore(core.provideAll_(coreScope.forkDaemon(map.map_(self.effect, (_) => _.get(1))), Tp.tuple(r, innerReleaseMap), __trace))), "releaseMapEntry", ({
    fiber,
    innerReleaseMap,
    outerReleaseMap
  }) => (0, import_add.add)((e) => core.chain_((0, import_interrupt.interrupt)(fiber), () => releaseMapReleaseAll(e, import_ExecutionStrategy.sequential)(innerReleaseMap), __trace))(outerReleaseMap)), ({
    fiber,
    releaseMapEntry
  }) => Tp.tuple(releaseMapEntry, fiber))));
}
function managedUse_(self, f, __trace) {
  return (0, import_bracketExit.bracketExit_)(import_makeReleaseMap.makeReleaseMap, (rm) => core.chain_((0, import_provideSome.provideSome_)(self.effect, (r) => Tp.tuple(r, rm)), (a) => f(a.get(1)), __trace), (rm, ex) => releaseMapReleaseAll(ex, import_ExecutionStrategy.sequential, __trace)(rm));
}
class BackPressureStrategy {
  constructor() {
    this.putters = new import_MutableQueue.Unbounded();
  }
  handleSurplus(as, queue, takers, isShutdown) {
    return core.suspend((_, fiberId2) => {
      const p = promise.unsafeMake(fiberId2);
      return interruption.onInterrupt_(core.suspend(() => {
        this.unsafeOffer(as, p);
        this.unsafeOnQueueEmptySpace(queue, takers);
        Q.unsafeCompleteTakers(this, queue, takers);
        if (isShutdown.get) {
          return interruption.interrupt;
        } else {
          return promise.await(p);
        }
      }), () => core.succeedWith(() => this.unsafeRemove(p)));
    });
  }
  unsafeRemove(p) {
    Q.unsafeOfferAll(this.putters, ChunkFilter.filter_(Q.unsafePollAll(this.putters), ([_, __]) => __ !== p));
  }
  unsafeOffer(as, p) {
    let bs = as;
    while (Chunk.size(bs) > 0) {
      const head = Chunk.unsafeGet_(bs, 0);
      bs = Chunk.drop_(bs, 1);
      if (Chunk.size(bs) === 0) {
        this.putters.offer(Tp.tuple(head, p, true));
        return;
      } else {
        this.putters.offer(Tp.tuple(head, p, false));
      }
    }
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && !queue.isFull) {
      const putter = this.putters.poll(void 0);
      if (putter != null) {
        const offered = queue.offer(putter.get(0));
        if (offered && putter.get(2)) {
          Q.unsafeCompletePromise(putter.get(1), true);
        } else if (!offered) {
          Q.unsafeOfferAll(this.putters, Chunk.prepend_(Q.unsafePollAll(this.putters), putter));
        }
        Q.unsafeCompleteTakers(this, queue, takers);
      } else {
        keepPolling = false;
      }
    }
  }
  get shutdown() {
    return asUnit.asUnit(tap.tap_(Do.bind_(Do.bind_(Do.do, "fiberId", () => fiberId.fiberId), "putters", () => core.succeedWith(() => Q.unsafePollAll(this.putters))), (s) => forEachPar_(s.putters, ({
      tuple: [_, p, lastItem]
    }) => lastItem ? promise.interruptAs(s.fiberId)(p) : core.unit)));
  }
  get surplusSize() {
    return this.putters.size;
  }
}
function makeBoundedQueue(capacity, __trace) {
  return core.chain_(core.succeedWith(() => new import_MutableQueue.Bounded(capacity)), (x) => createQueue_(x, new BackPressureStrategy()), __trace);
}
function unsafeCreateQueue(queue, takers, shutdownHook, shutdownFlag, strategy) {
  return new UnsafeCreate(queue, takers, shutdownHook, shutdownFlag, strategy);
}
class UnsafeCreate extends import_xqueue.XQueueInternal {
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.awaitShutdown = promise.await(this.shutdownHook);
    this.capacity = this.queue.capacity;
    this.isShutdown = core.succeedWith(() => this.shutdownFlag.get);
    this.shutdown = interruption.uninterruptible(core.suspend((_, fiberId2) => {
      this.shutdownFlag.set(true);
      return whenM.whenM_(core.chain_(forEachPar_(Q.unsafePollAll(this.takers), promise.interruptAs(fiberId2)), () => this.strategy.shutdown), promise.succeed(void 0)(this.shutdownHook));
    }));
    this.size = core.suspend(() => {
      if (this.shutdownFlag.get) {
        return interruption.interrupt;
      } else {
        return core.succeed(this.queue.size - this.takers.size + this.strategy.surplusSize);
      }
    });
    this.take = core.suspend((_, fiberId2) => {
      if (this.shutdownFlag.get) {
        return interruption.interrupt;
      }
      const item = this.queue.poll(void 0);
      if (item) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return core.succeed(item);
      } else {
        const p = promise.unsafeMake(fiberId2);
        return interruption.onInterrupt_(core.suspend(() => {
          this.takers.offer(p);
          Q.unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          if (this.shutdownFlag.get) {
            return interruption.interrupt;
          } else {
            return promise.await(p);
          }
        }), () => core.succeedWith(() => Q.unsafeRemove(this.takers, p)));
      }
    });
    this.takeAll = core.suspend(() => {
      if (this.shutdownFlag.get) {
        return interruption.interrupt;
      } else {
        return core.succeedWith(() => {
          const as = Q.unsafePollAll(this.queue);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return as;
        });
      }
    });
  }
  offer(a) {
    return core.suspend(() => {
      if (this.shutdownFlag.get) {
        return interruption.interrupt;
      } else {
        const noRemaining = (() => {
          if (this.queue.isEmpty) {
            const taker = this.takers.poll(void 0);
            if (!taker) {
              return false;
            } else {
              Q.unsafeCompletePromise(taker, a);
              return true;
            }
          } else {
            return false;
          }
        })();
        if (noRemaining) {
          return core.succeed(true);
        }
        const succeeded = this.queue.offer(a);
        Q.unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        if (succeeded) {
          return core.succeed(true);
        } else {
          return this.strategy.handleSurplus(Chunk.single(a), this.queue, this.takers, this.shutdownFlag);
        }
      }
    });
  }
  offerAll(as) {
    const arr = Chunk.from(as);
    return core.suspend(() => {
      if (this.shutdownFlag.get) {
        return interruption.interrupt;
      } else {
        const pTakers = this.queue.isEmpty ? Q.unsafePollN(this.takers, Chunk.size(arr)) : Chunk.empty();
        const {
          tuple: [forTakers, remaining]
        } = ChunkSplitAt.splitAt_(arr, Chunk.size(pTakers));
        ChunkForEach.forEach_(ChunkZip.zip_(pTakers, forTakers), ({
          tuple: [taker, item]
        }) => {
          Q.unsafeCompletePromise(taker, item);
        });
        if (Chunk.size(remaining) === 0) {
          return core.succeed(true);
        }
        const surplus = Q.unsafeOfferAll(this.queue, remaining);
        Q.unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        if (Chunk.size(surplus) === 0) {
          return core.succeed(true);
        } else {
          return this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
        }
      }
    });
  }
  takeUpTo(n) {
    return core.suspend(() => {
      if (this.shutdownFlag.get) {
        return interruption.interrupt;
      } else {
        return core.succeedWith(() => {
          const as = Q.unsafePollN(this.queue, n);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return as;
        });
      }
    });
  }
}
function createQueue_(queue, strategy, __trace) {
  return map.map_(promise.make(), (p) => unsafeCreateQueue(queue, new import_MutableQueue.Unbounded(), p, new import_AtomicBoolean.AtomicBoolean(false), strategy), __trace);
}
function createQueue(strategy, __trace) {
  return (queue) => createQueue_(queue, strategy, __trace);
}
module.exports = __toCommonJS(excl_forEach_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BackPressureStrategy,
  collectAll,
  collectAllPar,
  collectAllParN,
  collectAllParN_,
  collectAllSuccesses,
  collectAllSuccessesPar,
  collectAllSuccessesParN,
  collectAllSuccessesParN_,
  collectAllUnit,
  collectAllUnitPar,
  collectAllUnitParN,
  collectAllUnitParN_,
  collectAllWith,
  collectAllWithPar,
  collectAllWithParN,
  collectAllWithParN_,
  collectAllWithPar_,
  collectAllWith_,
  createQueue,
  createQueue_,
  fiberJoinAll,
  fiberWaitAll,
  forEach,
  forEachExec,
  forEachExec_,
  forEachPar,
  forEachParN,
  forEachParN_,
  forEachParWithIndex,
  forEachParWithIndexN,
  forEachParWithIndexN_,
  forEachParWithIndex_,
  forEachPar_,
  forEachUnit,
  forEachUnitPar,
  forEachUnitParN,
  forEachUnitParN_,
  forEachUnitPar_,
  forEachUnit_,
  forEachWithIndex,
  forEachWithIndex_,
  forEach_,
  forkManaged,
  makeBoundedQueue,
  managedFork,
  managedUse_,
  releaseMapReleaseAll,
  unsafeCreateQueue
});
