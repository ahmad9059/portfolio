var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  acquireReleaseOutExitWith: () => acquireReleaseOutExitWith,
  acquireReleaseOutExitWith_: () => acquireReleaseOutExitWith_,
  catchAllCause: () => catchAllCause,
  catchAllCause_: () => catchAllCause_,
  chain: () => chain,
  chain_: () => chain_,
  concatAllWith: () => concatAllWith,
  concatAllWith_: () => concatAllWith_,
  concatMapWith: () => concatMapWith,
  concatMapWith_: () => concatMapWith_,
  die: () => die,
  dieWith: () => dieWith,
  embedInput: () => embedInput,
  embedInput_: () => embedInput_,
  end: () => end,
  endWith: () => endWith,
  ensuringWith: () => ensuringWith,
  ensuringWith_: () => ensuringWith_,
  fail: () => fail,
  failCause: () => failCause,
  failCauseWith: () => failCauseWith,
  failWith: () => failWith,
  foldCauseChannel: () => foldCauseChannel,
  foldCauseChannel_: () => foldCauseChannel_,
  fromEffect: () => fromEffect,
  makeSingleProducerAsyncInput: () => import_producer.makeSingleProducerAsyncInput,
  pipeTo: () => pipeTo,
  pipeTo_: () => pipeTo_,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  readOrFail: () => readOrFail,
  readWithCause: () => readWithCause,
  succeedWith: () => succeedWith,
  suspend: () => suspend,
  write: () => write,
  writeWith: () => writeWith
});
var import_Operator = require("../../../Operator/index.js");
var Cause = __toESM(require("../../../Cause/index.js"));
var import_Function = require("../../../Function/index.js");
var P = __toESM(require("./_internal/primitives.js"));
var import_producer = require("./_internal/producer.js");
__reExport(core_exports, require("./_internal/primitives.js"));
function pipeTo_(left, right) {
  return new P.PipeTo(() => left, () => right);
}
function pipeTo(right) {
  return (left) => pipeTo_(left, right);
}
function readWithCause(inp, halt, done) {
  return new P.Read(inp, new P.ContinuationK(done, halt));
}
function endWith(result) {
  return new P.Done(result);
}
function end(result) {
  return new P.Done(() => result);
}
function failCauseWith(result) {
  return new P.Halt(result);
}
function failCause(result) {
  return new P.Halt(() => result);
}
function failWith(error) {
  return new P.Halt(() => Cause.fail(error()));
}
function fail(error) {
  return new P.Halt(() => Cause.fail(error));
}
function die(defect) {
  return new P.Halt(() => Cause.die(defect));
}
function dieWith(defect) {
  return new P.Halt(() => Cause.die(defect()));
}
function writeWith(out) {
  return new P.Emit(out);
}
function write(out) {
  return new P.Emit(() => out);
}
function ensuringWith_(channel, finalizer) {
  return new P.Ensuring(channel, finalizer);
}
function ensuringWith(finalizer) {
  return (channel) => ensuringWith_(channel, finalizer);
}
function concatMapWith_(self, f, g, h) {
  return new P.ConcatAll(g, h, self, f);
}
function concatMapWith(f, g, h) {
  return (self) => concatMapWith_(self, f, g, h);
}
function concatAllWith_(channels, f, g) {
  return new P.ConcatAll(f, g, channels, import_Function.identity);
}
function concatAllWith(f, g) {
  return (channels) => concatAllWith_(channels, f, g);
}
function foldCauseChannel_(self, onErr, onSucc) {
  return new P.Fold(self, new P.ContinuationK(onSucc, onErr));
}
function foldCauseChannel(onErr, onSucc) {
  return (self) => foldCauseChannel_(self, onErr, onSucc);
}
function embedInput_(self, input) {
  return new P.Bridge(input, self);
}
function embedInput(input) {
  return (self) => embedInput_(self, input);
}
function acquireReleaseOutExitWith_(self, release) {
  return new P.BracketOut(self, release);
}
function acquireReleaseOutExitWith(release) {
  return (self) => acquireReleaseOutExitWith_(self, release);
}
function provideAll_(self, env) {
  return new P.Provide(env, self);
}
function provideAll(env) {
  return (self) => provideAll_(self, env);
}
function chain_(self, f) {
  return new P.Fold(self, new P.ContinuationK(f, failCause));
}
function chain(f) {
  return (self) => chain_(self, f);
}
function suspend(effect) {
  return new P.EffectSuspendTotal(effect);
}
function fromEffect(self) {
  return new P.Effect(self);
}
function succeedWith(effect) {
  return new P.EffectTotal(effect);
}
function readOrFail(e) {
  return new P.Read((in_) => end(in_), new P.ContinuationK((_) => fail(e), (_) => fail(e)));
}
function catchAllCause_(self, f) {
  return new P.Fold(self, new P.ContinuationK((_) => end(_), f));
}
function catchAllCause(f) {
  return (self) => catchAllCause_(self, f);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  acquireReleaseOutExitWith,
  acquireReleaseOutExitWith_,
  catchAllCause,
  catchAllCause_,
  chain,
  chain_,
  concatAllWith,
  concatAllWith_,
  concatMapWith,
  concatMapWith_,
  die,
  dieWith,
  embedInput,
  embedInput_,
  end,
  endWith,
  ensuringWith,
  ensuringWith_,
  fail,
  failCause,
  failCauseWith,
  failWith,
  foldCauseChannel,
  foldCauseChannel_,
  fromEffect,
  makeSingleProducerAsyncInput,
  pipeTo,
  pipeTo_,
  provideAll,
  provideAll_,
  readOrFail,
  readWithCause,
  succeedWith,
  suspend,
  write,
  writeWith
});
