var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var producer_exports = {};
__export(producer_exports, {
  DoneTypeId: () => DoneTypeId,
  EmitTypeId: () => EmitTypeId,
  EmptyTypeId: () => EmptyTypeId,
  ErrorTypeId: () => ErrorTypeId,
  SingleProducerAsyncInput: () => SingleProducerAsyncInput,
  StateDone: () => StateDone,
  StateEmit: () => StateEmit,
  StateEmpty: () => StateEmpty,
  StateError: () => StateError,
  makeSingleProducerAsyncInput: () => makeSingleProducerAsyncInput
});
var import_Operator = require("../../../../Operator/index.js");
var Cause = __toESM(require("../../../../Cause/index.js"));
var Tp = __toESM(require("../../../../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../../../../Effect/index.js"));
var E = __toESM(require("../../../../Either/index.js"));
var Exit = __toESM(require("../../../../Exit/index.js"));
var P = __toESM(require("../../../../Promise/index.js"));
var Ref = __toESM(require("../../../../Ref/index.js"));
var IQ = __toESM(require("../../../../Support/ImmutableQueue/index.js"));
const DoneTypeId = /* @__PURE__ */ Symbol();
class StateDone {
  constructor(a) {
    this.a = a;
    this._typeId = DoneTypeId;
  }
}
const ErrorTypeId = /* @__PURE__ */ Symbol();
class StateError {
  constructor(cause) {
    this.cause = cause;
    this._typeId = ErrorTypeId;
  }
}
const EmptyTypeId = /* @__PURE__ */ Symbol();
class StateEmpty {
  constructor(notifyProducer) {
    this.notifyProducer = notifyProducer;
    this._typeId = EmptyTypeId;
  }
}
const EmitTypeId = /* @__PURE__ */ Symbol();
class StateEmit {
  constructor(notifyConsumers) {
    this.notifyConsumers = notifyConsumers;
    this._typeId = EmitTypeId;
  }
}
class SingleProducerAsyncInput {
  constructor(ref) {
    this.ref = ref;
    this.take = this.takeWith((c) => Exit.halt(Cause.map_(c, E.left)), (el) => Exit.succeed(el), (d) => Exit.fail(E.right(d)));
    this.close = T.chain_(T.fiberId, (id) => this.error(Cause.interrupt(id)));
    this.awaitRead = T.flatten(Ref.modify_(this.ref, (state) => {
      if (state._typeId === EmptyTypeId) {
        return Tp.tuple(P.await(state.notifyProducer), state);
      }
      return Tp.tuple(T.unit, state);
    }));
  }
  emit(el) {
    return T.chain_(P.make(), (p) => T.flatten(Ref.modify_(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId: {
          const dequeued = state.notifyConsumers.dequeue();
          if (dequeued._tag === "Some") {
            const {
              tuple: [notifyConsumer, notifyConsumers]
            } = dequeued.value;
            return Tp.tuple(P.succeed_(notifyConsumer, E.right(el)), notifyConsumers.size === 0 ? new StateEmpty(p) : new StateEmit(notifyConsumers));
          }
          throw new Error("SingleProducerAsyncInput#emit: queue was empty");
        }
        case ErrorTypeId: {
          return Tp.tuple(T.interrupt, state);
        }
        case DoneTypeId: {
          return Tp.tuple(T.interrupt, state);
        }
        case EmptyTypeId: {
          return Tp.tuple(P.await(state.notifyProducer), state);
        }
      }
    })));
  }
  done(a) {
    return T.chain_(P.make(), (p) => T.flatten(Ref.modify_(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId: {
          return Tp.tuple(T.forEachUnit_(state.notifyConsumers, (p2) => P.succeed_(p2, E.left(a))), new StateDone(a));
        }
        case ErrorTypeId: {
          return Tp.tuple(T.interrupt, state);
        }
        case DoneTypeId: {
          return Tp.tuple(T.interrupt, state);
        }
        case EmptyTypeId: {
          return Tp.tuple(P.await(state.notifyProducer), state);
        }
      }
    })));
  }
  error(cause) {
    return T.chain_(P.make(), (p) => T.flatten(Ref.modify_(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId: {
          return Tp.tuple(T.forEachUnit_(state.notifyConsumers, (p2) => P.halt_(p2, cause)), new StateError(cause));
        }
        case ErrorTypeId: {
          return Tp.tuple(T.interrupt, state);
        }
        case DoneTypeId: {
          return Tp.tuple(T.interrupt, state);
        }
        case EmptyTypeId: {
          return Tp.tuple(P.await(state.notifyProducer), state);
        }
      }
    })));
  }
  takeWith(onError, onElement, onDone) {
    return T.chain_(P.make(), (p) => T.flatten(Ref.modify_(this.ref, (state) => {
      switch (state._typeId) {
        case EmitTypeId: {
          return Tp.tuple(T.foldCause_(P.await(p), onError, E.fold(onDone, onElement)), new StateEmit(state.notifyConsumers.push(p)));
        }
        case ErrorTypeId: {
          return Tp.tuple(T.succeed(onError(state.cause)), state);
        }
        case DoneTypeId: {
          return Tp.tuple(T.succeed(onDone(state.a)), state);
        }
        case EmptyTypeId: {
          return Tp.tuple(T.zipRight_(P.succeed_(state.notifyProducer, void 0), T.foldCause_(P.await(p), onError, E.fold(onDone, onElement))), new StateEmit(IQ.ImmutableQueue.single(p)));
        }
      }
    })));
  }
}
function makeSingleProducerAsyncInput() {
  return T.map_(T.chain_(P.make(), (p) => Ref.makeRef(new StateEmpty(p))), (ref) => new SingleProducerAsyncInput(ref));
}
module.exports = __toCommonJS(producer_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DoneTypeId,
  EmitTypeId,
  EmptyTypeId,
  ErrorTypeId,
  SingleProducerAsyncInput,
  StateDone,
  StateEmit,
  StateEmpty,
  StateError,
  makeSingleProducerAsyncInput
});
