var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var zipAllSortedByKeyWithExec_exports = {};
__export(zipAllSortedByKeyWithExec_exports, {
  zipAllSortedByKeyWithExec: () => zipAllSortedByKeyWithExec,
  zipAllSortedByKeyWithExec_: () => zipAllSortedByKeyWithExec_
});
var A = __toESM(require("../../../Collections/Immutable/Chunk/index.js"));
var Tp = __toESM(require("../../../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../../../Effect/index.js"));
var Ex = __toESM(require("../../../Exit/index.js"));
var O = __toESM(require("../../../Option/index.js"));
var CombineChunks = __toESM(require("../_internal/api/combineChunks.js"));
class DrainLeft {
  constructor() {
    this._tag = "DrainLeft";
  }
}
class DrainRight {
  constructor() {
    this._tag = "DrainRight";
  }
}
class PullBoth {
  constructor() {
    this._tag = "PullBoth";
  }
}
class PullLeft {
  constructor(rightChunk) {
    this.rightChunk = rightChunk;
    this._tag = "PullLeft";
  }
}
class PullRight {
  constructor(leftChunk) {
    this.leftChunk = leftChunk;
    this._tag = "PullRight";
  }
}
function zipAllSortedByKeyWithExec_(self, that, left, right, both, ord, exec) {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case "DrainLeft":
        return T.fold_(pullLeft, (e) => Ex.fail(e), (leftChunk) => Ex.succeed(Tp.tuple(A.map_(leftChunk, ({
          tuple: [k, a]
        }) => Tp.tuple(k, left(a))), new DrainLeft())));
      case "DrainRight":
        return T.fold_(pullRight, (e) => Ex.fail(e), (rightChunk) => Ex.succeed(Tp.tuple(A.map_(rightChunk, ({
          tuple: [k, b]
        }) => Tp.tuple(k, right(b))), new DrainRight())));
      case "PullBoth": {
        switch (exec._tag) {
          case "Sequential":
            return T.foldM_(pullLeft, O.fold(() => pull(new DrainRight(), pullLeft, pullRight), (e) => T.succeed(Ex.fail(O.some(e)))), (leftChunk) => A.isEmpty(leftChunk) ? pull(new PullBoth(), pullLeft, pullRight) : pull(new PullRight(leftChunk), pullLeft, pullRight));
          default:
            return T.foldM_(T.zipPar_(T.unsome(pullLeft), T.unsome(pullRight)), (e) => T.succeed(Ex.fail(O.some(e))), ({
              tuple: [a, b]
            }) => {
              if (O.isSome(a) && O.isSome(b)) {
                const leftChunk = a.value;
                const rightChunk = b.value;
                if (A.isEmpty(leftChunk) && A.isEmpty(rightChunk)) {
                  return pull(new PullBoth(), pullLeft, pullRight);
                } else if (A.isEmpty(leftChunk)) {
                  return pull(new PullLeft(rightChunk), pullLeft, pullRight);
                } else if (A.isEmpty(rightChunk)) {
                  return pull(new PullRight(leftChunk), pullLeft, pullRight);
                } else {
                  return T.succeed(Ex.succeed(mergeSortedByKeyChunk(leftChunk, rightChunk)));
                }
              } else if (O.isSome(a)) {
                const leftChunk = a.value;
                return A.isEmpty(leftChunk) ? pull(new DrainLeft(), pullLeft, pullRight) : T.succeed(Ex.succeed(Tp.tuple(A.map_(leftChunk, ({
                  tuple: [k, a2]
                }) => Tp.tuple(k, left(a2))), new DrainLeft())));
              } else if (O.isSome(b)) {
                const rightChunk = b.value;
                return A.isEmpty(rightChunk) ? pull(new DrainLeft(), pullLeft, pullRight) : T.succeed(Ex.succeed(Tp.tuple(A.map_(rightChunk, ({
                  tuple: [k, b2]
                }) => Tp.tuple(k, right(b2))), new DrainRight())));
              } else {
                return T.succeed(Ex.fail(O.none));
              }
            });
        }
      }
      case "PullLeft": {
        const rightChunk = state.rightChunk;
        return T.foldM_(pullLeft, O.fold(() => T.succeed(Ex.succeed(Tp.tuple(A.map_(rightChunk, ({
          tuple: [k, b]
        }) => Tp.tuple(k, right(b))), new DrainRight()))), (e) => T.succeed(Ex.fail(O.some(e)))), (leftChunk) => A.isEmpty(leftChunk) ? pull(new PullLeft(rightChunk), pullLeft, pullRight) : T.succeed(Ex.succeed(mergeSortedByKeyChunk(leftChunk, rightChunk))));
      }
      case "PullRight": {
        const leftChunk = state.leftChunk;
        return T.foldM_(pullRight, O.fold(() => T.succeed(Ex.succeed(Tp.tuple(A.map_(leftChunk, ({
          tuple: [k, a]
        }) => Tp.tuple(k, left(a))), new DrainLeft()))), (e) => T.succeed(Ex.fail(O.some(e)))), (rightChunk) => A.isEmpty(rightChunk) ? pull(new PullRight(leftChunk), pullLeft, pullRight) : T.succeed(Ex.succeed(mergeSortedByKeyChunk(leftChunk, rightChunk))));
      }
    }
  };
  const mergeSortedByKeyChunk = (leftChunk, rightChunk) => {
    const builder = A.builder();
    let state;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = A.unsafeGet_(leftChunk, leftIndex);
    let rightTuple = A.unsafeGet_(rightChunk, rightIndex);
    let k1 = leftTuple.get(0);
    let a = leftTuple.get(1);
    let k2 = rightTuple.get(0);
    let b = rightTuple.get(1);
    let loop = true;
    const hasNext = (c, index) => index < A.size(c) - 1;
    while (loop) {
      const compare = ord.compare(k1, k2);
      if (compare === 0) {
        builder.append(Tp.tuple(k1, both(a, b)));
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex += 1;
          rightIndex += 1;
          leftTuple = A.unsafeGet_(leftChunk, leftIndex);
          rightTuple = A.unsafeGet_(rightChunk, rightIndex);
          k1 = leftTuple.get(0);
          a = leftTuple.get(1);
          k2 = rightTuple.get(0);
          b = rightTuple.get(1);
        } else if (hasNext(leftChunk, leftIndex)) {
          state = new PullRight(A.drop_(leftChunk, leftIndex + 1));
          loop = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = new PullLeft(A.drop_(rightChunk, rightIndex + 1));
          loop = false;
        } else {
          state = new PullBoth();
          loop = false;
        }
      } else if (compare < 0) {
        builder.append(Tp.tuple(k1, left(a)));
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex += 1;
          leftTuple = A.unsafeGet_(leftChunk, leftIndex);
          k1 = leftTuple.get(0);
          a = leftTuple.get(1);
        } else {
          const rightBuilder = A.builder();
          rightBuilder.append(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex += 1;
            rightTuple = A.unsafeGet_(rightChunk, rightIndex);
            rightBuilder.append(rightTuple);
            state = new PullLeft(rightBuilder.build());
            loop = false;
          }
        }
      } else {
        builder.append(Tp.tuple(k2, right(b)));
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex += 1;
          rightTuple = A.unsafeGet_(rightChunk, rightIndex);
          k2 = rightTuple.get(0);
          b = rightTuple.get(1);
        } else {
          const leftBuilder = A.builder();
          leftBuilder.append(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex += 1;
            leftTuple = A.unsafeGet_(leftChunk, leftIndex);
            leftBuilder.append(leftTuple);
            state = new PullRight(leftBuilder.build());
            loop = false;
          }
        }
      }
    }
    return Tp.tuple(builder.build(), state);
  };
  return CombineChunks.combineChunks_(self, that, new PullBoth(), pull);
}
function zipAllSortedByKeyWithExec(that, left, right, both, ord, exec) {
  return (self) => zipAllSortedByKeyWithExec_(self, that, left, right, both, ord, exec);
}
module.exports = __toCommonJS(zipAllSortedByKeyWithExec_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  zipAllSortedByKeyWithExec,
  zipAllSortedByKeyWithExec_
});
