var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var GroupBy_exports = {};
__export(GroupBy_exports, {
  GroupBy: () => GroupBy,
  filter: () => filter,
  filter_: () => filter_,
  first: () => first,
  first_: () => first_,
  make: () => make,
  make_: () => make_,
  mergeGroupBy: () => mergeGroupBy,
  mergeGroupBy_: () => mergeGroupBy_
});
var Mp = __toESM(require("../../../Collections/Immutable/Map/index.js"));
var Tp = __toESM(require("../../../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../../../Effect/index.js"));
var Ex = __toESM(require("../../../Exit/index.js"));
var import_Function = require("../../../Function/index.js");
var M = __toESM(require("../../../Managed/index.js"));
var O = __toESM(require("../../../Option/index.js"));
var P = __toESM(require("../../../Promise/index.js"));
var Q = __toESM(require("../../../Queue/index.js"));
var Ref = __toESM(require("../../../Ref/index.js"));
var ChainPar = __toESM(require("../_internal/api/chainPar.js"));
var DistributedWithDynamic = __toESM(require("../_internal/api/distributedWithDynamic.js"));
var FilterEffect = __toESM(require("../_internal/api/filterEffect.js"));
var FlattenExitOption = __toESM(require("../_internal/api/flattenExitOption.js"));
var FromQueueWithShutdown = __toESM(require("../_internal/api/fromQueueWithShutdown.js"));
var Map = __toESM(require("../_internal/api/map.js"));
var MapEffect = __toESM(require("../_internal/api/mapEffect.js"));
var UnwrapManaged = __toESM(require("../_internal/api/unwrapManaged.js"));
var ZipWithIndex = __toESM(require("../_internal/api/zipWithIndex.js"));
class GroupBy {
}
class GroupByInternal extends GroupBy {
  constructor(stream, key, buffer) {
    super();
    this.stream = stream;
    this.key = key;
    this.buffer = buffer;
    this.grouped = UnwrapManaged.unwrapManaged(M.map_(M.tap_(M.bind_(M.bind_(M.bind_(M.bind_(M.do, "decider", () => T.toManaged(P.make())), "out", () => T.toManagedRelease_(Q.makeBounded(this.buffer), Q.shutdown)), "ref", () => T.toManaged(Ref.makeRef(Mp.empty))), "add", ({
      decider,
      out
    }) => DistributedWithDynamic.distributedWithDynamic_(MapEffect.mapEffect_(this.stream, this.key), this.buffer, ({
      tuple: [k, v]
    }) => T.chain_(P.await(decider), (_) => _(k, v)), (_) => Q.offer_(out, _))), ({
      add,
      decider,
      out,
      ref
    }) => T.toManaged(P.succeed_(decider, (k, _) => T.chain_(T.map_(ref.get, Mp.lookup(k)), O.fold(() => T.chain_(add, ({
      tuple: [idx, q]
    }) => T.as_(T.zipRight_(Ref.update_(ref, Mp.insert(k, idx)), Q.offer_(out, Ex.succeed(Tp.tuple(k, Q.map_(q, Ex.map(({
      tuple: [_2, a]
    }) => a)))))), (_2) => _2 === idx)), (idx) => T.succeed((_2) => _2 === idx)))))), ({
      out
    }) => FlattenExitOption.flattenExitOption(FromQueueWithShutdown.fromQueueWithShutdown_(out))));
  }
  first(n) {
    return new FirstInternal(this.stream, this.key, this.buffer, n);
  }
  filter(f) {
    return new FilterInternal(this.stream, this.key, this.buffer, f);
  }
  apply(f) {
    return ChainPar.chainPar_(this.grouped, Number.MAX_SAFE_INTEGER, ({
      tuple: [k, q]
    }) => f(k, FlattenExitOption.flattenExitOption(FromQueueWithShutdown.fromQueueWithShutdown_(q))));
  }
}
class FirstInternal extends GroupByInternal {
  constructor(stream, key, buffer, n) {
    super(stream, key, buffer);
    this.n = n;
    this.grouped = Map.map_(FilterEffect.filterEffect_(ZipWithIndex.zipWithIndex(super.grouped), (elem) => {
      const {
        tuple: [{
          tuple: [_, q]
        }, i]
      } = elem;
      return i < this.n ? T.as_(T.succeed(elem), true) : T.as_(Q.shutdown(q), false);
    }), Tp.get(0));
  }
}
class FilterInternal extends GroupByInternal {
  constructor(stream, key, buffer, f) {
    super(stream, key, buffer);
    this.f = f;
    this.grouped = FilterEffect.filterEffect_(super.grouped, (elem) => {
      const {
        tuple: [k, q]
      } = elem;
      return this.f(k) ? T.as_(T.succeed(elem), true) : T.as_(Q.shutdown(q), false);
    });
  }
}
function concrete(_groupBy) {
}
function make_(stream, key, buffer) {
  return new GroupByInternal(stream, key, buffer);
}
function make(key, buffer) {
  return (stream) => make_(stream, key, buffer);
}
function filter_(self, f) {
  concrete(self);
  return self.filter(f);
}
function filter(f) {
  return (self) => filter_(self, f);
}
function first_(self, n) {
  concrete(self);
  return self.first(n);
}
function first(n) {
  return (self) => first_(self, n);
}
function mergeGroupBy_(self, f) {
  concrete(self);
  return self.apply(f);
}
function mergeGroupBy(f) {
  return (self) => mergeGroupBy_(self, f);
}
module.exports = __toCommonJS(GroupBy_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GroupBy,
  filter,
  filter_,
  first,
  first_,
  make,
  make_,
  mergeGroupBy,
  mergeGroupBy_
});
