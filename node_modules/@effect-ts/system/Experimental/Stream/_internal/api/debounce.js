var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var debounce_exports = {};
__export(debounce_exports, {
  debounce: () => debounce,
  debounce_: () => debounce_
});
var CL = __toESM(require("../../../../Clock/index.js"));
var CK = __toESM(require("../../../../Collections/Immutable/Chunk/index.js"));
var T = __toESM(require("../../../../Effect/index.js"));
var Ex = __toESM(require("../../../../Exit/index.js"));
var F = __toESM(require("../../../../Fiber/index.js"));
var import_Function = require("../../../../Function/index.js");
var M = __toESM(require("../../../../Managed/index.js"));
var O = __toESM(require("../../../../Option/index.js"));
var CH = __toESM(require("../../Channel/index.js"));
var C = __toESM(require("../core.js"));
var HO = __toESM(require("../Handoff.js"));
var SER = __toESM(require("../SinkEndReason.js"));
var CrossRight = __toESM(require("./crossRight.js"));
var Managed = __toESM(require("./managed.js"));
var Unwrap = __toESM(require("./unwrap.js"));
const NotStartedTypeId = /* @__PURE__ */ Symbol();
class NotStarted {
  constructor() {
    this._typeId = NotStartedTypeId;
  }
}
const PreviousTypeId = /* @__PURE__ */ Symbol();
class Previous {
  constructor(fiber) {
    this.fiber = fiber;
    this._typeId = PreviousTypeId;
  }
}
const CurrentTypeId = /* @__PURE__ */ Symbol();
class Current {
  constructor(fiber) {
    this.fiber = fiber;
    this._typeId = CurrentTypeId;
  }
}
function debounce_(self, d) {
  return Unwrap.unwrap(T.map_(T.bind_(T.bind_(T.do, "scope", () => T.forkScope), "handoff", () => HO.make()), ({
    handoff,
    scope
  }) => {
    const enqueue = (last) => T.map_(T.bind_(T.do, "f", () => T.forkIn_(T.as_(CL.sleep(d), last), scope)), ({
      f
    }) => consumer(new Previous(f)));
    const producer = CH.readWithCause((in_) => O.fold_(CK.last(in_), () => producer, (last) => CH.zipRight_(CH.fromEffect(HO.offer(handoff, new HO.Emit(CK.single(last)))), producer)), (cause) => CH.fromEffect(HO.offer(handoff, new HO.Halt(cause))), (_) => CH.fromEffect(HO.offer(handoff, new HO.End(new SER.UpstreamEnd()))));
    const consumer = (state) => CH.unwrap((() => {
      switch (state._typeId) {
        case NotStartedTypeId:
          return T.map_(HO.take(handoff), (sig) => {
            switch (sig._typeId) {
              case HO.EmitTypeId:
                return CH.unwrap(enqueue(sig.els));
              case HO.HaltTypeId:
                return CH.failCause(sig.error);
              case HO.EndTypeId:
                return CH.unit;
            }
          });
        case CurrentTypeId:
          return T.map_(F.join(state.fiber), (sig) => {
            switch (sig._typeId) {
              case HO.EmitTypeId:
                return CH.unwrap(enqueue(sig.els));
              case HO.HaltTypeId:
                return CH.failCause(sig.error);
              case HO.EndTypeId:
                return CH.unit;
            }
          });
        case PreviousTypeId:
          return T.raceWith_(F.join(state.fiber), HO.take(handoff), (ex, current) => {
            if (Ex.succeeded(ex)) {
              return T.succeed(CH.zipRight_(CH.write(ex.value), consumer(new Current(current))));
            } else {
              return T.as_(F.interrupt(current), CH.failCause(ex.cause));
            }
          }, (ex, previous) => {
            if (Ex.succeeded(ex)) {
              const sig = ex.value;
              switch (sig._typeId) {
                case HO.EmitTypeId:
                  return T.zipRight_(F.interrupt(previous), enqueue(sig.els));
                case HO.HaltTypeId:
                  return T.as_(F.interrupt(previous), CH.failCause(sig.error));
                case HO.EndTypeId:
                  return T.map_(F.join(previous), (_) => CH.zipRight_(CH.write(_), CH.unit));
              }
            } else {
              return T.as_(F.interrupt(previous), CH.failCause(ex.cause));
            }
          });
      }
    })());
    return CrossRight.crossRight_(Managed.managed(M.fork(CH.runManaged(self.channel[">>>"](producer)))), new C.Stream(consumer(new NotStarted())));
  }));
}
function debounce(d) {
  return (self) => debounce_(self, d);
}
module.exports = __toCommonJS(debounce_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  debounce,
  debounce_
});
