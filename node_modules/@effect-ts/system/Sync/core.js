var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  access: () => access,
  accessM: () => accessM,
  bimap: () => bimap,
  bimap_: () => bimap_,
  catchAll: () => catchAll,
  catchAll_: () => catchAll_,
  chain: () => chain,
  chain_: () => chain_,
  either: () => either,
  environment: () => environment,
  fail: () => fail,
  fold: () => fold,
  foldM: () => foldM,
  foldM_: () => foldM_,
  fold_: () => fold_,
  map: () => map,
  mapError: () => mapError,
  mapError_: () => mapError_,
  map_: () => map_,
  orElseEither: () => orElseEither,
  orElseEither_: () => orElseEither_,
  provide: () => provide,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  provideSome: () => provideSome,
  run: () => run,
  runEither: () => runEither,
  runEitherEnv: () => runEitherEnv,
  succeed: () => succeed,
  succeedWith: () => succeedWith,
  suspend: () => suspend,
  tap: () => tap,
  tap_: () => tap_,
  tryCatch: () => tryCatch,
  union: () => union,
  unionFn: () => unionFn,
  unit: () => unit,
  zip: () => zip,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var import_Function = require("../Function/index.js");
var X = __toESM(require("../XPure/index.js"));
const chain = X.chain;
const chain_ = X.chain_;
const tap = X.tap;
const tap_ = X.tap_;
const succeed = (a) => X.succeed(a);
const fail = X.fail;
const map_ = X.map_;
const map = X.map;
const foldM_ = X.foldM_;
const foldM = X.foldM;
const fold = X.fold;
const fold_ = X.fold_;
const catchAll = X.catchAll;
const catchAll_ = X.catchAll_;
const bimap = X.bimap;
const bimap_ = X.bimap_;
const mapError = X.mapError;
const mapError_ = X.mapError_;
const unit = /* @__PURE__ */ succeed(void 0);
const provideSome = X.provideSome;
const provide = X.provide;
const provideAll = X.provideAll;
const provideAll_ = X.provideAll_;
const accessM = X.accessM;
const access = X.access;
const environment = () => X.environment();
const either = X.either;
const orElseEither = X.orElseEither;
const orElseEither_ = X.orElseEither_;
const zipWith = X.zipWith;
const zipWith_ = X.zipWith_;
const zip = X.zip;
const zip_ = X.zip_;
const suspend = X.suspend;
const succeedWith = X.succeedWith;
const tryCatch = X.tryCatch;
const runEither = X.runEither;
const runEitherEnv = (r) => (x) => runEither(provideAll(r)(x));
const run = X.run;
function unionFn(_) {
  return _;
}
function union(_) {
  return _;
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  access,
  accessM,
  bimap,
  bimap_,
  catchAll,
  catchAll_,
  chain,
  chain_,
  either,
  environment,
  fail,
  fold,
  foldM,
  foldM_,
  fold_,
  map,
  mapError,
  mapError_,
  map_,
  orElseEither,
  orElseEither_,
  provide,
  provideAll,
  provideAll_,
  provideSome,
  run,
  runEither,
  runEitherEnv,
  succeed,
  succeedWith,
  suspend,
  tap,
  tap_,
  tryCatch,
  union,
  unionFn,
  unit,
  zip,
  zipWith,
  zipWith_,
  zip_
});
