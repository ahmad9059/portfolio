var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Iterable_exports = {};
__export(Iterable_exports, {
  ap: () => ap,
  chain: () => chain,
  chain_: () => chain_,
  concat: () => concat,
  corresponds: () => corresponds,
  flatten: () => flatten,
  foldMap: () => foldMap,
  map: () => map,
  map_: () => map_,
  never: () => never,
  of: () => of,
  partitionMap: () => partitionMap,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRight_: () => reduceRight_,
  reduce_: () => reduce_,
  skip_: () => skip_,
  take_: () => take_,
  unfold: () => unfold,
  zip: () => zip,
  zipWith: () => zipWith,
  zip_: () => zip_
});
var import_Operator = require("../Operator/index.js");
var A = __toESM(require("../Collections/Immutable/Array/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var import_Function = require("../Function/index.js");
function* genOf(a) {
  yield a;
}
function* genMap(iterator, mapping) {
  let n = -1;
  while (true) {
    const result = iterator.next();
    if (result.done) {
      break;
    }
    n += 1;
    yield mapping(result.value, n);
  }
}
function* genChain(iterator, mapping) {
  while (true) {
    const result = iterator.next();
    if (result.done) {
      break;
    }
    const ib = mapping(result.value)[Symbol.iterator]();
    while (true) {
      const result2 = ib.next();
      if (result2.done) {
        break;
      }
      yield result2.value;
    }
  }
}
function zipWith(iterableA, iterableB, zipper) {
  return {
    [Symbol.iterator]() {
      let done = false;
      const ia = iterableA[Symbol.iterator]();
      const ib = iterableB[Symbol.iterator]();
      return {
        next() {
          if (done) {
            return this.return();
          }
          const va = ia.next();
          const vb = ib.next();
          return va.done || vb.done ? this.return() : {
            done: false,
            value: zipper(va.value, vb.value)
          };
        },
        return(value) {
          if (!done) {
            done = true;
            if (typeof ia.return === "function") {
              ia.return();
            }
            if (typeof ib.return === "function") {
              ib.return();
            }
          }
          return {
            done: true,
            value
          };
        }
      };
    }
  };
}
function map(f) {
  return (i) => ({
    [Symbol.iterator]: () => genMap(i[Symbol.iterator](), f)
  });
}
function map_(i, f) {
  return {
    [Symbol.iterator]: () => genMap(i[Symbol.iterator](), f)
  };
}
function zip(fb) {
  return (fa) => zipWith(fa, fb, Tp.tuple);
}
function zip_(fa, fb) {
  return zipWith(fa, fb, Tp.tuple);
}
function chain(f) {
  return (i) => ({
    [Symbol.iterator]: () => genChain(i[Symbol.iterator](), f)
  });
}
function chain_(i, f) {
  return {
    [Symbol.iterator]: () => genChain(i[Symbol.iterator](), f)
  };
}
function ap(fa) {
  return (fab) => chain_(fab, (f) => map_(fa, f));
}
function of(a) {
  return {
    [Symbol.iterator]: () => genOf(a)
  };
}
function take_(a, n) {
  return {
    *[Symbol.iterator]() {
      let i = 0;
      for (const x of a) {
        if (i++ >= n) {
          return;
        }
        yield x;
      }
    }
  };
}
function skip_(a, n) {
  return {
    *[Symbol.iterator]() {
      let i = 0;
      for (const x of a) {
        if (i++ >= n) {
          yield x;
        }
      }
    }
  };
}
const never = {
  *[Symbol.iterator]() {
  }
};
function foldMap(M) {
  return (f) => (fa) => {
    let res = M.empty;
    let n = -1;
    const iterator = fa[Symbol.iterator]();
    while (true) {
      const result = iterator.next();
      if (result.done) {
        break;
      }
      n += 1;
      res = M.concat(res, f(result.value, n));
    }
    return res;
  };
}
function reduce(b, f) {
  return (fa) => reduce_(fa, b, f);
}
function reduce_(fa, b, f) {
  let res = b;
  let n = -1;
  const iterator = fa[Symbol.iterator]();
  while (true) {
    const result = iterator.next();
    if (result.done) {
      break;
    }
    n += 1;
    res = f(res, result.value, n);
  }
  return res;
}
function reduceRight(b, f) {
  return (fa) => {
    return A.reduceRightWithIndex_(Array.from(fa), b, (i, a, b2) => f(a, b2, i));
  };
}
function reduceRight_(fa, b, f) {
  return A.reduceRightWithIndex_(Array.from(fa), b, (i, a, b2) => f(a, b2, i));
}
function concat(a, b) {
  return {
    *[Symbol.iterator]() {
      for (const x of a) {
        yield x;
      }
      for (const x of b) {
        yield x;
      }
    }
  };
}
function flatten(a) {
  return chain_(a, import_Function.identity);
}
function partitionMap(f) {
  return (as) => A.separate(Array.from(map_(as, f)));
}
function unfold(a, f) {
  return {
    *[Symbol.iterator]() {
      yield a;
      let current = a;
      while (true) {
        current = f(a);
        yield current;
      }
    }
  };
}
function corresponds(left, right, f) {
  const leftIt = left[Symbol.iterator]();
  const rightIt = right[Symbol.iterator]();
  while (1) {
    const lnext = leftIt.next();
    const rnext = rightIt.next();
    if (lnext.done !== rnext.done) {
      return false;
    }
    if (lnext.done) {
      return true;
    }
    if (!f(lnext.value, rnext.value)) {
      return false;
    }
  }
  throw new Error("Bug");
}
module.exports = __toCommonJS(Iterable_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ap,
  chain,
  chain_,
  concat,
  corresponds,
  flatten,
  foldMap,
  map,
  map_,
  never,
  of,
  partitionMap,
  reduce,
  reduceRight,
  reduceRight_,
  reduce_,
  skip_,
  take_,
  unfold,
  zip,
  zipWith,
  zip_
});
