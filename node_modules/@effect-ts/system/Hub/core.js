var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  HubTypeId: () => HubTypeId,
  XHubInternal: () => XHubInternal,
  awaitShutdown: () => awaitShutdown,
  capacity: () => capacity,
  concrete: () => concrete,
  contramapM: () => contramapM,
  contramapM_: () => contramapM_,
  dimap: () => dimap,
  dimapM: () => dimapM,
  dimapM_: () => dimapM_,
  dimap_: () => dimap_,
  filterInput: () => filterInput,
  filterInputM: () => filterInputM,
  filterInputM_: () => filterInputM_,
  filterInput_: () => filterInput_,
  filterOutput: () => filterOutput,
  filterOutputM: () => filterOutputM,
  filterOutputM_: () => filterOutputM_,
  filterOutput_: () => filterOutput_,
  isShutdown: () => isShutdown,
  makeBounded: () => makeBounded,
  makeDropping: () => makeDropping,
  makeSliding: () => makeSliding,
  makeUnbounded: () => makeUnbounded,
  map: () => map,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  publish: () => publish,
  publishAll: () => publishAll,
  publishAll_: () => publishAll_,
  publish_: () => publish_,
  shutdown: () => shutdown,
  size: () => size,
  subscribe: () => subscribe,
  toQueue: () => toQueue,
  unsafeMakeBounded: () => unsafeMakeBounded,
  unsafeMakeDropping: () => unsafeMakeDropping,
  unsafeMakeSliding: () => unsafeMakeSliding,
  unsafeMakeUnbounded: () => unsafeMakeUnbounded
});
var import_Operator = require("../Operator/index.js");
var AR = __toESM(require("../Collections/Immutable/Array/index.js"));
var Chunk = __toESM(require("../Collections/Immutable/Chunk/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var HS = __toESM(require("../Collections/Mutable/HashSet/index.js"));
var ES = __toESM(require("../Effect/ExecutionStrategy.js"));
var T = __toESM(require("../Effect/index.js"));
var Ex = __toESM(require("../Exit/index.js"));
var F = __toESM(require("../Fiber/index.js"));
var import_Function = require("../Function/index.js");
var M = __toESM(require("../Managed/index.js"));
var RM = __toESM(require("../Managed/ReleaseMap/index.js"));
var P = __toESM(require("../Promise/index.js"));
var Q = __toESM(require("../Queue/index.js"));
var import_Queue = require("../Queue/index.js");
var Ref = __toESM(require("../Ref/index.js"));
var AB = __toESM(require("../Support/AtomicBoolean/index.js"));
var MQ = __toESM(require("../Support/MutableQueue/index.js"));
var HF = __toESM(require("./_internal/hubFactory.js"));
var U = __toESM(require("./_internal/unsafe.js"));
var PR = __toESM(require("./primitives.js"));
var S = __toESM(require("./Strategy.js"));
const HubTypeId = /* @__PURE__ */ Symbol();
class XHubInternal {
  constructor() {
    this.typeId = HubTypeId;
  }
}
PR._RA, PR._RB, PR._EA, PR._EB, PR._A, PR._B;
function concrete(_) {
}
function awaitShutdown(self) {
  ;
  return self.awaitShutdown;
}
function capacity(self) {
  ;
  return self.capacity;
}
function isShutdown(self) {
  ;
  return self.isShutdown;
}
function publish_(self, a) {
  ;
  return self.publish(a);
}
function publish(a) {
  return (self) => publish_(self, a);
}
function publishAll_(self, as) {
  ;
  return self.publishAll(as);
}
function publishAll(as) {
  return (self) => publishAll_(self, as);
}
function shutdown(self) {
  ;
  return self.shutdown;
}
function size(self) {
  ;
  return self.size;
}
function subscribe(self) {
  ;
  return self.subscribe;
}
function contramapM_(self, f) {
  return dimapM_(self, f, T.succeed);
}
function contramapM(f) {
  return (self) => contramapM_(self, f);
}
function dimap_(self, f, g) {
  return dimapM_(self, (c) => T.succeed(f(c)), (b) => T.succeed(g(b)));
}
function dimap(f, g) {
  return (self) => dimap_(self, f, g);
}
class DimapMImplementation extends XHubInternal {
  constructor(source, f, g) {
    super();
    this.source = source;
    this.f = f;
    this.awaitShutdown = source.awaitShutdown;
    this.capacity = source.capacity;
    this.isShutdown = source.isShutdown;
    this.shutdown = source.shutdown;
    this.size = source.size;
    this.subscribe = M.map_(source.subscribe, Q.mapM(g));
  }
  publish(c) {
    return T.chain_(this.f(c), (a) => this.source.publish(a));
  }
  publishAll(cs) {
    return T.chain_(T.forEach_(cs, this.f), (as) => this.source.publishAll(as));
  }
}
function dimapM_(self, f, g) {
  ;
  return new DimapMImplementation(self, f, g);
}
function dimapM(f, g) {
  return (self) => dimapM_(self, f, g);
}
class filterInputMImplementation extends XHubInternal {
  constructor(source, f) {
    super();
    this.source = source;
    this.f = f;
    this.awaitShutdown = source.awaitShutdown;
    this.capacity = source.capacity;
    this.isShutdown = source.isShutdown;
    this.shutdown = source.shutdown;
    this.size = source.size;
    this.subscribe = source.subscribe;
  }
  publish(a) {
    return T.chain_(this.f(a), (b) => b ? this.source.publish(a) : T.succeed(false));
  }
  publishAll(as) {
    return T.chain_(T.filter_(as, this.f), (as2) => AR.isNonEmpty(as2) ? this.source.publishAll(as2) : T.succeed(false));
  }
}
function filterInput_(self, f) {
  return filterInputM_(self, (a) => T.succeed(f(a)));
}
function filterInput(f) {
  return (self) => filterInput_(self, f);
}
function filterInputM_(self, f) {
  ;
  return new filterInputMImplementation(self, f);
}
function filterInputM(f) {
  return (self) => filterInputM_(self, f);
}
function filterOutput_(self, f) {
  return filterOutputM_(self, (b) => T.succeed(f(b)));
}
function filterOutput(f) {
  return (self) => filterOutput_(self, f);
}
class filterOutputMImplementation extends XHubInternal {
  constructor(source, f) {
    super();
    this.source = source;
    this.f = f;
    this.awaitShutdown = source.awaitShutdown;
    this.capacity = source.capacity;
    this.isShutdown = source.isShutdown;
    this.shutdown = source.shutdown;
    this.size = source.size;
    this.subscribe = M.map_(source.subscribe, Q.filterOutputM(f));
  }
  publish(a) {
    return this.source.publish(a);
  }
  publishAll(as) {
    return this.source.publishAll(as);
  }
}
function filterOutputM_(self, f) {
  ;
  return new filterOutputMImplementation(self, f);
}
function filterOutputM(f) {
  return (self) => filterOutputM_(self, f);
}
function map_(self, f) {
  return mapM_(self, (b) => T.succeed(f(b)));
}
function map(f) {
  return (self) => map_(self, f);
}
function mapM_(self, f) {
  return dimapM_(self, (a) => T.succeed(a), f);
}
function mapM(f) {
  return (self) => mapM_(self, f);
}
class ToQueueImplementation extends import_Queue.XQueueInternal {
  constructor(source) {
    super();
    this.source = source;
    this.awaitShutdown = source.awaitShutdown;
    this.capacity = source.capacity;
    this.isShutdown = source.isShutdown;
    this.shutdown = source.shutdown;
    this.size = source.size;
    this.take = T.never;
    this.takeAll = T.succeed(Chunk.empty());
  }
  offer(a) {
    return this.source.publish(a);
  }
  offerAll(as) {
    return this.source.publishAll(as);
  }
  takeUpTo() {
    return T.succeed(Chunk.empty());
  }
}
function toQueue(self) {
  ;
  return new ToQueueImplementation(self);
}
function makeBounded(requestedCapacity) {
  return T.chain_(T.succeedWith(() => HF.makeBounded(requestedCapacity)), (_) => makeHub(_, new S.BackPressure()));
}
function unsafeMakeBounded(requestedCapacity) {
  const releaseMap = new RM.ReleaseMap(Ref.unsafeMakeRef(new RM.Running(0, /* @__PURE__ */ new Map())));
  return unsafeMakeHub(HF.makeBounded(requestedCapacity), makeSubscribersHashSet(), releaseMap, P.unsafeMake(F.None), new AB.AtomicBoolean(false), new S.BackPressure());
}
function makeDropping(requestedCapacity) {
  return T.chain_(T.succeedWith(() => {
    return HF.makeBounded(requestedCapacity);
  }), (_) => makeHub(_, new S.Dropping()));
}
function unsafeMakeDropping(requestedCapacity) {
  const releaseMap = new RM.ReleaseMap(Ref.unsafeMakeRef(new RM.Running(0, /* @__PURE__ */ new Map())));
  return unsafeMakeHub(HF.makeBounded(requestedCapacity), makeSubscribersHashSet(), releaseMap, P.unsafeMake(F.None), new AB.AtomicBoolean(false), new S.Dropping());
}
function makeSliding(requestedCapacity) {
  return T.chain_(T.succeedWith(() => {
    return HF.makeBounded(requestedCapacity);
  }), (_) => makeHub(_, new S.Sliding()));
}
function unsafeMakeSliding(requestedCapacity) {
  const releaseMap = new RM.ReleaseMap(Ref.unsafeMakeRef(new RM.Running(0, /* @__PURE__ */ new Map())));
  return unsafeMakeHub(HF.makeBounded(requestedCapacity), makeSubscribersHashSet(), releaseMap, P.unsafeMake(F.None), new AB.AtomicBoolean(false), new S.Sliding());
}
function makeUnbounded() {
  return T.chain_(T.succeedWith(() => {
    return HF.makeUnbounded();
  }), (_) => makeHub(_, new S.Dropping()));
}
function unsafeMakeUnbounded() {
  const releaseMap = new RM.ReleaseMap(Ref.unsafeMakeRef(new RM.Running(0, /* @__PURE__ */ new Map())));
  return unsafeMakeHub(HF.makeUnbounded(), makeSubscribersHashSet(), releaseMap, P.unsafeMake(F.None), new AB.AtomicBoolean(false), new S.Dropping());
}
class UnsafeMakeHubImplementation extends XHubInternal {
  constructor(hub, subscribers, releaseMap, shutdownHook, shutdownFlag, strategy) {
    super();
    this.hub = hub;
    this.subscribers = subscribers;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.awaitShutdown = P.await(shutdownHook);
    this.capacity = hub.capacity;
    this.isShutdown = T.succeedWith(() => shutdownFlag.get);
    this.shutdown = T.uninterruptible(T.suspend((_, fiberId) => {
      shutdownFlag.set(true);
      return T.asUnit(T.whenM_(T.zipRight_(RM.releaseAll(Ex.interrupt(fiberId), ES.parallel)(releaseMap), strategy.shutdown), P.succeed_(shutdownHook, void 0)));
    }));
    this.size = T.suspend(() => {
      if (shutdownFlag.get) {
        return T.interrupt;
      }
      return T.succeed(hub.size());
    });
    this.subscribe = M.map_(M.tap_(M.bind_(M.do, "dequeue", () => T.toManaged(makeSubscription(hub, subscribers, strategy))), ({
      dequeue
    }) => M.makeExit_(RM.add((_) => Q.shutdown(dequeue))(releaseMap), (finalizer, exit) => finalizer(exit))), ({
      dequeue
    }) => dequeue);
  }
  publish(a) {
    return T.suspend(() => {
      if (this.shutdownFlag.get) {
        return T.interrupt;
      }
      if (this.hub.publish(a)) {
        this.strategy.unsafeCompleteSubscribers(this.hub, this.subscribers);
        return T.succeed(true);
      }
      return this.strategy.handleSurplus(this.hub, this.subscribers, Chunk.single(a), this.shutdownFlag);
    });
  }
  publishAll(as) {
    return T.suspend(() => {
      if (this.shutdownFlag.get) {
        return T.interrupt;
      }
      const surplus = U.unsafePublishAll(this.hub, as);
      this.strategy.unsafeCompleteSubscribers(this.hub, this.subscribers);
      if (Chunk.isEmpty(surplus)) {
        return T.succeed(true);
      }
      return this.strategy.handleSurplus(this.hub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
}
function makeHub(hub, strategy) {
  return T.chain_(RM.makeReleaseMap, (releaseMap) => {
    return T.map_(P.make(), (promise) => {
      return unsafeMakeHub(hub, makeSubscribersHashSet(), releaseMap, promise, new AB.AtomicBoolean(false), strategy);
    });
  });
}
function unsafeMakeHub(hub, subscribers, releaseMap, shutdownHook, shutdownFlag, strategy) {
  return new UnsafeMakeHubImplementation(hub, subscribers, releaseMap, shutdownHook, shutdownFlag, strategy);
}
function makeSubscription(hub, subscribers, strategy) {
  return T.map_(P.make(), (promise) => {
    return unsafeMakeSubscription(hub, subscribers, hub.subscribe(), new MQ.Unbounded(), promise, new AB.AtomicBoolean(false), strategy);
  });
}
class UnsafeMakeSubscriptionImplementation extends import_Queue.XQueueInternal {
  constructor(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.hub = hub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.awaitShutdown = P.await(this.shutdownHook);
    this.capacity = this.hub.capacity;
    this.isShutdown = T.succeedWith(() => this.shutdownFlag.get);
    this.shutdown = T.uninterruptible(T.suspend((_, fiberId) => {
      this.shutdownFlag.set(true);
      return T.asUnit(T.whenM_(T.zipRight_(T.forEachPar_(U.unsafePollAllQueue(this.pollers), (_2) => {
        return P.interruptAs(fiberId)(_2);
      }), T.succeedWith(() => this.subscription.unsubscribe())), P.succeed_(this.shutdownHook, void 0)));
    }));
    this.size = T.suspend(() => {
      if (this.shutdownFlag.get) {
        return T.interrupt;
      }
      return T.succeed(this.subscription.size());
    });
    this.take = T.suspend((_, fiberId) => {
      if (this.shutdownFlag.get) {
        return T.interrupt;
      }
      const empty = null;
      const message = this.pollers.isEmpty ? this.subscription.poll(empty) : empty;
      if (message === null) {
        const promise = P.unsafeMake(fiberId);
        return T.onInterrupt_(T.suspend(() => {
          this.pollers.offer(promise);
          this.subscribers.add(Tp.tuple(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.hub, this.subscribers, this.subscription, this.pollers);
          if (this.shutdownFlag.get) {
            return T.interrupt;
          } else {
            return P.await(promise);
          }
        }), () => T.succeedWith(() => {
          U.unsafeRemove(this.pollers, promise);
        }));
      } else {
        this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);
        return T.succeed(message);
      }
    });
    this.takeAll = T.suspend(() => {
      if (this.shutdownFlag.get) {
        return T.interrupt;
      }
      const as = this.pollers.isEmpty ? U.unsafePollAllSubscription(this.subscription) : Chunk.empty();
      this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);
      return T.succeed(as);
    });
  }
  offer(_) {
    return T.succeed(false);
  }
  offerAll(_) {
    return T.succeed(false);
  }
  takeUpTo(n) {
    return T.suspend(() => {
      if (this.shutdownFlag.get) {
        return T.interrupt;
      }
      const as = this.pollers.isEmpty ? U.unsafePollN(this.subscription, n) : Chunk.empty();
      this.strategy.unsafeOnHubEmptySpace(this.hub, this.subscribers);
      return T.succeed(as);
    });
  }
}
function unsafeMakeSubscription(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) {
  return new UnsafeMakeSubscriptionImplementation(hub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy);
}
function makeSubscribersHashSet() {
  return HS.make();
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HubTypeId,
  XHubInternal,
  awaitShutdown,
  capacity,
  concrete,
  contramapM,
  contramapM_,
  dimap,
  dimapM,
  dimapM_,
  dimap_,
  filterInput,
  filterInputM,
  filterInputM_,
  filterInput_,
  filterOutput,
  filterOutputM,
  filterOutputM_,
  filterOutput_,
  isShutdown,
  makeBounded,
  makeDropping,
  makeSliding,
  makeUnbounded,
  map,
  mapM,
  mapM_,
  map_,
  publish,
  publishAll,
  publishAll_,
  publish_,
  shutdown,
  size,
  subscribe,
  toQueue,
  unsafeMakeBounded,
  unsafeMakeDropping,
  unsafeMakeSliding,
  unsafeMakeUnbounded
});
