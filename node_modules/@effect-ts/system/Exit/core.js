var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  Failure: () => import_exit2.Failure,
  Success: () => import_exit2.Success,
  ap: () => ap,
  ap_: () => ap_,
  as: () => as,
  as_: () => as_,
  assertsFailure: () => assertsFailure,
  bimap: () => bimap,
  bimap_: () => bimap_,
  chain: () => chain,
  chain_: () => chain_,
  collectAll: () => collectAll,
  collectAllPar: () => collectAllPar,
  die: () => die,
  exists: () => exists,
  exists_: () => exists_,
  fail: () => fail,
  failCause: () => failCause,
  flatten: () => flatten,
  fold: () => fold,
  fold_: () => fold_,
  fromEither: () => fromEither,
  fromOption: () => fromOption,
  getOrElse: () => getOrElse,
  getOrElse_: () => getOrElse_,
  halt: () => halt,
  interrupt: () => interrupt,
  interrupted: () => interrupted,
  map: () => map,
  mapBoth: () => mapBoth,
  mapBoth_: () => mapBoth_,
  mapError: () => mapError,
  mapErrorCause: () => mapErrorCause,
  mapErrorCause_: () => mapErrorCause_,
  mapError_: () => mapError_,
  map_: () => map_,
  orElseFail: () => orElseFail,
  orElseFail_: () => orElseFail_,
  succeed: () => succeed,
  succeeded: () => succeeded,
  toEither: () => toEither,
  unit: () => unit,
  untraced: () => untraced,
  zip: () => zip,
  zipLeft: () => zipLeft,
  zipLeft_: () => zipLeft_,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParLeft_: () => zipParLeft_,
  zipParRight: () => zipParRight,
  zipParRight_: () => zipParRight_,
  zipPar_: () => zipPar_,
  zipRight: () => zipRight,
  zipRight_: () => zipRight_,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var C = __toESM(require("../Cause/core.js"));
var import_errors = require("../Cause/errors.js");
var A = __toESM(require("../Collections/Immutable/Array/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var O = __toESM(require("../Option/index.js"));
var import_exit = require("./exit.js");
var import_exit2 = require("./exit.js");
function ap_(fa, fab) {
  return chain_(fab, (f) => map_(fa, (a) => f(a)));
}
function ap(fa) {
  return (fab) => ap_(fa, fab);
}
function as_(exit, b) {
  return map_(exit, () => b);
}
function as(b) {
  return (exit) => as_(exit, b);
}
function bimap_(exit, f, g) {
  return mapError(f)(map(g)(exit));
}
function bimap(f, g) {
  return (exit) => bimap_(exit, f, g);
}
function chain_(exit, f) {
  switch (exit._tag) {
    case "Failure": {
      return exit;
    }
    case "Success": {
      return f(exit.value);
    }
  }
}
function chain(f) {
  return (exit) => chain_(exit, f);
}
function collectAll(...exits) {
  return O.map_(A.head(exits), (head) => map(A.reverse)(A.reduce_(A.drop_(exits, 1), map((x) => [x])(head), (acc, el) => zipWith(el, (acc2, el2) => [el2, ...acc2], C.then)(acc))));
}
function zipWith_(exit, that, f, g) {
  switch (exit._tag) {
    case "Failure": {
      switch (that._tag) {
        case "Success": {
          return exit;
        }
        case "Failure": {
          return halt(g(exit.cause, that.cause));
        }
      }
    }
    case "Success": {
      switch (that._tag) {
        case "Success": {
          return succeed(f(exit.value, that.value));
        }
        case "Failure": {
          return that;
        }
      }
    }
  }
}
function zipWith(that, f, g) {
  return (exit) => zipWith_(exit, that, f, g);
}
function collectAllPar(...exits) {
  return O.map_(A.head(exits), (head) => map(A.reverse)(A.reduce_(A.drop_(exits, 1), map((x) => [x])(head), (acc, el) => zipWith(el, (acc2, el2) => [el2, ...acc2], C.both)(acc))));
}
function die(error) {
  return halt(C.die(error));
}
function exists_(exit, f) {
  return fold(() => false, f)(exit);
}
function exists(f) {
  return (exit) => exists_(exit, f);
}
function fail(e) {
  return halt(C.fail(e));
}
function failCause(cause) {
  return new import_exit.Failure(cause);
}
function flatten(exit) {
  return chain(import_Function.identity)(exit);
}
function fold_(exit, failed, succeed2) {
  switch (exit._tag) {
    case "Success": {
      return succeed2(exit.value);
    }
    case "Failure": {
      return failed(exit.cause);
    }
  }
}
function fold(failed, succeed2) {
  return (exit) => fold_(exit, failed, succeed2);
}
function fromEither(e) {
  return e._tag === "Left" ? fail(e.left) : succeed(e.right);
}
function fromOption(onNone) {
  return (a) => a._tag === "None" ? fail(onNone()) : succeed(a.value);
}
function getOrElse_(exit, orElse) {
  switch (exit._tag) {
    case "Success": {
      return exit.value;
    }
    case "Failure": {
      return orElse(exit.cause);
    }
  }
}
function getOrElse(orElse) {
  return (exit) => getOrElse_(exit, orElse);
}
function halt(cause) {
  return new import_exit.Failure(cause);
}
function interrupt(id) {
  return halt(C.interrupt(id));
}
function interrupted(exit) {
  switch (exit._tag) {
    case "Success": {
      return false;
    }
    case "Failure": {
      return C.interrupted(exit.cause);
    }
  }
}
function map_(exit, f) {
  return chain((a) => succeed(f(a)))(exit);
}
function map(f) {
  return (exit) => map_(exit, f);
}
function mapError_(exit, f) {
  switch (exit._tag) {
    case "Failure": {
      return halt(C.map(f)(exit.cause));
    }
    case "Success": {
      return exit;
    }
  }
}
function mapError(f) {
  return (exit) => mapError_(exit, f);
}
function mapErrorCause_(exit, f) {
  switch (exit._tag) {
    case "Failure": {
      return halt(f(exit.cause));
    }
    case "Success": {
      return exit;
    }
  }
}
function mapErrorCause(f) {
  return (exit) => mapErrorCause_(exit, f);
}
function orElseFail_(exit, e) {
  return mapError(() => e)(exit);
}
function orElseFail(e) {
  return (exit) => orElseFail_(exit, e);
}
function succeed(a) {
  return new import_exit.Success(a);
}
function succeeded(exit) {
  switch (exit._tag) {
    case "Failure": {
      return false;
    }
    case "Success": {
      return true;
    }
  }
}
function toEither(exit) {
  switch (exit._tag) {
    case "Success": {
      return E.right(exit.value);
    }
    case "Failure": {
      return E.left(new import_errors.FiberFailure(exit.cause));
    }
  }
}
const unit = /* @__PURE__ */ succeed(void 0);
function zip_(exit, that) {
  return zipWith(that, (a, b) => Tp.tuple(a, b), C.then)(exit);
}
function zip(that) {
  return (exit) => zip_(exit, that);
}
function zipLeft_(exit, that) {
  return zipWith(that, (a, _) => a, C.then)(exit);
}
function zipLeft(that) {
  return (exit) => zipLeft_(exit, that);
}
function zipPar_(exit, that) {
  return zipWith(that, (a, b) => Tp.tuple(a, b), C.both)(exit);
}
function zipPar(that) {
  return (exit) => zipPar_(exit, that);
}
function zipParLeft_(exit, that) {
  return zipWith(that, (a, _) => a, C.both)(exit);
}
function zipParLeft(that) {
  return (exit) => zipParLeft_(exit, that);
}
function zipParRight_(exit, that) {
  return zipWith(that, (_, b) => b, C.both)(exit);
}
function zipParRight(that) {
  return (exit) => zipParRight_(exit, that);
}
function zipRight_(exit, that) {
  return zipWith(that, (_, b) => b, C.then)(exit);
}
function zipRight(that) {
  return (exit) => zipRight_(exit, that);
}
function untraced(self) {
  return self._tag === "Success" ? self : halt(C.untraced(self.cause));
}
function assertsFailure(exit) {
  if (exit._tag === "Success") {
    throw new Error("expected a failed exit and got success");
  }
}
function mapBoth_(self, f, g) {
  return map_(mapError_(self, f), g);
}
function mapBoth(f, g) {
  return (self) => mapBoth_(self, f, g);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Failure,
  Success,
  ap,
  ap_,
  as,
  as_,
  assertsFailure,
  bimap,
  bimap_,
  chain,
  chain_,
  collectAll,
  collectAllPar,
  die,
  exists,
  exists_,
  fail,
  failCause,
  flatten,
  fold,
  fold_,
  fromEither,
  fromOption,
  getOrElse,
  getOrElse_,
  halt,
  interrupt,
  interrupted,
  map,
  mapBoth,
  mapBoth_,
  mapError,
  mapErrorCause,
  mapErrorCause_,
  mapError_,
  map_,
  orElseFail,
  orElseFail_,
  succeed,
  succeeded,
  toEither,
  unit,
  untraced,
  zip,
  zipLeft,
  zipLeft_,
  zipPar,
  zipParLeft,
  zipParLeft_,
  zipParRight,
  zipParRight_,
  zipPar_,
  zipRight,
  zipRight_,
  zipWith,
  zipWith_,
  zip_
});
