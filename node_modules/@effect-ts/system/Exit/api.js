var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var api_exports = {};
__export(api_exports, {
  Failure: () => import_core.Failure,
  Success: () => import_core.Success,
  ap: () => import_core.ap,
  as: () => import_core.as,
  bimap: () => import_core.bimap,
  chain: () => import_core.chain,
  chain_: () => import_core.chain_,
  collectAll: () => import_core.collectAll,
  collectAllPar: () => import_core.collectAllPar,
  die: () => import_core.die,
  exists: () => import_core.exists,
  fail: () => import_core.fail,
  flatten: () => import_core.flatten,
  fold: () => import_core.fold,
  foldM: () => foldM,
  foldM_: () => foldM_,
  fold_: () => import_core.fold_,
  forEach: () => forEach,
  forEach_: () => forEach_,
  fromEither: () => import_core.fromEither,
  fromOption: () => import_core.fromOption,
  getOrElse: () => import_core.getOrElse,
  halt: () => import_core.halt,
  interrupt: () => import_core.interrupt,
  interrupted: () => import_core.interrupted,
  map: () => import_core.map,
  mapError: () => import_core.mapError,
  mapErrorCause: () => import_core.mapErrorCause,
  map_: () => import_core.map_,
  orElseFail: () => import_core.orElseFail,
  succeed: () => import_core.succeed,
  succeeded: () => import_core.succeeded,
  toEither: () => import_core.toEither,
  unit: () => import_core.unit,
  zip: () => import_core.zip,
  zipLeft: () => import_core.zipLeft,
  zipPar: () => import_core.zipPar,
  zipParLeft: () => import_core.zipParLeft,
  zipParRight: () => import_core.zipParRight,
  zipRight: () => import_core.zipRight,
  zipRight_: () => import_core.zipRight_,
  zipWith: () => import_core.zipWith,
  zipWith_: () => import_core.zipWith_
});
var T = __toESM(require("./_internal/effect.js"));
var Exit = __toESM(require("./core.js"));
var import_core = require("./core.js");
function foldM(failed, succeed2) {
  return (exit) => foldM_(exit, failed, succeed2);
}
function foldM_(exit, failed, succeed2) {
  switch (exit._tag) {
    case "Success": {
      return succeed2(exit.value);
    }
    case "Failure": {
      return failed(exit.cause);
    }
  }
}
function forEach(f) {
  return (exit) => forEach_(exit, f);
}
function forEach_(exit, f) {
  switch (exit._tag) {
    case "Failure": {
      return T.succeed(Exit.halt(exit.cause));
    }
    case "Success": {
      return T.result(f(exit.value));
    }
  }
}
module.exports = __toCommonJS(api_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Failure,
  Success,
  ap,
  as,
  bimap,
  chain,
  chain_,
  collectAll,
  collectAllPar,
  die,
  exists,
  fail,
  flatten,
  fold,
  foldM,
  foldM_,
  fold_,
  forEach,
  forEach_,
  fromEither,
  fromOption,
  getOrElse,
  halt,
  interrupt,
  interrupted,
  map,
  mapError,
  mapErrorCause,
  map_,
  orElseFail,
  succeed,
  succeeded,
  toEither,
  unit,
  zip,
  zipLeft,
  zipPar,
  zipParLeft,
  zipParRight,
  zipRight,
  zipRight_,
  zipWith,
  zipWith_
});
