var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Pretty_exports = {};
__export(Pretty_exports, {
  Failure: () => Failure,
  Parallel: () => Parallel,
  Sequential: () => Sequential,
  causeToSequential: () => causeToSequential,
  defaultErrorToLines: () => defaultErrorToLines,
  defaultRenderer: () => defaultRenderer,
  format: () => format,
  headTail: () => headTail,
  linearSegments: () => linearSegments,
  lines: () => lines,
  parallelSegments: () => parallelSegments,
  prefixBlock: () => prefixBlock,
  pretty: () => pretty,
  prettyLines: () => prettyLines,
  prettyM: () => prettyM,
  renderDie: () => renderDie,
  renderError: () => renderError,
  renderFail: () => renderFail,
  renderInterrupt: () => renderInterrupt,
  renderToString: () => renderToString,
  renderTrace: () => renderTrace,
  times: () => times
});
var A = __toESM(require("../../Collections/Immutable/Array/index.js"));
var import_tracing = require("../../Fiber/tracing.js");
var import_Function = require("../../Function/index.js");
var S = __toESM(require("../../IO/index.js"));
var O = __toESM(require("../../Option/index.js"));
function Failure(lines2) {
  return {
    _tag: "Failure",
    lines: lines2
  };
}
function Sequential(all) {
  return {
    _tag: "Sequential",
    all
  };
}
function Parallel(all) {
  return {
    _tag: "Parallel",
    all
  };
}
function headTail(a) {
  const x = [...a];
  const head = x.shift();
  return [head, x];
}
function prefixBlock(values, p1, p2) {
  return A.isNonEmpty(values) ? (([head, tail]) => [`${p1}${head}`, ...tail.map((_) => `${p2}${_}`)])(headTail(values)) : [];
}
function renderInterrupt(fiberId, trace, traceRenderer) {
  return Sequential([Failure([`An interrupt was produced by #${fiberId.seqNumber}.`, "", ...renderTrace(trace, traceRenderer)])]);
}
function renderError(error) {
  return lines(error.stack ? error.stack : String(error));
}
function renderDie(error, trace, traceRenderer) {
  return Sequential([Failure(["An unchecked error was produced.", "", ...error, ...renderTrace(trace, traceRenderer)])]);
}
function renderFail(error, trace, traceRenderer) {
  return Sequential([Failure(["A checked error was not handled.", "", ...error, ...renderTrace(trace, traceRenderer)])]);
}
function lines(s) {
  return s.split("\n").map((s2) => s2.replace("\r", ""));
}
function linearSegments(cause, renderer) {
  return S.gen(function* (_) {
    switch (cause._tag) {
      case "Then": {
        return [...yield* _(linearSegments(cause.left, renderer)), ...yield* _(linearSegments(cause.right, renderer))];
      }
      default: {
        return (yield* _(causeToSequential(cause, renderer))).all;
      }
    }
  });
}
function parallelSegments(cause, renderer) {
  return S.gen(function* (_) {
    switch (cause._tag) {
      case "Both": {
        return [...yield* _(parallelSegments(cause.left, renderer)), ...yield* _(parallelSegments(cause.right, renderer))];
      }
      default: {
        return [yield* _(causeToSequential(cause, renderer))];
      }
    }
  });
}
function renderToString(u) {
  if (typeof u === "object" && u != null && "toString" in u && typeof u["toString"] === "function" && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  return JSON.stringify(u, null, 2);
}
function causeToSequential(cause, renderer) {
  return S.gen(function* (_) {
    switch (cause._tag) {
      case "Empty": {
        return Sequential([]);
      }
      case "Fail": {
        return renderFail(renderer.renderError(cause.value), O.none, renderer.renderTrace);
      }
      case "Die": {
        return renderDie(renderer.renderUnknown(cause.value), O.none, renderer.renderTrace);
      }
      case "Interrupt": {
        return renderInterrupt(cause.fiberId, O.none, renderer.renderTrace);
      }
      case "Then": {
        return Sequential(yield* _(linearSegments(cause, renderer)));
      }
      case "Both": {
        return Sequential([Parallel(yield* _(parallelSegments(cause, renderer)))]);
      }
      case "Traced": {
        switch (cause.cause._tag) {
          case "Fail": {
            return renderFail(renderer.renderError(cause.cause.value), O.some(cause.trace), renderer.renderTrace);
          }
          case "Die": {
            return renderDie(renderer.renderUnknown(cause.cause.value), O.some(cause.trace), renderer.renderTrace);
          }
          case "Interrupt": {
            return renderInterrupt(cause.cause.fiberId, O.some(cause.trace), renderer.renderTrace);
          }
          default: {
            return Sequential([Failure(["An error was rethrown with a new trace.", ...renderTrace(O.some(cause.trace), renderer.renderTrace)]), ...(yield* _(causeToSequential(cause.cause, renderer))).all]);
          }
        }
      }
    }
  });
}
function renderTrace(o, renderTrace2) {
  return o._tag === "None" ? [] : lines(renderTrace2(o.value));
}
function times(s, n) {
  let h = "";
  for (let i = 0; i < n; i += 1) {
    h += s;
  }
  return h;
}
function format(segment) {
  switch (segment._tag) {
    case "Failure": {
      return prefixBlock(segment.lines, "\u2500", " ");
    }
    case "Parallel": {
      return [times("\u2550\u2550\u2566", segment.all.length - 1) + "\u2550\u2550\u2557", ...A.reduceRight_(segment.all, [], (current, acc) => [...prefixBlock(acc, "  \u2551", "  \u2551"), ...prefixBlock(format(current), "  ", "  ")])];
    }
    case "Sequential": {
      return A.chain_(segment.all, (seg) => ["\u2551", ...prefixBlock(format(seg), "\u2560", "\u2551"), "\u25BC"]);
    }
  }
}
function prettyLines(cause, renderer) {
  return S.gen(function* (_) {
    const s = yield* _(causeToSequential(cause, renderer));
    if (s.all.length === 1 && s.all[0] && s.all[0]._tag === "Failure") {
      return s.all[0].lines;
    }
    return O.getOrElse_(A.updateAt_(format(s), 0, "\u2565"), () => []);
  });
}
function prettyM(cause, renderer) {
  return S.gen(function* (_) {
    const lines2 = yield* _(prettyLines(cause, renderer));
    return `
${lines2.join("\n")}`;
  });
}
function defaultErrorToLines(error) {
  return error instanceof Error ? renderError(error) : lines(renderToString(error));
}
const defaultRenderer = {
  renderError: defaultErrorToLines,
  renderTrace: import_tracing.prettyTrace,
  renderUnknown: defaultErrorToLines
};
const pretty = (cause, renderer = defaultRenderer) => S.run(prettyM(cause, renderer));
module.exports = __toCommonJS(Pretty_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Failure,
  Parallel,
  Sequential,
  causeToSequential,
  defaultErrorToLines,
  defaultRenderer,
  format,
  headTail,
  linearSegments,
  lines,
  parallelSegments,
  prefixBlock,
  pretty,
  prettyLines,
  prettyM,
  renderDie,
  renderError,
  renderFail,
  renderInterrupt,
  renderToString,
  renderTrace,
  times
});
