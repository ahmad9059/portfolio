var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  ap: () => ap,
  as: () => as,
  both: () => import_cause2.both,
  chain: () => chain,
  chainSafe_: () => chainSafe_,
  chain_: () => chain_,
  contains: () => contains,
  containsSafe: () => containsSafe,
  defects: () => defects,
  die: () => import_cause2.die,
  dieOption: () => dieOption,
  died: () => died,
  empty: () => import_cause2.empty,
  fail: () => import_cause2.fail,
  failed: () => failed,
  failureOption: () => failureOption,
  failureOrCause: () => failureOrCause,
  failures: () => failures,
  find: () => find,
  findSafe: () => findSafe,
  flatten: () => flatten,
  flipCauseOption: () => flipCauseOption,
  fold: () => fold,
  foldSafe: () => foldSafe,
  interrupt: () => import_cause2.interrupt,
  interruptOption: () => interruptOption,
  interrupted: () => interrupted,
  interruptedOnly: () => interruptedOnly,
  interruptors: () => interruptors,
  isEmpty: () => import_cause2.isEmpty,
  keepDefects: () => keepDefects,
  keepDefectsSafe: () => keepDefectsSafe,
  map: () => map,
  map_: () => map_,
  reduceLeft: () => reduceLeft,
  sequenceCauseEither: () => sequenceCauseEither,
  sequenceCauseEitherSafe: () => sequenceCauseEitherSafe,
  sequenceCauseOption: () => sequenceCauseOption,
  sequenceCauseOptionSafe: () => sequenceCauseOptionSafe,
  squash: () => squash,
  stripFailures: () => stripFailures,
  stripFailuresSafe: () => stripFailuresSafe,
  stripInterrupts: () => stripInterrupts,
  stripInterruptsSafe: () => stripInterruptsSafe,
  stripSomeDefects: () => stripSomeDefects,
  stripSomeDefectsSafe: () => stripSomeDefectsSafe,
  stripSomeDefects_: () => stripSomeDefects_,
  then: () => import_cause2.then,
  traced: () => import_cause2.traced,
  untraced: () => untraced,
  untracedSafe: () => untracedSafe
});
var A = __toESM(require("../Collections/Immutable/Array/index.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var S = __toESM(require("../IO/index.js"));
var O = __toESM(require("../Option/index.js"));
var import_Stack = require("../Stack/index.js");
var import_cause = require("./cause.js");
var import_errors = require("./errors.js");
var import_cause2 = require("./cause.js");
function ap(fa) {
  return chain((f) => map(f)(fa));
}
function as(e) {
  return map(() => e);
}
function chain_(cause, f) {
  return S.run(chainSafe_(cause, f));
}
function chain(f) {
  return (cause) => chain_(cause, f);
}
function chainSafe_(cause, f) {
  switch (cause._tag) {
    case "Empty": {
      return S.succeed(import_cause.empty);
    }
    case "Fail": {
      return S.succeed(f(cause.value));
    }
    case "Die": {
      return S.succeed(cause);
    }
    case "Interrupt": {
      return S.succeed(cause);
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => chainSafe_(cause.left, f)), S.suspend(() => chainSafe_(cause.right, f)), (l, r) => (0, import_cause.then)(l, r));
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => chainSafe_(cause.left, f)), S.suspend(() => chainSafe_(cause.right, f)), (l, r) => (0, import_cause.both)(l, r));
    }
    case "Traced": {
      return S.map_(chainSafe_(cause.cause, f), (x) => (0, import_cause.traced)(x, cause.trace));
    }
  }
}
function map_(cause, f) {
  return chain_(cause, (e) => (0, import_cause.fail)(f(e)));
}
function map(f) {
  return (cause) => map_(cause, f);
}
function contains(that) {
  return (cause) => S.run(containsSafe(that)(cause));
}
function containsSafe(that) {
  return (cause) => S.gen(function* (_) {
    if (yield* _(cause.equalsSafe(that))) {
      return true;
    }
    return yield* _(reduceLeft(S.succeed(false))((_2, c) => O.some(S.chain_(_2, (b) => b ? S.succeed(b) : c.equalsSafe(that))))(cause));
  });
}
function defects(cause) {
  return reduceLeft([])((a, c) => c._tag === "Die" ? O.some([...a, c.value]) : O.none)(cause);
}
function dieOption(cause) {
  return find((c) => c._tag === "Die" ? O.some(c.value) : O.none)(cause);
}
function died(cause) {
  return O.getOrElse_(O.map_(dieOption(cause), () => true), () => false);
}
function failureOption(cause) {
  return find((c) => c._tag === "Fail" ? O.some(c.value) : O.none)(cause);
}
function failed(cause) {
  return O.getOrElse_(O.map_(failureOption(cause), () => true), () => false);
}
function failureOrCause(cause) {
  return O.getOrElse_(O.map_(failureOption(cause), E.left), () => E.right(cause));
}
function failures(cause) {
  return reduceLeft([])((a, c) => c._tag === "Fail" ? O.some([...a, c.value]) : O.none)(cause);
}
function stripSomeDefects(f) {
  return (cause) => {
    return S.run(stripSomeDefectsSafe(cause, f));
  };
}
function stripSomeDefects_(cause, f) {
  return S.run(stripSomeDefectsSafe(cause, f));
}
function stripSomeDefectsSafe(cause, f) {
  switch (cause._tag) {
    case "Empty": {
      return S.succeed(O.none);
    }
    case "Interrupt": {
      return S.succeed(O.some(cause));
    }
    case "Fail": {
      return S.succeed(O.some(cause));
    }
    case "Die": {
      return S.succeed(O.map_(f(cause.value), import_cause.die));
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => stripSomeDefectsSafe(cause.left, f)), S.suspend(() => stripSomeDefectsSafe(cause.right, f)), (l, r) => {
        if (l._tag === "Some" && r._tag === "Some") {
          return O.some((0, import_cause.both)(l.value, r.value));
        } else if (l._tag === "Some") {
          return l;
        } else if (r._tag === "Some") {
          return r;
        } else {
          return O.none;
        }
      });
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => stripSomeDefectsSafe(cause.left, f)), S.suspend(() => stripSomeDefectsSafe(cause.right, f)), (l, r) => {
        if (l._tag === "Some" && r._tag === "Some") {
          return O.some((0, import_cause.then)(l.value, r.value));
        } else if (l._tag === "Some") {
          return l;
        } else if (r._tag === "Some") {
          return r;
        } else {
          return O.none;
        }
      });
    }
    case "Traced": {
      return S.suspend(() => stripSomeDefectsSafe(cause.cause, f));
    }
  }
}
function find(f) {
  return (cause) => S.run(findSafe(f)(cause));
}
function findSafe(f) {
  return (cause) => {
    const apply = f(cause);
    if (apply._tag === "Some") {
      return S.succeed(apply);
    }
    switch (cause._tag) {
      case "Then": {
        return S.chain_(S.suspend(() => findSafe(f)(cause.left)), (isLeft) => {
          if (isLeft._tag === "Some") {
            return S.succeed(isLeft);
          } else {
            return findSafe(f)(cause.right);
          }
        });
      }
      case "Traced": {
        return S.suspend(() => findSafe(f)(cause.cause));
      }
      case "Both": {
        return S.chain_(S.suspend(() => findSafe(f)(cause.left)), (isLeft) => {
          if (isLeft._tag === "Some") {
            return S.succeed(isLeft);
          } else {
            return findSafe(f)(cause.right);
          }
        });
      }
      default: {
        return S.succeed(apply);
      }
    }
  };
}
const flatten = /* @__PURE__ */ chain(import_Function.identity);
function fold(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase) {
  return (cause) => S.run(foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause));
}
function foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase) {
  return (cause) => {
    switch (cause._tag) {
      case "Empty": {
        return S.succeedWith(empty3);
      }
      case "Fail": {
        return S.succeed(failCase(cause.value));
      }
      case "Die": {
        return S.succeed(dieCase(cause.value));
      }
      case "Interrupt": {
        return S.succeed(interruptCase(cause.fiberId));
      }
      case "Traced": {
        return S.map_(S.suspend(() => foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause.cause)), (x) => tracedCase(x, cause.trace));
      }
      case "Both": {
        return S.zipWith_(S.suspend(() => foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause.left)), S.suspend(() => foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause.right)), (l, r) => bothCase(l, r));
      }
      case "Then": {
        return S.zipWith_(S.suspend(() => foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause.left)), S.suspend(() => foldSafe(empty3, failCase, dieCase, interruptCase, thenCase, bothCase, tracedCase)(cause.right)), (l, r) => thenCase(l, r));
      }
    }
  };
}
function reduceLeft(z) {
  return (f) => {
    return (cause) => {
      let causes = void 0;
      let current = cause;
      let acc = z;
      while (current) {
        const x = f(acc, current);
        acc = x._tag === "Some" ? x.value : acc;
        switch (current._tag) {
          case "Then": {
            causes = new import_Stack.Stack(current.right, causes);
            current = current.left;
            break;
          }
          case "Both": {
            causes = new import_Stack.Stack(current.right, causes);
            current = current.left;
            break;
          }
          case "Traced": {
            current = current.cause;
            break;
          }
          default: {
            current = void 0;
            break;
          }
        }
        if (!current && causes) {
          current = causes.value;
          causes = causes.previous;
        }
      }
      return acc;
    };
  };
}
function interrupted(cause) {
  return O.getOrElse_(O.map_(interruptOption(cause), () => true), () => false);
}
function interruptOption(cause) {
  return find((c) => c._tag === "Interrupt" ? O.some(c.fiberId) : O.none)(cause);
}
function interruptedOnly(cause) {
  return O.getOrElse_(find((c) => c._tag === "Die" || c._tag === "Fail" ? O.some(false) : O.none)(cause), () => true);
}
function interruptors(cause) {
  return Array.from(reduceLeft(/* @__PURE__ */ new Set())((s, c) => c._tag === "Interrupt" ? O.some(s.add(c.fiberId)) : O.none)(cause));
}
function keepDefectsSafe(cause) {
  switch (cause._tag) {
    case "Empty": {
      return S.succeed(O.none);
    }
    case "Fail": {
      return S.succeed(O.none);
    }
    case "Interrupt": {
      return S.succeed(O.none);
    }
    case "Die": {
      return S.succeed(O.some(cause));
    }
    case "Traced": {
      return S.map_(S.suspend(() => keepDefectsSafe(cause.cause)), (x) => O.map_(x, (_) => (0, import_cause.traced)(_, cause.trace)));
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => keepDefectsSafe(cause.left)), S.suspend(() => keepDefectsSafe(cause.right)), (l, r) => {
        if (l._tag === "Some" && r._tag === "Some") {
          return O.some((0, import_cause.then)(l.value, r.value));
        } else if (l._tag === "Some") {
          return l;
        } else if (r._tag === "Some") {
          return r;
        } else {
          return O.none;
        }
      });
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => keepDefectsSafe(cause.left)), S.suspend(() => keepDefectsSafe(cause.right)), (l, r) => {
        if (l._tag === "Some" && r._tag === "Some") {
          return O.some((0, import_cause.both)(l.value, r.value));
        } else if (l._tag === "Some") {
          return l;
        } else if (r._tag === "Some") {
          return r;
        } else {
          return O.none;
        }
      });
    }
  }
}
function keepDefects(cause) {
  return S.run(keepDefectsSafe(cause));
}
function sequenceCauseEither(c) {
  return S.run(sequenceCauseEitherSafe(c));
}
function sequenceCauseEitherSafe(c) {
  switch (c._tag) {
    case "Empty": {
      return S.succeed(E.left(import_cause.empty));
    }
    case "Interrupt": {
      return S.succeed(E.left(c));
    }
    case "Fail": {
      return S.succeed(c.value._tag === "Left" ? E.left((0, import_cause.fail)(c.value.left)) : E.right(c.value.right));
    }
    case "Traced": {
      return S.map_(S.suspend(() => sequenceCauseEitherSafe(c.cause)), (x) => E.mapLeft_(x, (_) => (0, import_cause.traced)(_, c.trace)));
    }
    case "Die": {
      return S.succeed(E.left(c));
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => sequenceCauseEitherSafe(c.left)), S.suspend(() => sequenceCauseEitherSafe(c.right)), (l, r) => {
        if (l._tag === "Left") {
          if (r._tag === "Right") {
            return E.right(r.right);
          } else {
            return E.left((0, import_cause.then)(l.left, r.left));
          }
        } else {
          return E.right(l.right);
        }
      });
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => sequenceCauseEitherSafe(c.left)), S.suspend(() => sequenceCauseEitherSafe(c.right)), (l, r) => {
        if (l._tag === "Left") {
          if (r._tag === "Right") {
            return E.right(r.right);
          } else {
            return E.left((0, import_cause.both)(l.left, r.left));
          }
        } else {
          return E.right(l.right);
        }
      });
    }
  }
}
function sequenceCauseOptionSafe(c) {
  switch (c._tag) {
    case "Empty": {
      return S.succeed(O.some(import_cause.empty));
    }
    case "Interrupt": {
      return S.succeed(O.some(c));
    }
    case "Traced": {
      return S.map_(S.suspend(() => sequenceCauseOptionSafe(c.cause)), (x) => O.map_(x, (_) => (0, import_cause.traced)(_, c.trace)));
    }
    case "Fail": {
      return S.succeed(O.map_(c.value, import_cause.fail));
    }
    case "Die": {
      return S.succeed(O.some(c));
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => sequenceCauseOptionSafe(c.left)), S.suspend(() => sequenceCauseOptionSafe(c.right)), (l, r) => {
        if (l._tag === "Some" && r._tag === "Some") {
          return O.some((0, import_cause.then)(l.value, r.value));
        } else if (l._tag === "Some") {
          return O.some(l.value);
        } else if (r._tag === "Some") {
          return O.some(r.value);
        } else {
          return O.none;
        }
      });
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => sequenceCauseOptionSafe(c.left)), S.suspend(() => sequenceCauseOptionSafe(c.right)), (l, r) => {
        if (l._tag === "Some" && r._tag === "Some") {
          return O.some((0, import_cause.both)(l.value, r.value));
        } else if (l._tag === "Some") {
          return O.some(l.value);
        } else if (r._tag === "Some") {
          return O.some(r.value);
        } else {
          return O.none;
        }
      });
    }
  }
}
function sequenceCauseOption(c) {
  return S.run(sequenceCauseOptionSafe(c));
}
function squash(f) {
  return (cause) => O.getOrElse_(((o) => o._tag === "Some" ? o : A.head(defects(cause)))(((o) => o._tag === "Some" ? o : interrupted(cause) ? O.some(new import_errors.InterruptedException("Interrupted by fibers: " + Array.from(interruptors(cause)).map((_) => _.seqNumber.toString()).map((_) => "#" + _).join(", "))) : O.none)(O.map_(failureOption(cause), f))), () => new import_errors.InterruptedException());
}
function stripFailures(cause) {
  switch (cause._tag) {
    case "Empty": {
      return import_cause.empty;
    }
    case "Fail": {
      return import_cause.empty;
    }
    case "Interrupt": {
      return cause;
    }
    case "Die": {
      return cause;
    }
    default: {
      return S.run(stripFailuresSafe(cause));
    }
  }
}
function stripFailuresSafe(cause) {
  switch (cause._tag) {
    case "Empty": {
      return S.succeed(import_cause.empty);
    }
    case "Fail": {
      return S.succeed(import_cause.empty);
    }
    case "Interrupt": {
      return S.succeed(cause);
    }
    case "Die": {
      return S.succeed(cause);
    }
    case "Traced": {
      return S.map_(S.suspend(() => stripFailuresSafe(cause.cause)), (x) => (0, import_cause.traced)(x, cause.trace));
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => stripFailuresSafe(cause.left)), S.suspend(() => stripFailuresSafe(cause.right)), (l, r) => (0, import_cause.both)(l, r));
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => stripFailuresSafe(cause.left)), S.suspend(() => stripFailuresSafe(cause.right)), (l, r) => (0, import_cause.then)(l, r));
    }
  }
}
function stripInterrupts(cause) {
  switch (cause._tag) {
    case "Empty": {
      return import_cause.empty;
    }
    case "Fail": {
      return cause;
    }
    case "Interrupt": {
      return import_cause.empty;
    }
    case "Die": {
      return cause;
    }
    default: {
      return S.run(stripInterruptsSafe(cause));
    }
  }
}
function stripInterruptsSafe(cause) {
  switch (cause._tag) {
    case "Empty": {
      return S.succeed(import_cause.empty);
    }
    case "Fail": {
      return S.succeed(cause);
    }
    case "Interrupt": {
      return S.succeed(import_cause.empty);
    }
    case "Die": {
      return S.succeed(cause);
    }
    case "Traced": {
      return S.map_(S.suspend(() => stripInterruptsSafe(cause.cause)), (x) => (0, import_cause.traced)(x, cause.trace));
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => stripInterruptsSafe(cause.left)), S.suspend(() => stripInterruptsSafe(cause.right)), (l, r) => (0, import_cause.both)(l, r));
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => stripInterruptsSafe(cause.left)), S.suspend(() => stripInterruptsSafe(cause.right)), (l, r) => (0, import_cause.then)(l, r));
    }
  }
}
function untraced(cause) {
  switch (cause._tag) {
    case "Die":
    case "Empty":
    case "Fail":
    case "Interrupt":
      return cause;
    default:
      return S.run(untracedSafe(cause));
  }
}
function untracedSafe(cause) {
  switch (cause._tag) {
    case "Traced": {
      return S.suspend(() => untracedSafe(cause.cause));
    }
    case "Both": {
      return S.zipWith_(S.suspend(() => untracedSafe(cause.left)), S.suspend(() => untracedSafe(cause.right)), (l, r) => (0, import_cause.both)(l, r));
    }
    case "Then": {
      return S.zipWith_(S.suspend(() => untracedSafe(cause.left)), S.suspend(() => untracedSafe(cause.right)), (l, r) => (0, import_cause.then)(l, r));
    }
    default: {
      return S.succeed(cause);
    }
  }
}
const FCOStackFrameDoneTypeId = /* @__PURE__ */ Symbol();
class FCOStackFrameDone {
  constructor() {
    this._typeId = FCOStackFrameDoneTypeId;
  }
}
const FCOStackFrameTracedTypeId = /* @__PURE__ */ Symbol();
class FCOStackFrameTraced {
  constructor(cause) {
    this.cause = cause;
    this._typeId = FCOStackFrameTracedTypeId;
  }
}
const FCOStackFrameThenLeftTypeId = /* @__PURE__ */ Symbol();
class FCOStackFrameThenLeft {
  constructor(cause) {
    this.cause = cause;
    this._typeId = FCOStackFrameThenLeftTypeId;
  }
}
const FCOStackFrameThenRightTypeId = /* @__PURE__ */ Symbol();
class FCOStackFrameThenRight {
  constructor(cause, leftResult) {
    this.cause = cause;
    this.leftResult = leftResult;
    this._typeId = FCOStackFrameThenRightTypeId;
  }
}
const FCOStackFrameBothLeftTypeId = /* @__PURE__ */ Symbol();
class FCOStackFrameBothLeft {
  constructor(cause) {
    this.cause = cause;
    this._typeId = FCOStackFrameBothLeftTypeId;
  }
}
const FCOStackFrameBothRightTypeId = /* @__PURE__ */ Symbol();
class FCOStackFrameBothRight {
  constructor(cause, leftResult) {
    this.cause = cause;
    this.leftResult = leftResult;
    this._typeId = FCOStackFrameBothRightTypeId;
  }
}
function flipCauseOption(c) {
  let stack = new import_Stack.Stack(new FCOStackFrameDone());
  let result;
  recursion:
    while (stack) {
      pushing:
        while (true) {
          switch (c._tag) {
            case "Empty":
              result = O.some(import_cause.empty);
              break pushing;
            case "Traced":
              stack = new import_Stack.Stack(new FCOStackFrameTraced(c), stack);
              c = c.cause;
              continue pushing;
            case "Interrupt":
              result = O.some((0, import_cause.interrupt)(c.fiberId));
              break pushing;
            case "Die":
              result = O.some(c);
              break pushing;
            case "Fail":
              result = O.fold_(c.value, () => O.none, (r) => O.some((0, import_cause.fail)(r)));
              break pushing;
            case "Then":
              stack = new import_Stack.Stack(new FCOStackFrameThenLeft(c), stack);
              c = c.left;
              continue pushing;
            case "Both":
              stack = new import_Stack.Stack(new FCOStackFrameBothLeft(c), stack);
              c = c.left;
              continue pushing;
          }
        }
      popping:
        while (true) {
          const top = stack.value;
          stack = stack.previous;
          switch (top._typeId) {
            case FCOStackFrameDoneTypeId:
              return result;
            case FCOStackFrameTracedTypeId:
              result = O.map_(result, (_) => (0, import_cause.traced)(_, top.cause.trace));
              continue popping;
            case FCOStackFrameThenLeftTypeId:
              c = top.cause.right;
              stack = new import_Stack.Stack(new FCOStackFrameThenRight(top.cause, result), stack);
              continue recursion;
            case FCOStackFrameThenRightTypeId: {
              const l = top.leftResult;
              if (O.isSome(l) && O.isSome(result)) {
                result = O.some((0, import_cause.then)(l.value, result.value));
              }
              if (O.isNone(l) && O.isSome(result)) {
                result = O.some(result.value);
              }
              if (O.isSome(l) && O.isNone(result)) {
                result = O.some(l.value);
              }
              result = O.none;
              continue popping;
            }
            case FCOStackFrameBothLeftTypeId:
              c = top.cause.right;
              stack = new import_Stack.Stack(new FCOStackFrameBothRight(top.cause, result), stack);
              continue recursion;
            case FCOStackFrameBothRightTypeId: {
              const l = top.leftResult;
              if (O.isSome(l) && O.isSome(result)) {
                result = O.some((0, import_cause.both)(l.value, result.value));
              }
              if (O.isNone(l) && O.isSome(result)) {
                result = O.some(result.value);
              }
              if (O.isSome(l) && O.isNone(result)) {
                result = O.some(l.value);
              }
              result = O.none;
              continue popping;
            }
          }
        }
    }
  throw new Error("Bug");
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ap,
  as,
  both,
  chain,
  chainSafe_,
  chain_,
  contains,
  containsSafe,
  defects,
  die,
  dieOption,
  died,
  empty,
  fail,
  failed,
  failureOption,
  failureOrCause,
  failures,
  find,
  findSafe,
  flatten,
  flipCauseOption,
  fold,
  foldSafe,
  interrupt,
  interruptOption,
  interrupted,
  interruptedOnly,
  interruptors,
  isEmpty,
  keepDefects,
  keepDefectsSafe,
  map,
  map_,
  reduceLeft,
  sequenceCauseEither,
  sequenceCauseEitherSafe,
  sequenceCauseOption,
  sequenceCauseOptionSafe,
  squash,
  stripFailures,
  stripFailuresSafe,
  stripInterrupts,
  stripInterruptsSafe,
  stripSomeDefects,
  stripSomeDefectsSafe,
  stripSomeDefects_,
  then,
  traced,
  untraced,
  untracedSafe
});
