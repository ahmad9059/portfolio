var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var SortedSet_exports = {};
__export(SortedSet_exports, {
  SortedSet: () => SortedSet,
  add: () => add,
  add_: () => add_,
  chain: () => chain,
  chain_: () => chain_,
  difference: () => difference,
  difference_: () => difference_,
  equal: () => equal,
  every: () => every,
  every_: () => every_,
  filter: () => filter,
  filter_: () => filter_,
  forEach_: () => forEach_,
  has_: () => has_,
  intersection: () => intersection,
  intersection_: () => intersection_,
  isSubset: () => isSubset,
  isSubset_: () => isSubset_,
  make: () => make,
  map: () => map,
  map_: () => map_,
  partition: () => partition,
  partition_: () => partition_,
  reduce: () => reduce,
  reduce_: () => reduce_,
  remove: () => remove,
  remove_: () => remove_,
  size: () => size,
  some: () => some,
  some_: () => some_,
  toggle: () => toggle,
  toggle_: () => toggle_,
  union: () => union,
  union_: () => union_,
  values: () => values
});
var import_Operator = require("../../../Operator/index.js");
var import_Function = require("../../../Function/index.js");
var St = __toESM(require("../../../Structural/index.js"));
var RB = __toESM(require("../RedBlackTree/index.js"));
var Tp = __toESM(require("../Tuple/index.js"));
class SortedSet {
  constructor(keyTree) {
    this.keyTree = keyTree;
  }
  [Symbol.iterator]() {
    return RB.keys_(this.keyTree);
  }
  get [St.hashSym]() {
    return this.keyTree[St.hashSym];
  }
  [St.equalsSym](that) {
    return this.keyTree[St.equalsSym](that);
  }
}
function make(K) {
  return new SortedSet(RB.make(K));
}
function add_(set, v) {
  return RB.has_(set.keyTree, v) ? set : new SortedSet(RB.insert_(set.keyTree, v, true));
}
function add(v) {
  return (set) => add_(set, v);
}
function remove_(set, v) {
  return new SortedSet(RB.removeFirst_(set.keyTree, v));
}
function remove(v) {
  return (set) => remove_(set, v);
}
function values(set) {
  return RB.keys_(set.keyTree);
}
function has_(set, v) {
  return RB.has_(set.keyTree, v);
}
function forEach_(map2, f) {
  RB.forEach_(map2.keyTree, (k) => {
    f(k);
  });
}
function intersection_(l, r) {
  let x = make(l.keyTree.ord);
  for (const k of r) {
    if (has_(l, k)) {
      x = add_(x, k);
    }
  }
  return x;
}
function intersection(r) {
  return (l) => intersection_(l, r);
}
function map_(E) {
  return (set, f) => {
    let r = make(E);
    forEach_(set, (e) => {
      const v = f(e);
      if (!has_(r, v)) {
        r = add_(r, v);
      }
    });
    return r;
  };
}
function map(E) {
  const m = map_(E);
  return (f) => (set) => m(set, f);
}
function some(predicate) {
  return (set) => some_(set, predicate);
}
function some_(set, predicate) {
  let found = false;
  for (const e of set) {
    found = predicate(e);
    if (found) {
      break;
    }
  }
  return found;
}
function size(set) {
  return RB.size(set.keyTree);
}
function equal() {
  return {
    equals: (x, y) => {
      if (y === x) {
        return true;
      }
      if (size(x) !== size(y)) {
        return false;
      }
      let eq = true;
      for (const vx of x) {
        if (!has_(y, vx)) {
          eq = false;
          break;
        }
      }
      return eq;
    }
  };
}
function every(predicate) {
  return (set) => every_(set, predicate);
}
function every_(set, predicate) {
  return (0, import_Function.not)(some((0, import_Function.not)(predicate)))(set);
}
function chain(E) {
  const c = chain_(E);
  return (f) => (set) => c(set, f);
}
function chain_(E) {
  return (set, f) => {
    let r = make(E);
    forEach_(set, (e) => {
      for (const a of f(e)) {
        if (!has_(r, a)) {
          r = add_(r, a);
        }
      }
    });
    return r;
  };
}
function isSubset(y) {
  return (x) => isSubset_(y, x);
}
function isSubset_(x, y) {
  return every_(x, (a) => has_(y, a));
}
function filter(predicate) {
  return (set) => filter_(set, predicate);
}
function filter_(set, predicate) {
  let r = make(set.keyTree.ord);
  const values_ = values(set);
  let e;
  while (!(e = values_.next()).done) {
    const value = e.value;
    if (predicate(value)) {
      r = add_(r, value);
    }
  }
  return r;
}
function partition(predicate) {
  return (set) => partition_(set, predicate);
}
function partition_(set, predicate) {
  const values_ = values(set);
  let e;
  let right = make(set.keyTree.ord);
  let left = make(set.keyTree.ord);
  while (!(e = values_.next()).done) {
    const value = e.value;
    if (predicate(value)) {
      right = add_(right, value);
    } else {
      left = add_(left, value);
    }
  }
  return Tp.tuple(left, right);
}
function difference_(x, y) {
  let s = x;
  for (const k of y) {
    s = remove_(s, k);
  }
  return s;
}
function difference(y) {
  return (x) => difference_(x, y);
}
function reduce_(set, z, f) {
  return RB.reduceWithIndex_(set.keyTree, z, (z2, v) => f(z2, v));
}
function reduce(z, f) {
  return (set) => reduce_(set, z, f);
}
function toggle(a) {
  return (set) => toggle_(set, a);
}
function toggle_(set, a) {
  return (has_(set, a) ? remove : add)(a)(set);
}
function union_(l, r) {
  let x = make(l.keyTree.ord);
  forEach_(l, (a) => {
    x = add_(x, a);
  });
  for (const a of r) {
    x = add_(x, a);
  }
  return x;
}
function union(y) {
  return (x) => union_(x, y);
}
module.exports = __toCommonJS(SortedSet_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SortedSet,
  add,
  add_,
  chain,
  chain_,
  difference,
  difference_,
  equal,
  every,
  every_,
  filter,
  filter_,
  forEach_,
  has_,
  intersection,
  intersection_,
  isSubset,
  isSubset_,
  make,
  map,
  map_,
  partition,
  partition_,
  reduce,
  reduce_,
  remove,
  remove_,
  size,
  some,
  some_,
  toggle,
  toggle_,
  union,
  union_,
  values
});
