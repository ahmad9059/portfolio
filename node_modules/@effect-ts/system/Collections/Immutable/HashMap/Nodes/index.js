var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Nodes_exports = {};
__export(Nodes_exports, {
  ArrayNode: () => ArrayNode,
  CollisionNode: () => CollisionNode,
  Empty: () => Empty,
  IndexedNode: () => IndexedNode,
  LeafNode: () => LeafNode,
  canEditNode: () => canEditNode,
  isEmptyNode: () => isEmptyNode,
  isLeaf: () => isLeaf
});
var O = __toESM(require("../../../../Option/index.js"));
var import_Stack = require("../../../../Stack/index.js");
var St = __toESM(require("../../../../Structural/index.js"));
var import_Array = require("../Array/index.js");
var import_Bitwise = require("../Bitwise/index.js");
var import_Config = require("../Config/index.js");
class Empty {
  constructor() {
    this._tag = "Empty";
  }
  modify(edit, _shift, f, hash, key, size) {
    const v = f(O.none);
    if (O.isNone(v))
      return new Empty();
    ++size.value;
    return new LeafNode(edit, hash, key, v);
  }
}
function isEmptyNode(a) {
  return a instanceof Empty;
}
function isLeaf(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(edit, node) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
class LeafNode {
  constructor(edit, hash, key, value) {
    this.edit = edit;
    this.hash = hash;
    this.key = key;
    this.value = value;
    this._tag = "LeafNode";
  }
  modify(edit, shift, f, hash, key, size) {
    if (St.equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (O.isNone(v2)) {
        --size.value;
        return new Empty();
      }
      if (canEditNode(edit, this)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash, key, v2);
    }
    const v = f(O.none);
    if (O.isNone(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
}
class CollisionNode {
  constructor(edit, hash, children) {
    this.edit = edit;
    this.hash = hash;
    this.children = children;
    this._tag = "CollisionNode";
  }
  modify(edit, shift, f, hash, key, size) {
    if (hash === this.hash) {
      const canEdit = canEditNode(edit, this);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(O.none);
    if (O.isNone(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
  updateCollisionList(mutate, edit, hash, list, f, key, size) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && St.equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (O.isNone(newValue2)) {
          --size.value;
          return (0, import_Array.arraySpliceOut)(mutate, i, list);
        }
        return (0, import_Array.arrayUpdate)(mutate, i, new LeafNode(edit, hash, key, newValue2), list);
      }
    }
    const newValue = f(O.none);
    if (O.isNone(newValue))
      return list;
    ++size.value;
    return (0, import_Array.arrayUpdate)(mutate, len, new LeafNode(edit, hash, key, newValue), list);
  }
}
class IndexedNode {
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
    this._tag = "IndexedNode";
  }
  modify(edit, shift, f, hash, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = (0, import_Bitwise.hashFragment)(shift, hash);
    const bit = (0, import_Bitwise.toBitmap)(frag);
    const indx = (0, import_Bitwise.fromBitmap)(mask, bit);
    const exists = mask & bit;
    const current = exists ? children[indx] : new Empty();
    const child = current.modify(edit, shift + import_Config.SIZE, f, hash, key, size);
    if (current === child)
      return this;
    const canEdit = canEditNode(edit, this);
    let bitmap = mask;
    let newChildren;
    if (exists && isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new Empty();
      if (children.length <= 2 && isLeaf(children[indx ^ 1]))
        return children[indx ^ 1];
      newChildren = (0, import_Array.arraySpliceOut)(canEdit, indx, children);
    } else if (!exists && !isEmptyNode(child)) {
      if (children.length >= import_Config.MAX_INDEX_NODE) {
        return expand(edit, frag, child, mask, children);
      }
      bitmap |= bit;
      newChildren = (0, import_Array.arraySpliceIn)(canEdit, indx, child, children);
    } else {
      newChildren = (0, import_Array.arrayUpdate)(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}
class ArrayNode {
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
    this._tag = "ArrayNode";
  }
  modify(edit, shift, f, hash, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = (0, import_Bitwise.hashFragment)(shift, hash);
    const child = children[frag];
    const newChild = (child || new Empty()).modify(edit, shift + import_Config.SIZE, f, hash, key, size);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(edit, this);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = (0, import_Array.arrayUpdate)(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= import_Config.MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = (0, import_Array.arrayUpdate)(canEdit, frag, new Empty(), children);
    } else {
      newChildren = (0, import_Array.arrayUpdate)(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = (0, import_Bitwise.hashFragment)(shift, h1);
  const subH2 = (0, import_Bitwise.hashFragment)(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, (0, import_Bitwise.toBitmap)(subH1) | (0, import_Bitwise.toBitmap)(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, (0, import_Bitwise.toBitmap)(subH1) | (0, import_Bitwise.toBitmap)(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = new import_Stack.Stack(res, stack);
      currentShift = currentShift + import_Config.SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
module.exports = __toCommonJS(Nodes_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ArrayNode,
  CollisionNode,
  Empty,
  IndexedNode,
  LeafNode,
  canEditNode,
  isEmptyNode,
  isLeaf
});
