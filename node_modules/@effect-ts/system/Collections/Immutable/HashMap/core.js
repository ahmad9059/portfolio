var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  HashMap: () => HashMap,
  HashMapIterator: () => HashMapIterator,
  applyCont: () => applyCont,
  beginMutation: () => beginMutation,
  chain: () => chain,
  chainWithIndex: () => chainWithIndex,
  chainWithIndex_: () => chainWithIndex_,
  chain_: () => chain_,
  compact: () => compact,
  endMutation: () => endMutation,
  filter: () => filter,
  filterMap: () => filterMap,
  filterMapWithIndex: () => filterMapWithIndex,
  filterMapWithIndex_: () => filterMapWithIndex_,
  filterMap_: () => filterMap_,
  filterWithIndex: () => filterWithIndex,
  filterWithIndex_: () => filterWithIndex_,
  filter_: () => filter_,
  forEach: () => forEach,
  forEachWithIndex: () => forEachWithIndex,
  forEachWithIndex_: () => forEachWithIndex_,
  forEach_: () => forEach_,
  get: () => get,
  getHash_: () => getHash_,
  get_: () => get_,
  has: () => has,
  hasHash_: () => hasHash_,
  has_: () => has_,
  isEmpty: () => isEmpty,
  keys: () => keys,
  make: () => make,
  map: () => map,
  mapWithIndex: () => mapWithIndex,
  mapWithIndex_: () => mapWithIndex_,
  map_: () => map_,
  modify: () => modify,
  modifyHash_: () => modifyHash_,
  modify_: () => modify_,
  mutate: () => mutate,
  mutate_: () => mutate_,
  reduce: () => reduce,
  reduceWithIndex: () => reduceWithIndex,
  reduceWithIndex_: () => reduceWithIndex_,
  reduce_: () => reduce_,
  remove: () => remove,
  removeMany: () => removeMany,
  removeMany_: () => removeMany_,
  remove_: () => remove_,
  set: () => set,
  setTree_: () => setTree_,
  set_: () => set_,
  size: () => size,
  tryGetHash_: () => tryGetHash_,
  unsafeGet: () => unsafeGet,
  unsafeGet_: () => unsafeGet_,
  update: () => update,
  update_: () => update_,
  values: () => values,
  visitLazy: () => visitLazy,
  visitLazyChildren: () => visitLazyChildren
});
var import_Operator = require("../../../Operator/index.js");
var import_Function = require("../../../Function/index.js");
var import_GlobalExceptions = require("../../../GlobalExceptions/index.js");
var I = __toESM(require("../../../Iterable/index.js"));
var O = __toESM(require("../../../Option/index.js"));
var St = __toESM(require("../../../Structural/index.js"));
var Tp = __toESM(require("../Tuple/index.js"));
var import_Bitwise = require("./Bitwise/index.js");
var import_Config = require("./Config/index.js");
var import_Nodes = require("./Nodes/index.js");
class HashMap {
  constructor(editable, edit, root, size2) {
    this.editable = editable;
    this.edit = edit;
    this.root = root;
    this.size = size2;
    this.tupleIterator = {
      [Symbol.iterator]: () => new HashMapIterator(this, ([k, v]) => Tp.tuple(k, v))
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this, import_Function.identity);
  }
  get [St.hashSym]() {
    return St.hashIterator(new HashMapIterator(this, ([k, v]) => St.combineHash(St.hash(k), St.hash(v))));
  }
  [St.equalsSym](that) {
    return that instanceof HashMap && that.size === this.size && I.corresponds(this.tupleIterator, that.tupleIterator, St.equals);
  }
}
class HashMapIterator {
  constructor(map2, f) {
    this.map = map2;
    this.f = f;
    this.v = visitLazy(this.map.root, this.f, void 0);
  }
  next() {
    if (O.isNone(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
function make() {
  return new HashMap(false, 0, new import_Nodes.Empty(), 0);
}
function setTree_(map2, newRoot, newSize) {
  if (map2.editable) {
    map2.root = newRoot;
    map2.size = newSize;
    return map2;
  }
  return newRoot === map2.root ? map2 : new HashMap(map2.editable, map2.edit, newRoot, newSize);
}
function tryGetHash_(map2, key, hash) {
  let node = map2.root;
  let shift = 0;
  while (true)
    switch (node._tag) {
      case "LeafNode": {
        return St.equals(key, node.key) ? node.value : O.none;
      }
      case "CollisionNode": {
        if (hash === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length; i < len; ++i) {
            const child = children[i];
            if ("key" in child && St.equals(key, child.key))
              return child.value;
          }
        }
        return O.none;
      }
      case "IndexedNode": {
        const frag = (0, import_Bitwise.hashFragment)(shift, hash);
        const bit = (0, import_Bitwise.toBitmap)(frag);
        if (node.mask & bit) {
          node = node.children[(0, import_Bitwise.fromBitmap)(node.mask, bit)];
          shift += import_Config.SIZE;
          break;
        }
        return O.none;
      }
      case "ArrayNode": {
        node = node.children[(0, import_Bitwise.hashFragment)(shift, hash)];
        if (node) {
          shift += import_Config.SIZE;
          break;
        }
        return O.none;
      }
      default:
        return O.none;
    }
}
function getHash_(map2, key, hash) {
  return tryGetHash_(map2, key, hash);
}
function unsafeGet_(map2, key) {
  const element = tryGetHash_(map2, key, St.hash(key));
  if (O.isNone(element)) {
    throw new import_GlobalExceptions.NoSuchElementException();
  }
  return element.value;
}
function unsafeGet(key) {
  return (map2) => unsafeGet_(map2, key);
}
function get_(map2, key) {
  return tryGetHash_(map2, key, St.hash(key));
}
function get(key) {
  return (map2) => get_(map2, key);
}
function hasHash_(map2, key, hash) {
  return O.isSome(tryGetHash_(map2, key, hash));
}
function has_(map2, key) {
  return O.isSome(tryGetHash_(map2, key, St.hash(key)));
}
function has(key) {
  return (map2) => has_(map2, key);
}
function isEmpty(map2) {
  return map2 && !!(0, import_Nodes.isEmptyNode)(map2.root);
}
function modifyHash_(map2, key, hash, f) {
  const size2 = {
    value: map2.size
  };
  const newRoot = map2.root.modify(map2.editable ? map2.edit : NaN, 0, f, hash, key, size2);
  return setTree_(map2, newRoot, size2.value);
}
function modify_(map2, key, f) {
  return modifyHash_(map2, key, St.hash(key), f);
}
function modify(key, f) {
  return (map2) => modify_(map2, key, f);
}
function set_(map2, key, value) {
  return modify_(map2, key, (0, import_Function.constant)(O.some(value)));
}
function set(key, value) {
  return (map2) => set_(map2, key, value);
}
function remove_(map2, key) {
  return modify_(map2, key, (0, import_Function.constant)(O.none));
}
function remove(key) {
  return (map2) => remove_(map2, key);
}
function beginMutation(map2) {
  return new HashMap(true, map2.edit + 1, map2.root, map2.size);
}
function endMutation(map2) {
  map2.editable = false;
  return map2;
}
function mutate(f) {
  return (map2) => mutate_(map2, f);
}
function mutate_(map2, f) {
  const transient = beginMutation(map2);
  f(transient);
  return endMutation(transient);
}
function applyCont(cont) {
  return cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : O.none;
}
function visitLazyChildren(len, children, i, f, cont) {
  while (i < len) {
    const child = children[i++];
    if (child && !(0, import_Nodes.isEmptyNode)(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
}
function visitLazy(node, f, cont = void 0) {
  switch (node._tag) {
    case "LeafNode": {
      return O.isSome(node.value) ? O.some({
        value: f((0, import_Function.tuple)(node.key, node.value.value)),
        cont
      }) : applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
}
function keys(map2) {
  return new HashMapIterator(map2, ([k]) => k);
}
function values(map2) {
  return new HashMapIterator(map2, ([, v]) => v);
}
function update_(map2, key, f) {
  return modify_(map2, key, O.map(f));
}
function update(key, f) {
  return (map2) => update_(map2, key, f);
}
function reduceWithIndex_(map2, z, f) {
  const root = map2.root;
  if (root._tag === "LeafNode")
    return O.isSome(root.value) ? f(z, root.key, root.value.value) : z;
  if (root._tag === "Empty") {
    return z;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len; ) {
      const child = children[i++];
      if (child && !(0, import_Nodes.isEmptyNode)(child)) {
        if (child._tag === "LeafNode") {
          if (O.isSome(child.value)) {
            z = f(z, child.key, child.value.value);
          }
        } else
          toVisit.push(child.children);
      }
    }
  }
  return z;
}
function reduceWithIndex(z, f) {
  return (map2) => reduceWithIndex_(map2, z, f);
}
function reduce_(map2, z, f) {
  return reduceWithIndex_(map2, z, (z2, _, v) => f(z2, v));
}
function reduce(z, f) {
  return (map2) => reduce_(map2, z, f);
}
function forEachWithIndex_(map2, f) {
  reduceWithIndex_(map2, void 0, (_, key, value) => f(key, value));
}
function forEachWithIndex(f) {
  return (map2) => forEachWithIndex_(map2, f);
}
function forEach_(map2, f) {
  forEachWithIndex_(map2, (_, value) => f(value));
}
function forEach(f) {
  return (map2) => forEach_(map2, f);
}
function mapWithIndex_(map2, f) {
  return reduceWithIndex_(map2, make(), (z, k, v) => set_(z, k, f(k, v)));
}
function mapWithIndex(f) {
  return (map2) => mapWithIndex_(map2, f);
}
function map_(map2, f) {
  return reduceWithIndex_(map2, make(), (z, k, v) => set_(z, k, f(v)));
}
function map(f) {
  return (map2) => map_(map2, f);
}
function chain_(map2, f) {
  return reduceWithIndex_(map2, make(), (z, _, v) => mutate_(z, (m) => {
    forEachWithIndex_(f(v), (_k, _a) => {
      set_(m, _k, _a);
    });
  }));
}
function chain(f) {
  return (map2) => chain_(map2, f);
}
function chainWithIndex_(map2, f) {
  return reduceWithIndex_(map2, make(), (z, k, v) => mutate_(z, (m) => {
    forEachWithIndex_(f(k, v), (_k, _a) => {
      set_(m, _k, _a);
    });
  }));
}
function chainWithIndex(f) {
  return (map2) => chainWithIndex_(map2, f);
}
function compact(fa) {
  return filterMapWithIndex_(fa, (_, a) => a);
}
function filterMapWithIndex_(fa, f) {
  const m = make();
  return mutate_(m, (m2) => {
    for (const [k, a] of fa) {
      const o = f(k, a);
      if (O.isSome(o)) {
        set_(m2, k, o.value);
      }
    }
  });
}
function filterMapWithIndex(f) {
  return (fa) => filterMapWithIndex_(fa, f);
}
function filterMap_(fa, f) {
  return filterMapWithIndex_(fa, (_, a) => f(a));
}
function filterMap(f) {
  return (fa) => filterMap_(fa, f);
}
function filterWithIndex_(fa, p) {
  const m = make();
  return mutate_(m, (m2) => {
    for (const [k, a] of fa) {
      if (p(k, a)) {
        set_(m2, k, a);
      }
    }
  });
}
function filterWithIndex(p) {
  return (fa) => filterWithIndex_(fa, p);
}
function filter_(fa, p) {
  return filterWithIndex_(fa, (_, a) => p(a));
}
function filter(p) {
  return (fa) => filter_(fa, p);
}
function size(map2) {
  return map2.size;
}
function removeMany_(self, ks) {
  return mutate_(self, (m) => {
    for (const k of ks) {
      remove_(m, k);
    }
  });
}
function removeMany(ks) {
  return (self) => removeMany_(self, ks);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashMap,
  HashMapIterator,
  applyCont,
  beginMutation,
  chain,
  chainWithIndex,
  chainWithIndex_,
  chain_,
  compact,
  endMutation,
  filter,
  filterMap,
  filterMapWithIndex,
  filterMapWithIndex_,
  filterMap_,
  filterWithIndex,
  filterWithIndex_,
  filter_,
  forEach,
  forEachWithIndex,
  forEachWithIndex_,
  forEach_,
  get,
  getHash_,
  get_,
  has,
  hasHash_,
  has_,
  isEmpty,
  keys,
  make,
  map,
  mapWithIndex,
  mapWithIndex_,
  map_,
  modify,
  modifyHash_,
  modify_,
  mutate,
  mutate_,
  reduce,
  reduceWithIndex,
  reduceWithIndex_,
  reduce_,
  remove,
  removeMany,
  removeMany_,
  remove_,
  set,
  setTree_,
  set_,
  size,
  tryGetHash_,
  unsafeGet,
  unsafeGet_,
  update,
  update_,
  values,
  visitLazy,
  visitLazyChildren
});
