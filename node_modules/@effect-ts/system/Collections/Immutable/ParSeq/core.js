var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  chain: () => chain,
  chain_: () => chain_,
  first: () => first,
  flatten: () => flatten,
  fold: () => fold,
  fold_: () => fold_,
  map: () => map,
  map_: () => map_,
  toCause: () => toCause,
  zip: () => zip,
  zipLeft: () => zipLeft,
  zipLeft_: () => zipLeft_,
  zipRight: () => zipRight,
  zipRight_: () => zipRight_,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var Cause = __toESM(require("../../../Cause/core.js"));
var E = __toESM(require("../../../Either/index.js"));
var import_Function = require("../../../Function/index.js");
var O = __toESM(require("../../../Option/index.js"));
var L = __toESM(require("../List/core.js"));
var Tp = __toESM(require("../Tuple/index.js"));
var P = __toESM(require("./primitives.js"));
function first(self) {
  while (1) {
    switch (self._tag) {
      case "Single": {
        return O.some(self.a);
      }
      case "Empty": {
        return O.none;
      }
      case "Both": {
        self = self.left;
        break;
      }
      case "Then": {
        self = self.left;
        break;
      }
    }
  }
  throw new Error("Bug");
}
function foldLoop(emptyCase, singleCase, thenCase, bothCase, inp, out) {
  while (1) {
    if (L.isEmpty(inp)) {
      return L.reduce_(out, L.empty(), (acc, val) => {
        if (val._tag === "Right") {
          return L.prepend_(acc, val.right);
        } else {
          if (val.left) {
            let parSeqs = acc;
            const left = L.unsafeFirst(parSeqs);
            parSeqs = L.tail(parSeqs);
            const right = L.unsafeFirst(parSeqs);
            parSeqs = L.tail(parSeqs);
            return L.prepend_(parSeqs, bothCase(left, right));
          } else {
            let parSeqs = acc;
            const left = L.unsafeFirst(parSeqs);
            parSeqs = L.tail(parSeqs);
            const right = L.unsafeFirst(parSeqs);
            parSeqs = L.tail(parSeqs);
            return L.prepend_(parSeqs, thenCase(left, right));
          }
        }
      });
    } else {
      const head = L.unsafeFirst(inp);
      const parSeqs = L.tail(inp);
      switch (head._tag) {
        case "Empty": {
          inp = parSeqs;
          out = L.prepend_(out, E.right(emptyCase));
          break;
        }
        case "Single": {
          inp = parSeqs;
          out = L.prepend_(out, E.right(singleCase(head.a)));
          break;
        }
        case "Then": {
          inp = L.prepend_(L.prepend_(parSeqs, head.right), head.left);
          out = L.prepend_(out, E.left(false));
          break;
        }
        case "Both": {
          inp = L.prepend_(L.prepend_(parSeqs, head.right), head.left);
          out = L.prepend_(out, E.left(true));
          break;
        }
      }
    }
  }
  throw new Error("Bug");
}
function fold_(self, emptyCase, singleCase, thenCase, bothCase) {
  return L.unsafeFirst(foldLoop(emptyCase, singleCase, thenCase, bothCase, L.of(self), L.empty()));
}
function fold(emptyCase, singleCase, thenCase, bothCase) {
  return (self) => fold_(self, emptyCase, singleCase, thenCase, bothCase);
}
function chain_(self, f) {
  return fold_(self, P.empty, f, P.then_, P.both_);
}
function chain(f) {
  return (self) => chain_(self, f);
}
function flatten(self) {
  return chain_(self, import_Function.identity);
}
function toCause(self) {
  return fold_(self, Cause.empty, Cause.fail, Cause.then, Cause.both);
}
function map_(self, f) {
  return chain_(self, (a) => P.single(f(a)));
}
function map(f) {
  return (self) => map_(self, f);
}
function zipWith_(self, that, f) {
  return chain_(self, (a) => map_(that, (b) => f(a, b)));
}
function zipWith(that, f) {
  return (self) => zipWith_(self, that, f);
}
function zip_(self, that) {
  return zipWith_(self, that, Tp.tuple);
}
function zip(that) {
  return (self) => zip_(self, that);
}
function zipLeft_(self, that) {
  return zipWith_(self, that, (a, _b) => a);
}
function zipLeft(that) {
  return (self) => zipLeft_(self, that);
}
function zipRight_(self, that) {
  return zipWith_(self, that, (_a, b) => b);
}
function zipRight(that) {
  return (self) => zipRight_(self, that);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  chain,
  chain_,
  first,
  flatten,
  fold,
  fold_,
  map,
  map_,
  toCause,
  zip,
  zipLeft,
  zipLeft_,
  zipRight,
  zipRight_,
  zipWith,
  zipWith_,
  zip_
});
