var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  ChunkBuilder: () => ChunkBuilder,
  append: () => append,
  append_: () => append_,
  buckets: () => buckets,
  builder: () => builder,
  chain: () => chain,
  chain_: () => chain_,
  concat: () => concat,
  concat_: () => concat_,
  drop: () => drop,
  dropRight: () => dropRight,
  dropRight_: () => dropRight_,
  drop_: () => drop_,
  empty: () => empty,
  equals: () => equals,
  equals_: () => equals_,
  flatten: () => flatten,
  get: () => get,
  get_: () => get_,
  head: () => head,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty,
  last: () => last,
  make: () => make,
  makeBy_: () => makeBy_,
  map: () => map,
  mapWithIndex: () => mapWithIndex,
  mapWithIndex_: () => mapWithIndex_,
  map_: () => map_,
  materialize: () => materialize,
  prepend: () => prepend,
  prepend_: () => prepend_,
  reverse: () => reverse,
  reverseBuckets: () => reverseBuckets,
  single: () => single,
  size: () => size,
  tail: () => tail,
  take: () => take,
  takeRight: () => takeRight,
  takeRight_: () => takeRight_,
  take_: () => take_,
  toArray: () => toArray,
  toArrayLike: () => toArrayLike,
  unit: () => unit,
  unsafeGet: () => unsafeGet,
  unsafeGet_: () => unsafeGet_,
  unsafeHead: () => unsafeHead,
  unsafeLast: () => unsafeLast,
  unsafeTail: () => unsafeTail
});
var import_Function = require("../../../Function/index.js");
var import_GlobalExceptions = require("../../../GlobalExceptions/index.js");
var O = __toESM(require("../../../Option/index.js"));
var St = __toESM(require("../../../Structural/index.js"));
var import_definition = require("./definition.js");
__reExport(core_exports, require("./definition.js"));
function single(a) {
  return new import_definition.Singleton(a);
}
function empty() {
  return import_definition._Empty;
}
function append(a) {
  return (self) => self.append(a);
}
function append_(self, a) {
  return self.append(a);
}
function prepend(a) {
  return (self) => self.prepend(a);
}
function prepend_(self, a) {
  return self.prepend(a);
}
function concat(that) {
  return (self) => self.concat(that);
}
function concat_(self, that) {
  return self.concat(that);
}
function toArrayLike(self) {
  return self.arrayLike();
}
function toArray(self) {
  return self.array();
}
function get_(self, n) {
  return !Number.isInteger(n) || n < 0 || n >= self.length ? O.none : O.some(self.get(n));
}
function get(n) {
  return (self) => get_(self, n);
}
function unsafeGet_(self, n) {
  return self.get(n);
}
function unsafeGet(n) {
  return (self) => unsafeGet_(self, n);
}
function equals_(self, that) {
  return (0, import_definition.corresponds_)(self, that, St.equals);
}
function equals(that) {
  return (self) => equals_(self, that);
}
function take_(self, n) {
  return self.take(n);
}
function take(n) {
  return (self) => self.take(n);
}
function takeRight_(self, n) {
  return drop_(self, size(self) - n);
}
function takeRight(n) {
  return (self) => takeRight_(self, n);
}
function drop_(self, n) {
  ;
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return import_definition._Empty;
  } else {
    const len = self.length;
    switch (self._typeId) {
      case import_definition.EmptyTypeId: {
        return import_definition._Empty;
      }
      case import_definition.SliceTypeId: {
        return new import_definition.Slice(self.chunk, self.offset + n, self.length - n);
      }
      case import_definition.SingletonTypeId: {
        if (n > 0) {
          return import_definition._Empty;
        }
        return self;
      }
      default: {
        return new import_definition.Slice(self, n, len - n);
      }
    }
  }
}
function drop(n) {
  return (self) => drop_(self, n);
}
function dropRight_(self, n) {
  ;
  return take_(self, Math.max(0, self.length - n));
}
function dropRight(n) {
  return (self) => dropRight_(self, n);
}
function size(self) {
  return self.length;
}
function map_(self, f) {
  ;
  if (self._typeId === import_definition.SingletonTypeId) {
    return new import_definition.Singleton(f(self.a));
  }
  let r = empty();
  for (const k of self) {
    r = append_(r, f(k));
  }
  return r;
}
function map(f) {
  return (self) => map_(self, f);
}
function mapWithIndex_(self, f) {
  ;
  if (self._typeId === import_definition.SingletonTypeId) {
    return new import_definition.Singleton(f(0, self.a));
  }
  let r = empty();
  let i = 0;
  for (const k of self) {
    r = append_(r, f(i, k));
    i += 1;
  }
  return r;
}
function mapWithIndex(f) {
  return (self) => mapWithIndex_(self, f);
}
function chain_(self, f) {
  ;
  if (self._typeId === import_definition.SingletonTypeId) {
    return f(self.a);
  }
  let r = empty();
  for (const k of self) {
    r = concat_(r, f(k));
  }
  return r;
}
function chain(f) {
  return (self) => chain_(self, f);
}
function flatten(self) {
  return chain_(self, import_Function.identity);
}
function head(self) {
  return get_(self, 0);
}
function tail(self) {
  return self.length > 0 ? O.some(drop_(self, 1)) : O.none;
}
function last(self) {
  return get_(self, self.length - 1);
}
function unsafeHead(self) {
  return self.get(0);
}
function unsafeTail(self) {
  if (self.length === 0) {
    throw new import_GlobalExceptions.ArrayIndexOutOfBoundsException(1);
  }
  return drop_(self, 1);
}
function unsafeLast(self) {
  return self.get(self.length - 1);
}
function isEmpty(self) {
  return self.length === 0;
}
function isNonEmpty(self) {
  return self.length !== 0;
}
function buckets(self) {
  return self.buckets();
}
function reverseBuckets(self) {
  return self.reverseBuckets();
}
function reverse(self) {
  return self.reverse();
}
function materialize(self) {
  return self.materialize();
}
const unit = /* @__PURE__ */ single(void 0);
function make(...iter) {
  let builder2 = empty();
  for (const x of iter) {
    builder2 = append_(builder2, x);
  }
  return builder2;
}
function makeBy_(n, f) {
  const b = builder();
  for (let i = 0; i < n; i++) {
    b.append(f(i));
  }
  return b.build();
}
function builder() {
  return new ChunkBuilder(empty());
}
class ChunkBuilder {
  constructor(chunk) {
    this.chunk = chunk;
  }
  append(a) {
    this.chunk = append_(this.chunk, a);
    return this;
  }
  build() {
    return this.chunk;
  }
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChunkBuilder,
  append,
  append_,
  buckets,
  builder,
  chain,
  chain_,
  concat,
  concat_,
  drop,
  dropRight,
  dropRight_,
  drop_,
  empty,
  equals,
  equals_,
  flatten,
  get,
  get_,
  head,
  isEmpty,
  isNonEmpty,
  last,
  make,
  makeBy_,
  map,
  mapWithIndex,
  mapWithIndex_,
  map_,
  materialize,
  prepend,
  prepend_,
  reverse,
  reverseBuckets,
  single,
  size,
  tail,
  take,
  takeRight,
  takeRight_,
  take_,
  toArray,
  toArrayLike,
  unit,
  unsafeGet,
  unsafeGet_,
  unsafeHead,
  unsafeLast,
  unsafeTail
});
