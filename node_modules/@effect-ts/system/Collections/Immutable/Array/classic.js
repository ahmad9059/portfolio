var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var classic_exports = {};
__export(classic_exports, {
  ap: () => ap,
  ap_: () => ap_,
  comprehension: () => comprehension,
  deleteAt: () => deleteAt,
  deleteAt_: () => deleteAt_,
  duplicate: () => duplicate,
  extend: () => extend,
  extend_: () => extend_,
  findFirstMap: () => findFirstMap,
  findFirstMap_: () => findFirstMap_,
  findLastMap: () => findLastMap,
  findLastMap_: () => findLastMap_,
  foldLeft: () => foldLeft,
  foldLeft_: () => foldLeft_,
  foldRight: () => foldRight,
  foldRight_: () => foldRight_,
  groupBy: () => groupBy,
  groupBy_: () => groupBy_,
  init: () => init,
  insertAt: () => insertAt,
  insertAt_: () => insertAt_,
  lefts: () => lefts,
  modifyAt: () => modifyAt,
  modifyAt_: () => modifyAt_,
  rights: () => rights,
  rotate: () => rotate,
  rotate_: () => rotate_,
  scanLeft: () => scanLeft,
  scanLeft_: () => scanLeft_,
  scanRight: () => scanRight,
  scanRight_: () => scanRight_,
  separate: () => separate,
  takeUntil: () => takeUntil,
  takeUntil_: () => takeUntil_,
  unsafeDeleteAt: () => unsafeDeleteAt,
  unsafeDeleteAt_: () => unsafeDeleteAt_,
  unsafeInsertAt: () => unsafeInsertAt,
  unsafeInsertAt_: () => unsafeInsertAt_,
  unsafeUpdateAt: () => unsafeUpdateAt,
  unsafeUpdateAt_: () => unsafeUpdateAt_,
  updateAt: () => updateAt,
  updateAt_: () => updateAt_
});
var import_Option = require("../../../Option/index.js");
var Tp = __toESM(require("../Tuple/index.js"));
var C = __toESM(require("./core.js"));
function ap(fa) {
  return (fab) => ap_(fab, fa);
}
function ap_(fab, fa) {
  return C.flatten(C.map_(fab, (f) => C.map_(fa, f)));
}
function comprehension(input, f, g = () => true) {
  const go = (scope, input2) => {
    if (input2.length === 0) {
      return g(...scope) ? [f(...scope)] : C.empty();
    } else {
      return C.chain_(input2[0], (x) => go(C.append_(scope, x), input2.slice(1)));
    }
  };
  return go(C.empty(), input);
}
function deleteAt(i) {
  return (as) => deleteAt_(as, i);
}
function deleteAt_(as, i) {
  return C.isOutOfBound(i, as) ? import_Option.none : (0, import_Option.some)(unsafeDeleteAt_(as, i));
}
function duplicate(ma) {
  return extend((x) => x)(ma);
}
function extend(f) {
  return (ma) => extend_(ma, f);
}
function extend_(ma, f) {
  return ma.map((_, i, as) => f(as.slice(i)));
}
function findFirstMap(f) {
  return (as) => findFirstMap_(as, f);
}
function findFirstMap_(as, f) {
  const len = as.length;
  for (let i = 0; i < len; i++) {
    const v = f(as[i]);
    if ((0, import_Option.isSome)(v)) {
      return v;
    }
  }
  return import_Option.none;
}
function findLastMap(f) {
  return (as) => findLastMap_(as, f);
}
function findLastMap_(as, f) {
  const len = as.length;
  for (let i = len - 1; i >= 0; i--) {
    const v = f(as[i]);
    if ((0, import_Option.isSome)(v)) {
      return v;
    }
  }
  return import_Option.none;
}
function foldLeft(onNil, onCons) {
  return (as) => foldLeft_(as, onNil, onCons);
}
function foldLeft_(as, onNil, onCons) {
  return C.isEmpty(as) ? onNil() : onCons(as[0], as.slice(1));
}
function foldRight(onNil, onCons) {
  return (as) => foldRight_(as, onNil, onCons);
}
function foldRight_(as, onNil, onCons) {
  return C.isEmpty(as) ? onNil() : onCons(as.slice(0, as.length - 1), as[as.length - 1]);
}
function init(as) {
  const len = as.length;
  return len === 0 ? import_Option.none : (0, import_Option.some)(as.slice(0, len - 1));
}
function insertAt(i, a) {
  return (as) => insertAt_(as, i, a);
}
function insertAt_(as, i, a) {
  return i < 0 || i > as.length ? import_Option.none : (0, import_Option.some)(unsafeInsertAt_(as, i, a));
}
function unsafeInsertAt_(as, i, a) {
  const xs = [...as];
  xs.splice(i, 0, a);
  return xs;
}
function unsafeInsertAt(i, a) {
  return (as) => unsafeInsertAt_(as, i, a);
}
function updateAt(i, a) {
  return (as) => updateAt_(as, i, a);
}
function updateAt_(as, i, a) {
  return C.isOutOfBound(i, as) ? import_Option.none : (0, import_Option.some)(unsafeUpdateAt_(as, i, a));
}
function unsafeUpdateAt_(as, i, a) {
  if (as[i] === a) {
    return as;
  } else {
    const xs = [...as];
    xs[i] = a;
    return xs;
  }
}
function unsafeUpdateAt(i, a) {
  return (as) => unsafeUpdateAt_(as, i, a);
}
function lefts(as) {
  const r = [];
  const len = as.length;
  for (let i = 0; i < len; i++) {
    const a = as[i];
    if (a._tag === "Left") {
      r.push(a.left);
    }
  }
  return r;
}
function modifyAt(i, f) {
  return (as) => C.isOutOfBound(i, as) ? import_Option.none : (0, import_Option.some)(unsafeUpdateAt_(as, i, f(as[i])));
}
function modifyAt_(as, i, f) {
  return C.isOutOfBound(i, as) ? import_Option.none : (0, import_Option.some)(unsafeUpdateAt_(as, i, f(as[i])));
}
function rights(as) {
  const r = [];
  const len = as.length;
  for (let i = 0; i < len; i++) {
    const a = as[i];
    if (a._tag === "Right") {
      r.push(a.right);
    }
  }
  return r;
}
function rotate(n) {
  return (as) => rotate_(as, n);
}
function rotate_(as, n) {
  const len = as.length;
  if (n === 0 || len <= 1 || len === Math.abs(n)) {
    return as;
  } else if (n < 0) {
    return rotate(len + n)(as);
  } else {
    return as.slice(-n).concat(as.slice(0, len - n));
  }
}
function scanLeft(b, f) {
  return (as) => scanLeft_(as, b, f);
}
function scanLeft_(as, b, f) {
  const l = as.length;
  const r = new Array(l + 1);
  r[0] = b;
  for (let i = 0; i < l; i++) {
    r[i + 1] = f(r[i], as[i]);
  }
  return r;
}
function scanRight(b, f) {
  return (as) => scanRight_(as, b, f);
}
function scanRight_(as, b, f) {
  const l = as.length;
  const r = new Array(l + 1);
  r[l] = b;
  for (let i = l - 1; i >= 0; i--) {
    r[i] = f(as[i], r[i + 1]);
  }
  return r;
}
function takeUntil(predicate) {
  return (as) => takeUntil_(as, predicate);
}
function takeUntil_(as, predicate) {
  const init2 = [];
  for (let i = 0; i < as.length; i++) {
    init2[i] = as[i];
    if (predicate(as[i])) {
      return init2;
    }
  }
  return init2;
}
function unsafeDeleteAt_(as, i) {
  const xs = [...as];
  xs.splice(i, 1);
  return xs;
}
function unsafeDeleteAt(i) {
  return (as) => unsafeDeleteAt_(as, i);
}
function separate(fa) {
  const left = [];
  const right = [];
  for (const e of fa) {
    if (e._tag === "Left") {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return Tp.tuple(left, right);
}
function groupBy(f) {
  return (as) => groupBy_(as, f);
}
function groupBy_(as, f) {
  const r = {};
  for (const a of as) {
    const k = f(a);
    if (r.hasOwnProperty(k)) {
      r[k].push(a);
    } else {
      r[k] = [a];
    }
  }
  return r;
}
module.exports = __toCommonJS(classic_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ap,
  ap_,
  comprehension,
  deleteAt,
  deleteAt_,
  duplicate,
  extend,
  extend_,
  findFirstMap,
  findFirstMap_,
  findLastMap,
  findLastMap_,
  foldLeft,
  foldLeft_,
  foldRight,
  foldRight_,
  groupBy,
  groupBy_,
  init,
  insertAt,
  insertAt_,
  lefts,
  modifyAt,
  modifyAt_,
  rights,
  rotate,
  rotate_,
  scanLeft,
  scanLeft_,
  scanRight,
  scanRight_,
  separate,
  takeUntil,
  takeUntil_,
  unsafeDeleteAt,
  unsafeDeleteAt_,
  unsafeInsertAt,
  unsafeInsertAt_,
  unsafeUpdateAt,
  unsafeUpdateAt_,
  updateAt,
  updateAt_
});
