var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  append: () => append,
  append_: () => append_,
  chain: () => chain,
  chain_: () => chain_,
  chop: () => chop,
  chop_: () => chop_,
  collect: () => collect,
  collectWhile: () => collectWhile,
  collectWhile_: () => collectWhile_,
  collectWithIndex: () => collectWithIndex,
  collectWithIndex_: () => collectWithIndex_,
  collect_: () => collect_,
  compact: () => compact,
  concat: () => concat,
  concat_: () => concat_,
  copy: () => copy,
  drop: () => drop,
  dropRight: () => dropRight,
  dropRight_: () => dropRight_,
  dropWhile: () => dropWhile,
  dropWhile_: () => dropWhile_,
  drop_: () => drop_,
  empty: () => empty,
  filter: () => filter,
  filterWithIndex: () => filterWithIndex,
  filterWithIndex_: () => filterWithIndex_,
  filter_: () => filter_,
  find: () => find,
  findIndex: () => findIndex,
  findIndex_: () => findIndex_,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  findLastIndex_: () => findLastIndex_,
  findLast_: () => findLast_,
  find_: () => find_,
  flatten: () => flatten,
  forAll: () => forAll,
  forAll_: () => forAll_,
  forAny: () => forAny,
  forAny_: () => forAny_,
  from: () => from,
  fromMutable: () => fromMutable,
  get: () => get,
  get_: () => get_,
  head: () => head,
  includes: () => includes,
  includes_: () => includes_,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty,
  isOutOfBound: () => isOutOfBound,
  join: () => join,
  join_: () => join_,
  last: () => last,
  makeBy: () => makeBy,
  makeBy_: () => makeBy_,
  map: () => map,
  mapWithIndex: () => mapWithIndex,
  mapWithIndex_: () => mapWithIndex_,
  map_: () => map_,
  prepend: () => prepend,
  prepend_: () => prepend_,
  range: () => range,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRightWithIndex: () => reduceRightWithIndex,
  reduceRightWithIndex_: () => reduceRightWithIndex_,
  reduceRight_: () => reduceRight_,
  reduceWithIndex: () => reduceWithIndex,
  reduceWithIndex_: () => reduceWithIndex_,
  reduce_: () => reduce_,
  replicate: () => replicate,
  replicate_: () => replicate_,
  reverse: () => reverse,
  single: () => single,
  size: () => size,
  spanIndex_: () => spanIndex_,
  spanLeft: () => spanLeft,
  spanLeft_: () => spanLeft_,
  split: () => split,
  splitAt: () => splitAt,
  splitAt_: () => splitAt_,
  split_: () => split_,
  tail: () => tail,
  take: () => take,
  takeRight: () => takeRight,
  takeRight_: () => takeRight_,
  takeWhile: () => takeWhile,
  takeWhile_: () => takeWhile_,
  take_: () => take_,
  toMutable: () => toMutable,
  unfold: () => unfold,
  unfold_: () => unfold_,
  unzip: () => unzip,
  zip: () => zip,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var import_Operator = require("../../../Operator/index.js");
var import_core = require("../../../Function/core.js");
var import_Option = require("../../../Option/index.js");
var Tp = __toESM(require("../Tuple/index.js"));
function chain(f) {
  return (ma) => chain_(ma, f);
}
function chain_(fa, f) {
  let resLen = 0;
  const l = fa.length;
  const temp = new Array(l);
  for (let i = 0; i < l; i++) {
    const e = fa[i];
    const arr = f(e);
    resLen += arr.length;
    temp[i] = arr;
  }
  const r = Array(resLen);
  let start = 0;
  for (let i = 0; i < l; i++) {
    const arr = temp[i];
    const l2 = arr.length;
    for (let j = 0; j < l2; j++) {
      r[j + start] = arr[j];
    }
    start += l2;
  }
  return r;
}
function split(n) {
  return (as) => split_(as, n);
}
function split_(as, n) {
  const f = chop(splitAt(n));
  return as.length === 0 ? empty() : isOutOfBound(n - 1, as) ? [as] : f(as);
}
function compact(fa) {
  return collect((x) => x)(fa);
}
function concat_(x, y) {
  const lenx = x.length;
  if (lenx === 0) {
    return y;
  }
  const leny = y.length;
  if (leny === 0) {
    return x;
  }
  const r = Array(lenx + leny);
  for (let i = 0; i < lenx; i++) {
    r[i] = x[i];
  }
  for (let i = 0; i < leny; i++) {
    r[i + lenx] = y[i];
  }
  return r;
}
function concat(y) {
  return (x) => concat_(x, y);
}
function prepend_(tail2, head2) {
  const len = tail2.length;
  const r = Array(len + 1);
  for (let i = 0; i < len; i++) {
    r[i + 1] = tail2[i];
  }
  r[0] = head2;
  return r;
}
function prepend(head2) {
  return (tail2) => prepend_(tail2, head2);
}
function drop(n) {
  return (as) => drop_(as, n);
}
function drop_(as, n) {
  return as.slice(n, as.length);
}
function dropWhile(predicate) {
  return (as) => dropWhile_(as, predicate);
}
function dropWhile_(as, predicate) {
  const i = spanIndex_(as, predicate);
  const l = as.length;
  const rest = Array(l - i);
  for (let j = i; j < l; j++) {
    rest[j - i] = as[j];
  }
  return rest;
}
function dropRight(n) {
  return (as) => dropRight_(as, n);
}
function dropRight_(as, n) {
  return as.slice(0, as.length - n);
}
function empty() {
  return [];
}
function filter(predicate) {
  return (fa) => fa.filter(predicate);
}
function filter_(fa, predicate) {
  return fa.filter(predicate);
}
function filterWithIndex(predicate) {
  return (nea) => filterWithIndex_(nea, predicate);
}
function filterWithIndex_(nea, predicate) {
  return nea.filter((a, i) => predicate(i, a));
}
const collect = (f) => (fa) => collect_(fa, f);
function collect_(fa, f) {
  return collectWithIndex_(fa, (_, a) => f(a));
}
function collectWithIndex(f) {
  return (fa) => collectWithIndex_(fa, f);
}
function collectWithIndex_(fa, f) {
  const result = [];
  for (let i = 0; i < fa.length; i++) {
    const optionB = f(i, fa[i]);
    if ((0, import_Option.isSome)(optionB)) {
      result.push(optionB.value);
    }
  }
  return result;
}
function collectWhile_(arr, f) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const o = f(arr[i]);
    if ((0, import_Option.isSome)(o)) {
      result.push(o.value);
    } else {
      break;
    }
  }
  return result;
}
function collectWhile(f) {
  return (arr) => collectWhile_(arr, f);
}
function find(predicate) {
  return (as) => find_(as, predicate);
}
function find_(as, predicate) {
  const len = as.length;
  for (let i = 0; i < len; i++) {
    if (predicate(as[i])) {
      return (0, import_Option.some)(as[i]);
    }
  }
  return import_Option.none;
}
function findIndex(predicate) {
  return (as) => findIndex_(as, predicate);
}
function findIndex_(as, predicate) {
  const len = as.length;
  for (let i = 0; i < len; i++) {
    if (predicate(as[i])) {
      return (0, import_Option.some)(i);
    }
  }
  return import_Option.none;
}
function findLast(predicate) {
  return (as) => findLast_(as, predicate);
}
function findLast_(as, predicate) {
  const len = as.length;
  for (let i = len - 1; i >= 0; i--) {
    if (predicate(as[i])) {
      return (0, import_Option.some)(as[i]);
    }
  }
  return import_Option.none;
}
function findLastIndex(predicate) {
  return (as) => findLastIndex_(as, predicate);
}
function findLastIndex_(as, predicate) {
  const len = as.length;
  for (let i = len - 1; i >= 0; i--) {
    if (predicate(as[i])) {
      return (0, import_Option.some)(i);
    }
  }
  return import_Option.none;
}
function flatten(mma) {
  return chain_(mma, import_core.identity);
}
function fromMutable(as) {
  const l = as.length;
  if (l === 0) {
    return empty();
  }
  const ras = Array(l);
  for (let i = 0; i < l; i++) {
    ras[i] = as[i];
  }
  return ras;
}
function head(as) {
  return isEmpty(as) ? import_Option.none : (0, import_Option.some)(as[0]);
}
function isEmpty(as) {
  return as.length === 0;
}
function isNonEmpty(as) {
  return as.length > 0;
}
function last(as) {
  return get_(as, as.length - 1);
}
function get_(as, i) {
  return isOutOfBound(i, as) ? import_Option.none : (0, import_Option.some)(as[i]);
}
function get(i) {
  return (as) => get_(as, i);
}
function makeBy_(n, f) {
  const r = [];
  for (let i = 0; i < n; i++) {
    r.push(f(i));
  }
  return r;
}
function makeBy(f) {
  return (n) => makeBy_(n, f);
}
function map(f) {
  return (fa) => fa.map(f);
}
function map_(fa, f) {
  return fa.map(f);
}
function mapWithIndex(f) {
  return (fa) => mapWithIndex_(fa, f);
}
function mapWithIndex_(fa, f) {
  return fa.map((a, i) => f(i, a));
}
function single(a) {
  return [a];
}
function range(start, end) {
  return makeBy_(end - start + 1, (i) => start + i);
}
function reduce(b, f) {
  return (fa) => reduce_(fa, b, f);
}
function reduce_(fa, b, f) {
  return reduceWithIndex_(fa, b, (_, b2, a) => f(b2, a));
}
function reduceRight(b, f) {
  return (fa) => reduceRight_(fa, b, f);
}
function reduceRight_(fa, b, f) {
  return reduceRightWithIndex_(fa, b, (_, a, b2) => f(a, b2));
}
function reduceRightWithIndex(b, f) {
  return (fa) => fa.reduceRight((b2, a, i) => f(i, a, b2), b);
}
function reduceRightWithIndex_(fa, b, f) {
  return fa.reduceRight((b2, a, i) => f(i, a, b2), b);
}
function reduceWithIndex(b, f) {
  return (fa) => reduceWithIndex_(fa, b, f);
}
function reduceWithIndex_(fa, b, f) {
  const l = fa.length;
  let r = b;
  for (let i = 0; i < l; i++) {
    r = f(i, r, fa[i]);
  }
  return r;
}
function replicate_(n, a) {
  return makeBy_(n, () => a);
}
function replicate(a) {
  return (n) => replicate_(n, a);
}
function reverse(as) {
  return [...as].reverse();
}
function append_(init, end) {
  const len = init.length;
  const r = Array(len + 1);
  for (let i = 0; i < len; i++) {
    r[i] = init[i];
  }
  r[len] = end;
  return r;
}
function append(end) {
  return (init) => append_(init, end);
}
function splitAt(n) {
  return (as) => Tp.tuple(as.slice(0, n), as.slice(n));
}
function splitAt_(as, n) {
  return Tp.tuple(as.slice(0, n), as.slice(n));
}
function tail(as) {
  return isEmpty(as) ? import_Option.none : (0, import_Option.some)(as.slice(1));
}
function take(n) {
  return (as) => as.slice(0, n);
}
function take_(as, n) {
  return as.slice(0, n);
}
function takeWhile(predicate) {
  return (as) => takeWhile_(as, predicate);
}
function takeWhile_(as, predicate) {
  const i = spanIndex_(as, predicate);
  const init = Array(i);
  for (let j = 0; j < i; j++) {
    init[j] = as[j];
  }
  return init;
}
function takeRight(n) {
  return (as) => takeRight_(as, n);
}
function takeRight_(as, n) {
  return n === 0 ? empty() : as.slice(-n);
}
function toMutable(ras) {
  const l = ras.length;
  const as = Array(l);
  for (let i = 0; i < l; i++) {
    as[i] = ras[i];
  }
  return as;
}
function unfold_(b, f) {
  const ret = [];
  let bb = b;
  while (true) {
    const mt = f(bb);
    if ((0, import_Option.isSome)(mt)) {
      const [a, b2] = mt.value.tuple;
      ret.push(a);
      bb = b2;
    } else {
      break;
    }
  }
  return ret;
}
function unfold(f) {
  return (b) => unfold_(b, f);
}
function unzip(as) {
  const fa = [];
  const fb = [];
  for (let i = 0; i < as.length; i++) {
    fa[i] = as[i].get(0);
    fb[i] = as[i].get(1);
  }
  return Tp.tuple(fa, fb);
}
function zip(fb) {
  return zipWith(fb, Tp.tuple);
}
function zip_(fa, fb) {
  return zipWith_(fa, fb, Tp.tuple);
}
function zipWith_(fa, fb, f) {
  const fc = [];
  const len = Math.min(fa.length, fb.length);
  for (let i = 0; i < len; i++) {
    fc[i] = f(fa[i], fb[i]);
  }
  return fc;
}
function zipWith(fb, f) {
  return (fa) => zipWith_(fa, fb, f);
}
function from(as) {
  return Array.from(as);
}
function join_(as, s) {
  return as.join(s);
}
function join(s) {
  return (as) => as.join(s);
}
function chop(f) {
  return (as) => chop_(as, f);
}
function chop_(as, f) {
  const result = [];
  let cs = as;
  while (isNonEmpty(cs)) {
    const {
      tuple: [b, c]
    } = f(cs);
    result.push(b);
    cs = c;
  }
  return result;
}
function isOutOfBound(i, as) {
  return i < 0 || i >= as.length;
}
function spanIndex_(as, predicate) {
  const l = as.length;
  let i = 0;
  for (; i < l; i++) {
    if (!predicate(as[i])) {
      break;
    }
  }
  return i;
}
function spanLeft(predicate) {
  return (as) => spanLeft_(as, predicate);
}
function spanLeft_(as, predicate) {
  const i = spanIndex_(as, predicate);
  const init = Array(i);
  for (let j = 0; j < i; j++) {
    init[j] = as[j];
  }
  const l = as.length;
  const rest = Array(l - i);
  for (let j = i; j < l; j++) {
    rest[j - i] = as[j];
  }
  return {
    init,
    rest
  };
}
function size(as) {
  return as.length;
}
function forAll_(as, pred) {
  for (const a of as) {
    if (!pred(a)) {
      return false;
    }
  }
  return true;
}
function forAll(pred) {
  return (as) => forAll_(as, pred);
}
function forAny_(as, pred) {
  for (const a of as) {
    if (pred(a)) {
      return true;
    }
  }
  return false;
}
function forAny(pred) {
  return (as) => forAny_(as, pred);
}
function includes_(as, elem) {
  for (const a of as) {
    if (a === elem) {
      return true;
    }
  }
  return false;
}
function includes(elem) {
  return (as) => includes_(as, elem);
}
function copy(as) {
  return as.slice(0);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  append,
  append_,
  chain,
  chain_,
  chop,
  chop_,
  collect,
  collectWhile,
  collectWhile_,
  collectWithIndex,
  collectWithIndex_,
  collect_,
  compact,
  concat,
  concat_,
  copy,
  drop,
  dropRight,
  dropRight_,
  dropWhile,
  dropWhile_,
  drop_,
  empty,
  filter,
  filterWithIndex,
  filterWithIndex_,
  filter_,
  find,
  findIndex,
  findIndex_,
  findLast,
  findLastIndex,
  findLastIndex_,
  findLast_,
  find_,
  flatten,
  forAll,
  forAll_,
  forAny,
  forAny_,
  from,
  fromMutable,
  get,
  get_,
  head,
  includes,
  includes_,
  isEmpty,
  isNonEmpty,
  isOutOfBound,
  join,
  join_,
  last,
  makeBy,
  makeBy_,
  map,
  mapWithIndex,
  mapWithIndex_,
  map_,
  prepend,
  prepend_,
  range,
  reduce,
  reduceRight,
  reduceRightWithIndex,
  reduceRightWithIndex_,
  reduceRight_,
  reduceWithIndex,
  reduceWithIndex_,
  reduce_,
  replicate,
  replicate_,
  reverse,
  single,
  size,
  spanIndex_,
  spanLeft,
  spanLeft_,
  split,
  splitAt,
  splitAt_,
  split_,
  tail,
  take,
  takeRight,
  takeRight_,
  takeWhile,
  takeWhile_,
  take_,
  toMutable,
  unfold,
  unfold_,
  unzip,
  zip,
  zipWith,
  zipWith_,
  zip_
});
