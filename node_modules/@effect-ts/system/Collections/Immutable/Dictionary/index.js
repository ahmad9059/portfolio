var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Dictionary_exports = {};
__export(Dictionary_exports, {
  collect: () => collect,
  collect_: () => collect_,
  compact: () => compact,
  deleteAt: () => deleteAt,
  deleteAt_: () => deleteAt_,
  empty: () => empty,
  every: () => every,
  every_: () => every_,
  filter: () => filter,
  filterMap: () => filterMap,
  filterMapWithIndex: () => filterMapWithIndex,
  filterMapWithIndex_: () => filterMapWithIndex_,
  filterMap_: () => filterMap_,
  filterWithIndex: () => filterWithIndex,
  filterWithIndex_: () => filterWithIndex_,
  filter_: () => filter_,
  fromArray: () => fromArray,
  fromMutable: () => fromMutable,
  hasOwnProperty: () => hasOwnProperty,
  insertAt: () => insertAt,
  insertAt_: () => insertAt_,
  isEmpty: () => isEmpty,
  keys: () => keys,
  lookup: () => lookup,
  lookup_: () => lookup_,
  map: () => map,
  mapWithIndex: () => mapWithIndex,
  mapWithIndex_: () => mapWithIndex_,
  map_: () => map_,
  modifyAt: () => modifyAt,
  modifyAt_: () => modifyAt_,
  partition: () => partition,
  partitionMap: () => partitionMap,
  partitionMapWithIndex: () => partitionMapWithIndex,
  partitionMapWithIndex_: () => partitionMapWithIndex_,
  partitionMap_: () => partitionMap_,
  partitionWithIndex: () => partitionWithIndex,
  partitionWithIndex_: () => partitionWithIndex_,
  partition_: () => partition_,
  pop: () => pop,
  pop_: () => pop_,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRightWithIndex: () => reduceRightWithIndex,
  reduceRightWithIndex_: () => reduceRightWithIndex_,
  reduceRight_: () => reduceRight_,
  reduceWithIndex: () => reduceWithIndex,
  reduceWithIndex_: () => reduceWithIndex_,
  reduce_: () => reduce_,
  separate: () => separate,
  singleton: () => singleton,
  size: () => size,
  some: () => some,
  some_: () => some_,
  toArray: () => toArray,
  toMutable: () => toMutable,
  updateAt: () => updateAt,
  updateAt_: () => updateAt_,
  values: () => values
});
var import_Operator = require("../../../Operator/index.js");
var O = __toESM(require("../../../Option/index.js"));
var A = __toESM(require("../Array/index.js"));
var Tp = __toESM(require("../Tuple/index.js"));
function fromMutable(r) {
  return Object.assign({}, r);
}
function toMutable(r) {
  return Object.assign({}, r);
}
function size(r) {
  return Object.keys(r).length;
}
function isEmpty(r) {
  return Object.keys(r).length === 0;
}
function keys(r) {
  return Object.keys(r).sort();
}
function values(r) {
  return Object.keys(r).sort().map((s) => r[s]);
}
function collect(f) {
  return (r) => collect_(r, f);
}
function collect_(r, f) {
  const out = [];
  for (const key of keys(r)) {
    out.push(f(key, r[key]));
  }
  return out;
}
function insertAt(k, a) {
  return (r) => insertAt_(r, k, a);
}
function insertAt_(r, k, a) {
  if (r[k] === a) {
    return r;
  }
  const out = Object.assign({}, r);
  out[k] = a;
  return out;
}
function hasOwnProperty(r, k) {
  return Object.prototype.hasOwnProperty.call(r, k);
}
function deleteAt(k) {
  return (r) => deleteAt_(r, k);
}
function deleteAt_(r, k) {
  if (!Object.prototype.hasOwnProperty.call(r, k)) {
    return r;
  }
  const out = Object.assign({}, r);
  delete out[k];
  return out;
}
function updateAt(k, a) {
  return (r) => updateAt_(r, k, a);
}
function updateAt_(r, k, a) {
  if (!hasOwnProperty(r, k)) {
    return O.none;
  }
  if (r[k] === a) {
    return O.some(r);
  }
  const out = Object.assign({}, r);
  out[k] = a;
  return O.some(out);
}
function modifyAt(k, f) {
  return (r) => modifyAt_(r, k, f);
}
function modifyAt_(r, k, f) {
  if (!hasOwnProperty(r, k)) {
    return O.none;
  }
  const out = Object.assign({}, r);
  out[k] = f(r[k]);
  return O.some(out);
}
function pop(k) {
  return (r) => pop_(r, k);
}
function pop_(r, k) {
  const deleteAtk = deleteAt(k);
  const oa = lookup_(r, k);
  return O.isNone(oa) ? O.none : O.some(Tp.tuple(oa.value, deleteAtk(r)));
}
function lookup_(r, k) {
  return Object.prototype.hasOwnProperty.call(r, k) ? O.some(r[k]) : O.none;
}
function lookup(k) {
  return (r) => Object.prototype.hasOwnProperty.call(r, k) ? O.some(r[k]) : O.none;
}
const empty = {};
function mapWithIndex(f) {
  return (fa) => mapWithIndex_(fa, f);
}
function mapWithIndex_(fa, f) {
  const out = {};
  const keys2 = Object.keys(fa);
  for (const key of keys2) {
    out[key] = f(key, fa[key]);
  }
  return out;
}
function map(f) {
  return (fa) => map_(fa, f);
}
function map_(fa, f) {
  return mapWithIndex_(fa, (_, a) => f(a));
}
function reduceWithIndex(b, f) {
  return (fa) => reduceWithIndex_(fa, b, f);
}
function reduceWithIndex_(fa, b, f) {
  let out = b;
  const keys2 = Object.keys(fa).sort();
  const len = keys2.length;
  for (let i = 0; i < len; i++) {
    const k = keys2[i];
    out = f(k, out, fa[k]);
  }
  return out;
}
function reduceRightWithIndex(b, f) {
  return (fa) => reduceRightWithIndex_(fa, b, f);
}
function reduceRightWithIndex_(fa, b, f) {
  let out = b;
  const keys2 = Object.keys(fa).sort();
  const len = keys2.length;
  for (let i = len - 1; i >= 0; i--) {
    const k = keys2[i];
    out = f(k, fa[k], out);
  }
  return out;
}
function singleton(k, a) {
  return {
    [k]: a
  };
}
function partitionMapWithIndex(f) {
  return (fa) => partitionMapWithIndex_(fa, f);
}
function partitionMapWithIndex_(fa, f) {
  const left = {};
  const right = {};
  const keys2 = Object.keys(fa);
  for (const key of keys2) {
    const e = f(key, fa[key]);
    switch (e._tag) {
      case "Left":
        left[key] = e.left;
        break;
      case "Right":
        right[key] = e.right;
        break;
    }
  }
  return Tp.tuple(left, right);
}
function partitionWithIndex(predicateWithIndex) {
  return (fa) => partitionWithIndex_(fa, predicateWithIndex);
}
function partitionWithIndex_(fa, predicateWithIndex) {
  const left = {};
  const right = {};
  const keys2 = Object.keys(fa);
  for (const key of keys2) {
    const a = fa[key];
    if (predicateWithIndex(key, a)) {
      right[key] = a;
    } else {
      left[key] = a;
    }
  }
  return Tp.tuple(left, right);
}
function filterMapWithIndex(f) {
  return (fa) => filterMapWithIndex_(fa, f);
}
function filterMapWithIndex_(fa, f) {
  const r = {};
  const keys2 = Object.keys(fa);
  for (const key of keys2) {
    const optionB = f(key, fa[key]);
    if (O.isSome(optionB)) {
      r[key] = optionB.value;
    }
  }
  return r;
}
function filterWithIndex(predicateWithIndex) {
  return (fa) => filterWithIndex_(fa, predicateWithIndex);
}
function filterWithIndex_(fa, predicateWithIndex) {
  const out = {};
  let changed = false;
  for (const key in fa) {
    if (Object.prototype.hasOwnProperty.call(fa, key)) {
      const a = fa[key];
      if (predicateWithIndex(key, a)) {
        out[key] = a;
      } else {
        changed = true;
      }
    }
  }
  return changed ? out : fa;
}
function every(predicate) {
  return (r) => every_(r, predicate);
}
function every_(r, predicate) {
  for (const k in r) {
    if (!predicate(r[k])) {
      return false;
    }
  }
  return true;
}
function some(predicate) {
  return (r) => some_(r, predicate);
}
function some_(r, predicate) {
  for (const k in r) {
    if (predicate(r[k])) {
      return true;
    }
  }
  return false;
}
const compact = (fa) => {
  const r = {};
  const keys2 = Object.keys(fa);
  for (const key of keys2) {
    const optionA = fa[key];
    if (O.isSome(optionA)) {
      r[key] = optionA.value;
    }
  }
  return r;
};
const separate = (fa) => {
  const left = {};
  const right = {};
  const keys2 = Object.keys(fa);
  for (const key of keys2) {
    const e = fa[key];
    switch (e._tag) {
      case "Left":
        left[key] = e.left;
        break;
      case "Right":
        right[key] = e.right;
        break;
    }
  }
  return Tp.tuple(left, right);
};
const filter = (predicate) => (fa) => filter_(fa, predicate);
const filter_ = (fa, predicate) => filterWithIndex_(fa, (_, a) => predicate(a));
const filterMap = (f) => (fa) => filterMap_(fa, f);
const filterMap_ = (fa, f) => filterMapWithIndex_(fa, (_, a) => f(a));
const partition = (predicate) => (fa) => partition_(fa, predicate);
const partition_ = (fa, predicate) => partitionWithIndex_(fa, (_, a) => predicate(a));
const partitionMap = (f) => (fa) => partitionMap_(fa, f);
const partitionMap_ = (fa, f) => partitionMapWithIndex_(fa, (_, a) => f(a));
const reduce = (b, f) => (fa) => reduce_(fa, b, f);
const reduce_ = (fa, b, f) => reduceWithIndex_(fa, b, (_, b2, a) => f(b2, a));
const reduceRight = (b, f) => (fa) => reduceRight_(fa, b, f);
const reduceRight_ = (fa, b, f) => reduceRightWithIndex_(fa, b, (_, a, b2) => f(a, b2));
const toArray = /* @__PURE__ */ collect(Tp.tuple);
const fromArray = (_) => A.reduce_(_, {}, (b, {
  tuple: [k, v]
}) => Object.assign(b, {
  [k]: v
}));
module.exports = __toCommonJS(Dictionary_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  collect,
  collect_,
  compact,
  deleteAt,
  deleteAt_,
  empty,
  every,
  every_,
  filter,
  filterMap,
  filterMapWithIndex,
  filterMapWithIndex_,
  filterMap_,
  filterWithIndex,
  filterWithIndex_,
  filter_,
  fromArray,
  fromMutable,
  hasOwnProperty,
  insertAt,
  insertAt_,
  isEmpty,
  keys,
  lookup,
  lookup_,
  map,
  mapWithIndex,
  mapWithIndex_,
  map_,
  modifyAt,
  modifyAt_,
  partition,
  partitionMap,
  partitionMapWithIndex,
  partitionMapWithIndex_,
  partitionMap_,
  partitionWithIndex,
  partitionWithIndex_,
  partition_,
  pop,
  pop_,
  reduce,
  reduceRight,
  reduceRightWithIndex,
  reduceRightWithIndex_,
  reduceRight_,
  reduceWithIndex,
  reduceWithIndex_,
  reduce_,
  separate,
  singleton,
  size,
  some,
  some_,
  toArray,
  toMutable,
  updateAt,
  updateAt_,
  values
});
