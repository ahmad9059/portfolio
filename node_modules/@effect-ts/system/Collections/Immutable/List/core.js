var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  List: () => List,
  ListBuilder: () => ListBuilder,
  Node: () => Node,
  adjust: () => adjust,
  adjust_: () => adjust_,
  ap: () => ap,
  ap_: () => ap_,
  append: () => append,
  append_: () => append_,
  backwards: () => backwards,
  builder: () => builder,
  chain: () => chain,
  chain_: () => chain_,
  compact: () => compact,
  concat: () => concat,
  concat_: () => concat_,
  contains: () => contains,
  contains_: () => contains_,
  drop: () => drop,
  dropLast: () => dropLast,
  dropLast_: () => dropLast_,
  dropRepeats: () => dropRepeats,
  dropRepeatsWith: () => dropRepeatsWith,
  dropRepeatsWith_: () => dropRepeatsWith_,
  dropWhile: () => dropWhile,
  dropWhile_: () => dropWhile_,
  drop_: () => drop_,
  empty: () => empty,
  emptyPushable: () => emptyPushable,
  equals: () => equals,
  equalsWith: () => equalsWith,
  equalsWith_: () => equalsWith_,
  equals_: () => equals_,
  every: () => every,
  every_: () => every_,
  filter: () => filter,
  filterMap: () => filterMap,
  filterMap_: () => filterMap_,
  filterNot: () => filterNot,
  filterNot_: () => filterNot_,
  filter_: () => filter_,
  find: () => find,
  findIndex: () => findIndex,
  findIndex_: () => findIndex_,
  findLast: () => findLast,
  findLast_: () => findLast_,
  find_: () => find_,
  first: () => first,
  flatten: () => flatten,
  forEach: () => forEach,
  forEach_: () => forEach_,
  from: () => from,
  group: () => group,
  groupWith: () => groupWith,
  groupWith_: () => groupWith_,
  indexOf: () => indexOf,
  indexOf_: () => indexOf_,
  insert: () => insert,
  insertAll: () => insertAll,
  insertAll_: () => insertAll_,
  insert_: () => insert_,
  intersperse: () => intersperse,
  intersperse_: () => intersperse_,
  isEmpty: () => isEmpty,
  isList: () => isList,
  join: () => join,
  join_: () => join_,
  last: () => last,
  lastIndexOf: () => lastIndexOf,
  lastIndexOf_: () => lastIndexOf_,
  list: () => list,
  map: () => map,
  map_: () => map_,
  none: () => none,
  none_: () => none_,
  nth: () => nth,
  nth_: () => nth_,
  of: () => of,
  pair: () => pair,
  pair_: () => pair_,
  partition: () => partition,
  partitionMap: () => partitionMap,
  partitionMap_: () => partitionMap_,
  partition_: () => partition_,
  pluck: () => pluck,
  pluck_: () => pluck_,
  pop: () => pop,
  prepend: () => prepend,
  prepend_: () => prepend_,
  push_: () => push_,
  range: () => range,
  range_: () => range_,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRight_: () => reduceRight_,
  reduceWhile: () => reduceWhile,
  reduceWhile_: () => reduceWhile_,
  reduce_: () => reduce_,
  remove: () => remove,
  remove_: () => remove_,
  repeat: () => repeat,
  repeat_: () => repeat_,
  reverse: () => reverse,
  scan: () => scan,
  scan_: () => scan_,
  separate: () => separate,
  size: () => size,
  slice: () => slice,
  slice_: () => slice_,
  some: () => some,
  some_: () => some_,
  sortWith: () => sortWith,
  sortWith_: () => sortWith_,
  splitAt: () => splitAt,
  splitAt_: () => splitAt_,
  splitEvery: () => splitEvery,
  splitEvery_: () => splitEvery_,
  splitWhen: () => splitWhen,
  splitWhen_: () => splitWhen_,
  tail: () => tail,
  take: () => take,
  takeLast: () => takeLast,
  takeLastWhile: () => takeLastWhile,
  takeLastWhile_: () => takeLastWhile_,
  takeLast_: () => takeLast_,
  takeWhile: () => takeWhile,
  takeWhile_: () => takeWhile_,
  take_: () => take_,
  times: () => times,
  times_: () => times_,
  toArray: () => toArray,
  unsafeFind: () => unsafeFind,
  unsafeFindLast: () => unsafeFindLast,
  unsafeFindLast_: () => unsafeFindLast_,
  unsafeFind_: () => unsafeFind_,
  unsafeFirst: () => unsafeFirst,
  unsafeLast: () => unsafeLast,
  unsafeNth: () => unsafeNth,
  unsafeNth_: () => unsafeNth_,
  update: () => update,
  update_: () => update_,
  zip: () => zip,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var import_Function = require("../../../Function/index.js");
var O = __toESM(require("../../../Option/index.js"));
var St = __toESM(require("../../../Structural/index.js"));
var Tp = __toESM(require("../Tuple/index.js"));
const branchingFactor = 32;
const branchBits = 5;
const mask = 31;
function elementEquals(a, b) {
  if (a === b) {
    return true;
  } else {
    return false;
  }
}
function createPath(depth, value) {
  let current = value;
  for (let i = 0; i < depth; ++i) {
    current = new Node(void 0, [current]);
  }
  return current;
}
function copyArray(source) {
  const array = [];
  for (let i = 0; i < source.length; ++i) {
    array[i] = source[i];
  }
  return array;
}
function pushElements(source, target, offset, amount) {
  for (let i = offset; i < offset + amount; ++i) {
    target.push(source[i]);
  }
}
function copyIndices(source, sourceStart, target, targetStart, length) {
  for (let i = 0; i < length; ++i) {
    target[targetStart + i] = source[sourceStart + i];
  }
}
function arrayPrepend(value, array) {
  const newLength = array.length + 1;
  const result = new Array(newLength);
  result[0] = value;
  for (let i = 1; i < newLength; ++i) {
    result[i] = array[i - 1];
  }
  return result;
}
function reverseArray(array) {
  return array.slice().reverse();
}
function arrayFirst(array) {
  return array[0];
}
function arrayLast(array) {
  return array[array.length - 1];
}
const pathResult = {
  path: 0,
  index: 0,
  updatedOffset: 0
};
function getPath(index, offset, depth, sizes) {
  if (sizes === void 0 && offset !== 0) {
    pathResult.updatedOffset = 0;
    index = handleOffset(depth, offset, index);
  }
  let path = index >> depth * branchBits & mask;
  if (sizes !== void 0) {
    while (sizes[path] <= index) {
      path++;
    }
    const traversed = path === 0 ? 0 : sizes[path - 1];
    index -= traversed;
    pathResult.updatedOffset = offset;
  }
  pathResult.path = path;
  pathResult.index = index;
  return pathResult;
}
function updateNode(node, depth, index, offset, value) {
  const {
    index: newIndex,
    path,
    updatedOffset
  } = getPath(index, offset, depth, node.sizes);
  const array = copyArray(node.array);
  array[path] = depth > 0 ? updateNode(array[path], depth - 1, newIndex, updatedOffset, value) : value;
  return new Node(node.sizes, array);
}
class Node {
  constructor(sizes, array) {
    this.sizes = sizes;
    this.array = array;
  }
}
function cloneNode({
  array,
  sizes
}) {
  return new Node(sizes === void 0 ? void 0 : copyArray(sizes), copyArray(array));
}
const emptyAffix = [0];
const affixBits = 6;
const affixMask = 63;
function getSuffixSize(l) {
  return l.bits & affixMask;
}
function getPrefixSize(l) {
  return l.bits >> affixBits & affixMask;
}
function getDepth(l) {
  return l.bits >> affixBits * 2;
}
function setPrefix(size2, bits) {
  return size2 << affixBits | bits & ~(affixMask << affixBits);
}
function setSuffix(size2, bits) {
  return size2 | bits & ~affixMask;
}
function setDepth(depth, bits) {
  return depth << affixBits * 2 | bits & (affixMask | affixMask << affixBits);
}
function incrementPrefix(bits) {
  return bits + (1 << affixBits);
}
function incrementSuffix(bits) {
  return bits + 1;
}
function incrementDepth(bits) {
  return bits + (1 << affixBits * 2);
}
function decrementDepth(bits) {
  return bits - (1 << affixBits * 2);
}
class List {
  constructor(bits, offset, length, prefix, root, suffix) {
    this.bits = bits;
    this.offset = offset;
    this.length = length;
    this.prefix = prefix;
    this.root = root;
    this.suffix = suffix;
  }
  [Symbol.iterator]() {
    return new ForwardListIterator(this);
  }
  toJSON() {
    return toArray(this);
  }
  [St.equalsSym](that) {
    return that instanceof List && equalsWith_(this, that, St.equals);
  }
  get [St.hashSym]() {
    return St.hashIterator(this[Symbol.iterator]());
  }
}
function cloneList(l) {
  return new List(l.bits, l.offset, l.length, l.prefix, l.root, l.suffix);
}
class ListIterator {
  constructor(l, direction) {
    this.l = l;
    this.result = {
      done: false,
      value: void 0
    };
    this.idx = direction === 1 ? -1 : l.length;
    this.prefixSize = getPrefixSize(l);
    this.middleSize = l.length - getSuffixSize(l);
    if (l.root !== void 0) {
      const depth = getDepth(l);
      this.stack = new Array(depth + 1);
      this.indices = new Array(depth + 1);
      let currentNode = l.root.array;
      for (let i = depth; 0 <= i; --i) {
        this.stack[i] = currentNode;
        const idx = direction === 1 ? 0 : currentNode.length - 1;
        this.indices[i] = idx;
        currentNode = currentNode[idx].array;
      }
      this.indices[0] -= direction;
    }
  }
}
class ForwardListIterator extends ListIterator {
  constructor(l) {
    super(l, 1);
  }
  nextInTree() {
    for (var i = 0; ++this.indices[i] === this.stack[i].length; ++i) {
      this.indices[i] = 0;
    }
    for (; 0 < i; --i) {
      this.stack[i - 1] = this.stack[i][this.indices[i]].array;
    }
  }
  next() {
    let newVal;
    const idx = ++this.idx;
    if (idx < this.prefixSize) {
      newVal = this.l.prefix[this.prefixSize - idx - 1];
    } else if (idx < this.middleSize) {
      this.nextInTree();
      newVal = this.stack[0][this.indices[0]];
    } else if (idx < this.l.length) {
      newVal = this.l.suffix[idx - this.middleSize];
    } else {
      this.result.done = true;
    }
    this.result.value = newVal;
    return this.result;
  }
}
class BackwardsListIterator extends ListIterator {
  constructor(l) {
    super(l, -1);
  }
  prevInTree() {
    for (var i = 0; this.indices[i] === 0; ++i) {
    }
    --this.indices[i];
    for (; 0 < i; --i) {
      const n = this.stack[i][this.indices[i]].array;
      this.stack[i - 1] = n;
      this.indices[i - 1] = n.length - 1;
    }
  }
  next() {
    let newVal;
    const idx = --this.idx;
    if (this.middleSize <= idx) {
      newVal = this.l.suffix[idx - this.middleSize];
    } else if (this.prefixSize <= idx) {
      this.prevInTree();
      newVal = this.stack[0][this.indices[0]];
    } else if (0 <= idx) {
      newVal = this.l.prefix[this.prefixSize - idx - 1];
    } else {
      this.result.done = true;
    }
    this.result.value = newVal;
    return this.result;
  }
}
function backwards(l) {
  return {
    [Symbol.iterator]() {
      return new BackwardsListIterator(l);
    }
  };
}
function emptyPushable() {
  return new List(0, 0, 0, [], void 0, []);
}
function push_(l, value) {
  const suffixSize = getSuffixSize(l);
  if (l.length === 0) {
    l.bits = setPrefix(1, l.bits);
    l.prefix = [value];
  } else if (suffixSize < 32) {
    l.bits = incrementSuffix(l.bits);
    l.suffix.push(value);
  } else if (l.root === void 0) {
    l.root = new Node(void 0, l.suffix);
    l.suffix = [value];
    l.bits = setSuffix(1, l.bits);
  } else {
    const newNode = new Node(void 0, l.suffix);
    const index = l.length - 1 - 32 + 1;
    let current = l.root;
    let depth = getDepth(l);
    l.suffix = [value];
    l.bits = setSuffix(1, l.bits);
    if (index - 1 < branchingFactor ** (depth + 1)) {
      for (; depth >= 0; --depth) {
        const path = index >> depth * branchBits & mask;
        if (path < current.array.length) {
          current = current.array[path];
        } else {
          current.array.push(createPath(depth - 1, newNode));
          break;
        }
      }
    } else {
      l.bits = incrementDepth(l.bits);
      l.root = new Node(void 0, [l.root, createPath(depth, newNode)]);
    }
  }
  l.length++;
  return l;
}
function list(...elements) {
  const l = emptyPushable();
  for (const element of elements) {
    push_(l, element);
  }
  return l;
}
function empty() {
  return new List(0, 0, 0, emptyAffix, void 0, emptyAffix);
}
function of(a) {
  return list(a);
}
function pair(second) {
  return (first2) => pair_(first2, second);
}
function pair_(first2, second) {
  return new List(2, 0, 2, emptyAffix, void 0, [first2, second]);
}
function from(sequence) {
  const l = emptyPushable();
  if (sequence.length > 0 && (sequence[0] !== void 0 || 0 in sequence)) {
    for (let i = 0; i < sequence.length; ++i) {
      push_(l, sequence[i]);
    }
  } else if (Symbol.iterator in sequence) {
    const iterator = sequence[Symbol.iterator]();
    let cur;
    while (!(cur = iterator.next()).done) {
      push_(l, cur.value);
    }
  }
  return l;
}
function range(end) {
  return (start) => range_(start, end);
}
function range_(start, end) {
  const list2 = emptyPushable();
  for (let i = start; i < end; ++i) {
    push_(list2, i);
  }
  return list2;
}
function repeat(times2) {
  return (value) => repeat_(value, times2);
}
function repeat_(value, times2) {
  const l = emptyPushable();
  while (--times2 >= 0) {
    push_(l, value);
  }
  return l;
}
function times(times2) {
  return (func) => times_(func, times2);
}
function times_(func, times2) {
  const l = emptyPushable();
  for (let i = 0; i < times2; i++) {
    push_(l, func(i));
  }
  return l;
}
function nodeNthDense(node, depth, index) {
  let current = node;
  for (; depth >= 0; --depth) {
    current = current.array[index >> depth * branchBits & mask];
  }
  return current;
}
function handleOffset(depth, offset, index) {
  index += offset;
  for (; depth >= 0; --depth) {
    index = index - (offset & mask << depth * branchBits);
    if ((index >> depth * branchBits & mask) !== 0) {
      break;
    }
  }
  return index;
}
function nodeNth(node, depth, offset, index) {
  let path;
  let current = node;
  while (current.sizes !== void 0) {
    path = index >> depth * branchBits & mask;
    while (current.sizes[path] <= index) {
      path++;
    }
    if (path !== 0) {
      index -= current.sizes[path - 1];
      offset = 0;
    }
    depth--;
    current = current.array[path];
  }
  return nodeNthDense(current, depth, offset === 0 ? index : handleOffset(depth, offset, index));
}
function unsafeNth_(l, index) {
  return O.toUndefined(nth_(l, index));
}
function unsafeNth(index) {
  return (l) => unsafeNth_(l, index);
}
function nth_(l, index) {
  if (index < 0 || l.length <= index) {
    return O.none;
  }
  const prefixSize = getPrefixSize(l);
  const suffixSize = getSuffixSize(l);
  if (index < prefixSize) {
    return O.some(l.prefix[prefixSize - index - 1]);
  } else if (index >= l.length - suffixSize) {
    return O.some(l.suffix[index - (l.length - suffixSize)]);
  }
  const {
    offset
  } = l;
  const depth = getDepth(l);
  return O.some(l.root.sizes === void 0 ? nodeNthDense(l.root, depth, offset === 0 ? index - prefixSize : handleOffset(depth, offset, index - prefixSize)) : nodeNth(l.root, depth, offset, index - prefixSize));
}
function nth(index) {
  return (l) => nth_(l, index);
}
function setSizes(node, height) {
  let sum = 0;
  const sizeTable = [];
  for (let i = 0; i < node.array.length; ++i) {
    sum += sizeOfSubtree(node.array[i], height - 1);
    sizeTable[i] = sum;
  }
  node.sizes = sizeTable;
  return node;
}
function sizeOfSubtree(node, height) {
  if (height !== 0) {
    if (node.sizes !== void 0) {
      return arrayLast(node.sizes);
    } else {
      const lastSize = sizeOfSubtree(arrayLast(node.array), height - 1);
      return (node.array.length - 1 << height * branchBits) + lastSize;
    }
  } else {
    return node.array.length;
  }
}
function affixPush(a, array, length) {
  if (array.length === length) {
    array.push(a);
    return array;
  } else {
    const newArray = [];
    copyIndices(array, 0, newArray, 0, length);
    newArray.push(a);
    return newArray;
  }
}
function prepend_(l, value) {
  const prefixSize = getPrefixSize(l);
  if (prefixSize < 32) {
    return new List(incrementPrefix(l.bits), l.offset, l.length + 1, affixPush(value, l.prefix, prefixSize), l.root, l.suffix);
  } else {
    const newList = cloneList(l);
    prependNodeToTree(newList, reverseArray(l.prefix));
    const newPrefix = [value];
    newList.prefix = newPrefix;
    newList.length++;
    newList.bits = setPrefix(1, newList.bits);
    return newList;
  }
}
function prepend(value) {
  return (l) => prepend_(l, value);
}
function copyLeft(l, k) {
  let currentNode = cloneNode(l.root);
  l.root = currentNode;
  for (let i = 1; i < k; ++i) {
    const index = 0;
    if (currentNode.sizes !== void 0) {
      for (let i2 = 0; i2 < currentNode.sizes.length; ++i2) {
        currentNode.sizes[i2] += 32;
      }
    }
    const newNode = cloneNode(currentNode.array[index]);
    currentNode.array[index] = newNode;
    currentNode = newNode;
  }
  return currentNode;
}
function nodePrepend(value, size2, node) {
  const array = arrayPrepend(value, node.array);
  let sizes = void 0;
  if (node.sizes !== void 0) {
    sizes = new Array(node.sizes.length + 1);
    sizes[0] = size2;
    for (let i = 0; i < node.sizes.length; ++i) {
      sizes[i + 1] = node.sizes[i] + size2;
    }
  }
  return new Node(sizes, array);
}
function prependTopTree(l, depth, node) {
  let newOffset2;
  if (l.root.array.length < branchingFactor) {
    newOffset2 = 32 ** depth - 32;
    l.root = new Node(void 0, arrayPrepend(createPath(depth - 1, node), l.root.array));
  } else {
    l.bits = incrementDepth(l.bits);
    const sizes = l.root.sizes === void 0 ? void 0 : [32, arrayLast(l.root.sizes) + 32];
    newOffset2 = depth === 0 ? 0 : 32 ** (depth + 1) - 32;
    l.root = new Node(sizes, [createPath(depth, node), l.root]);
  }
  return newOffset2;
}
function prependNodeToTree(l, array) {
  if (l.root === void 0) {
    if (getSuffixSize(l) === 0) {
      l.bits = setSuffix(array.length, l.bits);
      l.suffix = array;
    } else {
      l.root = new Node(void 0, array);
    }
    return l;
  } else {
    const node = new Node(void 0, array);
    const depth = getDepth(l);
    let newOffset2 = 0;
    if (l.root.sizes === void 0) {
      if (l.offset !== 0) {
        newOffset2 = l.offset - branchingFactor;
        l.root = prependDense(l.root, depth, l.offset, node);
      } else {
        newOffset2 = prependTopTree(l, depth, node);
      }
    } else {
      let copyableCount = 0;
      let nodesTraversed = 0;
      let currentNode = l.root;
      while (currentNode.sizes !== void 0 && nodesTraversed < depth) {
        ++nodesTraversed;
        if (currentNode.array.length < 32) {
          copyableCount = nodesTraversed;
        }
        currentNode = currentNode.array[0];
      }
      if (l.offset !== 0) {
        const copiedNode = copyLeft(l, nodesTraversed);
        for (let i = 0; i < copiedNode.sizes.length; ++i) {
          copiedNode.sizes[i] += branchingFactor;
        }
        copiedNode.array[0] = prependDense(copiedNode.array[0], depth - nodesTraversed, l.offset, node);
        l.offset = l.offset - branchingFactor;
        return l;
      } else {
        if (copyableCount === 0) {
          l.offset = prependTopTree(l, depth, node);
        } else {
          let parent;
          let prependableNode;
          if (copyableCount > 1) {
            parent = copyLeft(l, copyableCount - 1);
            prependableNode = parent.array[0];
          } else {
            parent = void 0;
            prependableNode = l.root;
          }
          const path = createPath(depth - copyableCount, node);
          l.offset = 32 ** (depth - copyableCount + 1) - 32;
          const prepended = nodePrepend(path, 32, prependableNode);
          if (parent === void 0) {
            l.root = prepended;
          } else {
            parent.array[0] = prepended;
          }
        }
        return l;
      }
    }
    l.offset = newOffset2;
    return l;
  }
}
function prependDense(node, depth, offset, value) {
  const curOffset = offset >> depth * branchBits & mask;
  const path = (offset - 1 >> depth * branchBits & mask) - curOffset;
  if (path < 0) {
    return new Node(void 0, arrayPrepend(createPath(depth - 1, value), node.array));
  } else {
    const array = copyArray(node.array);
    array[0] = prependDense(array[0], depth - 1, offset, value);
    return new Node(void 0, array);
  }
}
function append_(l, value) {
  const suffixSize = getSuffixSize(l);
  if (suffixSize < 32) {
    return new List(incrementSuffix(l.bits), l.offset, l.length + 1, l.prefix, l.root, affixPush(value, l.suffix, suffixSize));
  }
  const newSuffix = [value];
  const newList = cloneList(l);
  appendNodeToTree(newList, l.suffix);
  newList.suffix = newSuffix;
  newList.length++;
  newList.bits = setSuffix(1, newList.bits);
  return newList;
}
function append(value) {
  return (l) => append_(l, value);
}
function size(l) {
  return l.length;
}
function unsafeFirst(l) {
  return O.toUndefined(first(l));
}
function first(l) {
  const prefixSize = getPrefixSize(l);
  return prefixSize !== 0 ? O.some(l.prefix[prefixSize - 1]) : l.length !== 0 ? O.some(l.suffix[0]) : O.none;
}
function unsafeLast(l) {
  return O.toUndefined(last(l));
}
function last(l) {
  const suffixSize = getSuffixSize(l);
  return suffixSize !== 0 ? O.some(l.suffix[suffixSize - 1]) : l.length !== 0 ? O.some(l.prefix[0]) : O.none;
}
function mapArray(f, array) {
  const result = new Array(array.length);
  for (let i = 0; i < array.length; ++i) {
    result[i] = f(array[i]);
  }
  return result;
}
function mapNode(f, node, depth) {
  if (depth !== 0) {
    const {
      array
    } = node;
    const result = new Array(array.length);
    for (let i = 0; i < array.length; ++i) {
      result[i] = mapNode(f, array[i], depth - 1);
    }
    return new Node(node.sizes, result);
  } else {
    return new Node(void 0, mapArray(f, node.array));
  }
}
function mapPrefix(f, prefix, length) {
  const newPrefix = new Array(length);
  for (let i = length - 1; 0 <= i; --i) {
    newPrefix[i] = f(prefix[i]);
  }
  return newPrefix;
}
function mapAffix(f, suffix, length) {
  const newSuffix = new Array(length);
  for (let i = 0; i < length; ++i) {
    newSuffix[i] = f(suffix[i]);
  }
  return newSuffix;
}
function map_(l, f) {
  return new List(l.bits, l.offset, l.length, mapPrefix(f, l.prefix, getPrefixSize(l)), l.root === void 0 ? void 0 : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)));
}
function map(f) {
  return (l) => new List(l.bits, l.offset, l.length, mapPrefix(f, l.prefix, getPrefixSize(l)), l.root === void 0 ? void 0 : mapNode(f, l.root, getDepth(l)), mapAffix(f, l.suffix, getSuffixSize(l)));
}
function pluck_(l, key) {
  return map_(l, (a) => a[key]);
}
function pluck(key) {
  return (l) => pluck_(l, key);
}
function foldlSuffix(f, acc, array, length) {
  for (let i = 0; i < length; ++i) {
    acc = f(acc, array[i]);
  }
  return acc;
}
function foldlPrefix(f, acc, array, length) {
  for (let i = length - 1; 0 <= i; --i) {
    acc = f(acc, array[i]);
  }
  return acc;
}
function foldlNode(f, acc, node, depth) {
  const {
    array
  } = node;
  if (depth === 0) {
    return foldlSuffix(f, acc, array, array.length);
  }
  for (let i = 0; i < array.length; ++i) {
    acc = foldlNode(f, acc, array[i], depth - 1);
  }
  return acc;
}
function reduce_(l, initial, f) {
  const suffixSize = getSuffixSize(l);
  const prefixSize = getPrefixSize(l);
  initial = foldlPrefix(f, initial, l.prefix, prefixSize);
  if (l.root !== void 0) {
    initial = foldlNode(f, initial, l.root, getDepth(l));
  }
  return foldlSuffix(f, initial, l.suffix, suffixSize);
}
function reduce(initial, f) {
  return (l) => reduce_(l, initial, f);
}
function scan_(l, initial, f) {
  return reduce_(l, push_(emptyPushable(), initial), (l2, a) => push_(l2, f(unsafeLast(l2), a)));
}
function scan(initial, f) {
  return (l) => scan_(l, initial, f);
}
function forEach_(l, callback) {
  reduce_(l, void 0, (_, element) => callback(element));
}
function forEach(callback) {
  return (l) => forEach_(l, callback);
}
function filter_(l, predicate) {
  return reduce_(l, emptyPushable(), (acc, a) => predicate(a) ? push_(acc, a) : acc);
}
function filter(predicate) {
  return (l) => reduce_(l, emptyPushable(), (acc, a) => predicate(a) ? push_(acc, a) : acc);
}
function filterMap_(l, f) {
  return reduce_(l, emptyPushable(), (acc, a) => {
    const fa = f(a);
    if (fa._tag === "Some") {
      push_(acc, fa.value);
    }
    return acc;
  });
}
function filterMap(f) {
  return (l) => filterMap_(l, f);
}
function compact(fa) {
  return filterMap((x) => x)(fa);
}
function filterNot_(l, predicate) {
  return reduce_(l, emptyPushable(), (acc, a) => predicate(a) ? acc : push_(acc, a));
}
function filterNot(predicate) {
  return (l) => filterNot_(l, predicate);
}
function partition_(l, predicate) {
  return reduce_(l, Tp.tuple(emptyPushable(), emptyPushable()), (arr, a) => (predicate(a) ? push_(arr.get(0), a) : push_(arr.get(1), a), arr));
}
function partition(predicate) {
  return (l) => partition_(l, predicate);
}
function partitionMap_(l, f) {
  return reduce_(l, Tp.tuple(emptyPushable(), emptyPushable()), (arr, a) => {
    const fa = f(a);
    if (fa._tag === "Left") {
      push_(arr.get(0), fa.left);
    } else {
      push_(arr.get(1), fa.right);
    }
    return arr;
  });
}
function partitionMap(f) {
  return (l) => partitionMap_(l, f);
}
function separate(l) {
  return partitionMap_(l, import_Function.identity);
}
function join_(l, separator) {
  return reduce_(l, "", (a, b) => a.length === 0 ? b : a + separator + b);
}
function join(separator) {
  return (l) => join_(l, separator);
}
function foldrSuffix(f, initial, array, length) {
  let acc = initial;
  for (let i = length - 1; 0 <= i; --i) {
    acc = f(array[i], acc);
  }
  return acc;
}
function foldrPrefix(f, initial, array, length) {
  let acc = initial;
  for (let i = 0; i < length; ++i) {
    acc = f(array[i], acc);
  }
  return acc;
}
function foldrNode(f, initial, {
  array
}, depth) {
  if (depth === 0) {
    return foldrSuffix(f, initial, array, array.length);
  }
  let acc = initial;
  for (let i = array.length - 1; 0 <= i; --i) {
    acc = foldrNode(f, acc, array[i], depth - 1);
  }
  return acc;
}
function reduceRight_(l, initial, f) {
  const suffixSize = getSuffixSize(l);
  const prefixSize = getPrefixSize(l);
  let acc = foldrSuffix(f, initial, l.suffix, suffixSize);
  if (l.root !== void 0) {
    acc = foldrNode(f, acc, l.root, getDepth(l));
  }
  return foldrPrefix(f, acc, l.prefix, prefixSize);
}
function reduceRight(initial, f) {
  return (l) => reduceRight_(l, initial, f);
}
function ap_(listF, l) {
  return flatten(map_(listF, (f) => map_(l, f)));
}
function ap(l) {
  return (listF) => ap_(listF, l);
}
function flatten(nested) {
  return reduce_(nested, empty(), concat_);
}
function chain_(l, f) {
  return flatten(map_(l, f));
}
function chain(f) {
  return (l) => chain_(l, f);
}
function foldlArrayCb(cb, state, array, from2, to) {
  for (var i = from2; i < to && cb(array[i], state); ++i) {
  }
  return i === to;
}
function foldrArrayCb(cb, state, array, from2, to) {
  for (var i = from2 - 1; to <= i && cb(array[i], state); --i) {
  }
  return i === to - 1;
}
function foldlNodeCb(cb, state, node, depth) {
  const {
    array
  } = node;
  if (depth === 0) {
    return foldlArrayCb(cb, state, array, 0, array.length);
  }
  const to = array.length;
  for (let i = 0; i < to; ++i) {
    if (!foldlNodeCb(cb, state, array[i], depth - 1)) {
      return false;
    }
  }
  return true;
}
function foldlCb(cb, state, l) {
  const prefixSize = getPrefixSize(l);
  if (!foldrArrayCb(cb, state, l.prefix, prefixSize, 0) || l.root !== void 0 && !foldlNodeCb(cb, state, l.root, getDepth(l))) {
    return state;
  }
  const suffixSize = getSuffixSize(l);
  foldlArrayCb(cb, state, l.suffix, 0, suffixSize);
  return state;
}
function foldrNodeCb(cb, state, node, depth) {
  const {
    array
  } = node;
  if (depth === 0) {
    return foldrArrayCb(cb, state, array, array.length, 0);
  }
  for (let i = array.length - 1; 0 <= i; --i) {
    if (!foldrNodeCb(cb, state, array[i], depth - 1)) {
      return false;
    }
  }
  return true;
}
function foldrCb(cb, state, l) {
  const suffixSize = getSuffixSize(l);
  const prefixSize = getPrefixSize(l);
  if (!foldrArrayCb(cb, state, l.suffix, suffixSize, 0) || l.root !== void 0 && !foldrNodeCb(cb, state, l.root, getDepth(l))) {
    return state;
  }
  const prefix = l.prefix;
  foldlArrayCb(cb, state, l.prefix, prefix.length - prefixSize, prefix.length);
  return state;
}
function foldlWhileCb(a, state) {
  if (state.predicate(state.result, a) === false) {
    return false;
  }
  state.result = state.f(state.result, a);
  return true;
}
function reduceWhile_(l, initial, predicate, f) {
  return foldlCb(foldlWhileCb, {
    predicate,
    f,
    result: initial
  }, l).result;
}
function reduceWhile(initial, predicate, f) {
  return (l) => reduceWhile_(l, initial, predicate, f);
}
function everyCb(value, state) {
  return state.result = state.predicate(value);
}
function every_(l, predicate) {
  return foldlCb(everyCb, {
    predicate,
    result: true
  }, l).result;
}
function every(predicate) {
  return (l) => every_(l, predicate);
}
function someCb(value, state) {
  return !(state.result = state.predicate(value));
}
function some_(l, predicate) {
  return foldlCb(someCb, {
    predicate,
    result: false
  }, l).result;
}
function some(predicate) {
  return (l) => some_(l, predicate);
}
function none_(l, predicate) {
  return !some_(l, predicate);
}
function none(predicate) {
  return (l) => none_(l, predicate);
}
function findCb(value, state) {
  if (state.predicate(value)) {
    state.result = O.some(value);
    return false;
  } else {
    return true;
  }
}
function unsafeFind_(l, predicate) {
  return O.toUndefined(find_(l, predicate));
}
function unsafeFind(predicate) {
  return (l) => unsafeFind_(l, predicate);
}
function find_(l, predicate) {
  return foldlCb(findCb, {
    predicate,
    result: O.none
  }, l).result;
}
function find(predicate) {
  return (l) => find_(l, predicate);
}
function unsafeFindLast_(l, predicate) {
  return O.toUndefined(findLast_(l, predicate));
}
function unsafeFindLast(predicate) {
  return (l) => unsafeFindLast_(l, predicate);
}
function findLast_(l, predicate) {
  return foldrCb(findCb, {
    predicate,
    result: O.none
  }, l).result;
}
function findLast(predicate) {
  return (l) => findLast_(l, predicate);
}
function indexOfCb(value, state) {
  ++state.index;
  return !(state.found = elementEquals(value, state.element));
}
function indexOf_(l, element) {
  const state = {
    element,
    found: false,
    index: -1
  };
  foldlCb(indexOfCb, state, l);
  return state.found ? state.index : -1;
}
function indexOf(element) {
  return (l) => indexOf_(l, element);
}
function lastIndexOf_(l, element) {
  const state = {
    element,
    found: false,
    index: 0
  };
  foldrCb(indexOfCb, state, l);
  return state.found ? l.length - state.index : -1;
}
function lastIndexOf(element) {
  return (l) => lastIndexOf_(l, element);
}
function findIndexCb(value, state) {
  ++state.index;
  return !(state.found = state.predicate(value));
}
function findIndex_(l, predicate) {
  const {
    found,
    index
  } = foldlCb(findIndexCb, {
    predicate,
    found: false,
    index: -1
  }, l);
  return found ? index : -1;
}
function findIndex(predicate) {
  return (l) => findIndex_(l, predicate);
}
const containsState = {
  element: void 0,
  result: false
};
function containsCb(value, state) {
  return !(state.result = value === state.element);
}
function contains_(l, element) {
  containsState.element = element;
  containsState.result = false;
  return foldlCb(containsCb, containsState, l).result;
}
function contains(element) {
  return (l) => contains_(l, element);
}
function equalsCb(value2, state) {
  const {
    value
  } = state.iterator.next();
  return state.equals = state.f(value, value2);
}
function equals_(l1, l2) {
  return equalsWith_(l1, l2, elementEquals);
}
function equals(l2) {
  return (l1) => equals_(l1, l2);
}
function equalsWith_(l1, l2, f) {
  if (l1 === l2) {
    return true;
  } else if (l1.length !== l2.length) {
    return false;
  } else {
    const s = {
      iterator: l2[Symbol.iterator](),
      equals: true,
      f
    };
    return foldlCb(equalsCb, s, l1).equals;
  }
}
function equalsWith(l2, f) {
  return (l1) => equalsWith_(l1, l2, f);
}
const eMax = 2;
function createConcatPlan(array) {
  const sizes = [];
  let sum = 0;
  for (let i2 = 0; i2 < array.length; ++i2) {
    sum += array[i2].array.length;
    sizes[i2] = array[i2].array.length;
  }
  const optimalLength = Math.ceil(sum / branchingFactor);
  let n = array.length;
  let i = 0;
  if (optimalLength + eMax >= n) {
    return void 0;
  }
  while (optimalLength + eMax < n) {
    while (sizes[i] > branchingFactor - eMax / 2) {
      ++i;
    }
    let remaining = sizes[i];
    do {
      const size2 = Math.min(remaining + sizes[i + 1], branchingFactor);
      sizes[i] = size2;
      remaining = remaining - (size2 - sizes[i + 1]);
      ++i;
    } while (remaining > 0);
    for (let j = i; j <= n - 1; ++j) {
      sizes[j] = sizes[j + 1];
    }
    --i;
    --n;
  }
  sizes.length = n;
  return sizes;
}
function concatNodeMerge(left, center, right) {
  const array = [];
  if (left !== void 0) {
    for (let i = 0; i < left.array.length - 1; ++i) {
      array.push(left.array[i]);
    }
  }
  for (let i = 0; i < center.array.length; ++i) {
    array.push(center.array[i]);
  }
  if (right !== void 0) {
    for (let i = 1; i < right.array.length; ++i) {
      array.push(right.array[i]);
    }
  }
  return array;
}
function executeConcatPlan(merged, plan, height) {
  const result = [];
  let sourceIdx = 0;
  let offset = 0;
  for (let toMove of plan) {
    let source = merged[sourceIdx].array;
    if (toMove === source.length && offset === 0) {
      result.push(merged[sourceIdx]);
      ++sourceIdx;
    } else {
      const node = new Node(void 0, []);
      while (toMove > 0) {
        const available = source.length - offset;
        const itemsToCopy = Math.min(toMove, available);
        pushElements(source, node.array, offset, itemsToCopy);
        if (toMove >= available) {
          ++sourceIdx;
          source = merged[sourceIdx].array;
          offset = 0;
        } else {
          offset += itemsToCopy;
        }
        toMove -= itemsToCopy;
      }
      if (height > 1) {
        setSizes(node, height - 1);
      }
      result.push(node);
    }
  }
  return result;
}
function rebalance(left, center, right, height, top) {
  const merged = concatNodeMerge(left, center, right);
  const plan = createConcatPlan(merged);
  const balanced = plan !== void 0 ? executeConcatPlan(merged, plan, height) : merged;
  if (balanced.length <= branchingFactor) {
    if (top === true) {
      return new Node(void 0, balanced);
    } else {
      return new Node(void 0, [setSizes(new Node(void 0, balanced), height)]);
    }
  } else {
    return new Node(void 0, [setSizes(new Node(void 0, balanced.slice(0, branchingFactor)), height), setSizes(new Node(void 0, balanced.slice(branchingFactor)), height)]);
  }
}
function concatSubTree(left, lDepth, right, rDepth, isTop) {
  if (lDepth > rDepth) {
    const c = concatSubTree(arrayLast(left.array), lDepth - 1, right, rDepth, false);
    return rebalance(left, c, void 0, lDepth, isTop);
  } else if (lDepth < rDepth) {
    const c = concatSubTree(left, lDepth, arrayFirst(right.array), rDepth - 1, false);
    return rebalance(void 0, c, right, rDepth, isTop);
  } else if (lDepth === 0) {
    return new Node(void 0, [left, right]);
  } else {
    const c = concatSubTree(arrayLast(left.array), lDepth - 1, arrayFirst(right.array), rDepth - 1, false);
    return rebalance(left, c, right, lDepth, isTop);
  }
}
function getHeight(node) {
  if (node.array[0] instanceof Node) {
    return 1 + getHeight(node.array[0]);
  } else {
    return 0;
  }
}
function appendNodeToTree(l, array) {
  if (l.root === void 0) {
    if (getPrefixSize(l) === 0) {
      l.bits = setPrefix(array.length, l.bits);
      l.prefix = reverseArray(array);
    } else {
      l.root = new Node(void 0, array);
    }
    return l;
  }
  const depth = getDepth(l);
  let index = handleOffset(depth, l.offset, l.length - 1 - getPrefixSize(l));
  let nodesToCopy = 0;
  let nodesVisited = 0;
  let shift = depth * 5;
  let currentNode = l.root;
  if (32 ** (depth + 1) < index) {
    shift = 0;
    nodesVisited = depth;
  }
  while (shift > 5) {
    let childIndex;
    if (currentNode.sizes === void 0) {
      childIndex = index >> shift & mask;
      index &= ~(mask << shift);
    } else {
      childIndex = currentNode.array.length - 1;
      index -= currentNode.sizes[childIndex - 1];
    }
    nodesVisited++;
    if (childIndex < mask) {
      nodesToCopy = nodesVisited;
    }
    currentNode = currentNode.array[childIndex];
    if (currentNode === void 0) {
      nodesToCopy = nodesVisited;
      shift = 5;
    }
    shift -= 5;
  }
  if (shift !== 0) {
    nodesVisited++;
    if (currentNode.array.length < branchingFactor) {
      nodesToCopy = nodesVisited;
    }
  }
  const node = new Node(void 0, array);
  if (nodesToCopy === 0) {
    const newPath = nodesVisited === 0 ? node : createPath(nodesVisited, node);
    const newRoot = new Node(void 0, [l.root, newPath]);
    l.root = newRoot;
    l.bits = incrementDepth(l.bits);
  } else {
    const copiedNode = copyFirstK(l, nodesToCopy, array.length);
    copiedNode.array.push(createPath(depth - nodesToCopy, node));
  }
  return l;
}
function copyFirstK(newList, k, leafSize) {
  let currentNode = cloneNode(newList.root);
  newList.root = currentNode;
  for (let i = 1; i < k; ++i) {
    const index = currentNode.array.length - 1;
    if (currentNode.sizes !== void 0) {
      currentNode.sizes[index] += leafSize;
    }
    const newNode = cloneNode(currentNode.array[index]);
    currentNode.array[index] = newNode;
    currentNode = newNode;
  }
  if (currentNode.sizes !== void 0) {
    currentNode.sizes.push(arrayLast(currentNode.sizes) + leafSize);
  }
  return currentNode;
}
const concatBuffer = /* @__PURE__ */ new Array(3);
function concatAffixes(left, right) {
  let nr = 0;
  let arrIdx = 0;
  let i = 0;
  let length = getSuffixSize(left);
  concatBuffer[nr] = [];
  for (i = 0; i < length; ++i) {
    concatBuffer[nr][arrIdx++] = left.suffix[i];
  }
  length = getPrefixSize(right);
  for (i = 0; i < length; ++i) {
    if (arrIdx === 32) {
      arrIdx = 0;
      ++nr;
      concatBuffer[nr] = [];
    }
    concatBuffer[nr][arrIdx++] = right.prefix[length - 1 - i];
  }
  length = getSuffixSize(right);
  for (i = 0; i < length; ++i) {
    if (arrIdx === 32) {
      arrIdx = 0;
      ++nr;
      concatBuffer[nr] = [];
    }
    concatBuffer[nr][arrIdx++] = right.suffix[i];
  }
  return nr;
}
function concat_(left, right) {
  if (left.length === 0) {
    return right;
  } else if (right.length === 0) {
    return left;
  }
  const newSize = left.length + right.length;
  const rightSuffixSize = getSuffixSize(right);
  let newList = cloneList(left);
  if (right.root === void 0) {
    const nrOfAffixes = concatAffixes(left, right);
    for (let i = 0; i < nrOfAffixes; ++i) {
      newList = appendNodeToTree(newList, concatBuffer[i]);
      newList.length += concatBuffer[i].length;
      concatBuffer[i] = void 0;
    }
    newList.length = newSize;
    newList.suffix = concatBuffer[nrOfAffixes];
    newList.bits = setSuffix(concatBuffer[nrOfAffixes].length, newList.bits);
    concatBuffer[nrOfAffixes] = void 0;
    return newList;
  } else {
    const leftSuffixSize = getSuffixSize(left);
    if (leftSuffixSize > 0) {
      newList = appendNodeToTree(newList, left.suffix.slice(0, leftSuffixSize));
      newList.length += leftSuffixSize;
    }
    newList = appendNodeToTree(newList, right.prefix.slice(0, getPrefixSize(right)).reverse());
    const newNode = concatSubTree(newList.root, getDepth(newList), right.root, getDepth(right), true);
    const newDepth = getHeight(newNode);
    setSizes(newNode, newDepth);
    newList.root = newNode;
    newList.offset &= ~(mask << getDepth(left) * branchBits);
    newList.length = newSize;
    newList.bits = setSuffix(rightSuffixSize, setDepth(newDepth, newList.bits));
    newList.suffix = right.suffix;
    return newList;
  }
}
function concat(right) {
  return (left) => concat_(left, right);
}
function update_(l, index, a) {
  if (index < 0 || l.length <= index) {
    return l;
  }
  const prefixSize = getPrefixSize(l);
  const suffixSize = getSuffixSize(l);
  const newList = cloneList(l);
  if (index < prefixSize) {
    const newPrefix = copyArray(newList.prefix);
    newPrefix[newPrefix.length - index - 1] = a;
    newList.prefix = newPrefix;
  } else if (index >= l.length - suffixSize) {
    const newSuffix = copyArray(newList.suffix);
    newSuffix[index - (l.length - suffixSize)] = a;
    newList.suffix = newSuffix;
  } else {
    newList.root = updateNode(l.root, getDepth(l), index - prefixSize, l.offset, a);
  }
  return newList;
}
function update(index, a) {
  return (l) => update_(l, index, a);
}
function adjust_(l, index, f) {
  if (index < 0 || l.length <= index) {
    return l;
  }
  return update_(l, index, f(unsafeNth_(l, index)));
}
function adjust(index, f) {
  return (l) => adjust_(l, index, f);
}
let newAffix;
function sliceNode(node, index, depth, pathLeft, pathRight, childLeft, childRight) {
  const array = node.array.slice(pathLeft, pathRight + 1);
  if (childLeft !== void 0) {
    array[0] = childLeft;
  }
  if (childRight !== void 0) {
    array[array.length - 1] = childRight;
  }
  let sizes = node.sizes;
  if (sizes !== void 0) {
    sizes = sizes.slice(pathLeft, pathRight + 1);
    let slicedOffLeft = pathLeft !== 0 ? node.sizes[pathLeft - 1] : 0;
    if (childLeft !== void 0) {
      if (childLeft.sizes !== void 0) {
        const oldChild = node.array[pathLeft];
        slicedOffLeft += arrayLast(oldChild.sizes) - arrayLast(childLeft.sizes);
      } else {
        slicedOffLeft += (index - slicedOffLeft & ~31) + 32;
      }
    }
    for (let i = 0; i < sizes.length; ++i) {
      sizes[i] -= slicedOffLeft;
    }
    if (childRight !== void 0) {
      const slicedOffRight = sizeOfSubtree(node.array[pathRight], depth - 1) - sizeOfSubtree(childRight, depth - 1);
      sizes[sizes.length - 1] -= slicedOffRight;
    }
  }
  return new Node(sizes, array);
}
let newOffset = 0;
function sliceLeft(tree, depth, index, offset, top) {
  let {
    index: newIndex,
    path,
    updatedOffset
  } = getPath(index, offset, depth, tree.sizes);
  if (depth === 0) {
    newAffix = tree.array.slice(path).reverse();
    return void 0;
  } else {
    const child = sliceLeft(tree.array[path], depth - 1, newIndex, updatedOffset, false);
    if (child === void 0) {
      ++path;
      if (path === tree.array.length) {
        return void 0;
      }
    }
    if (tree.sizes === void 0 && top === false) {
      newOffset |= 32 - (tree.array.length - path) << depth * branchBits;
    }
    return sliceNode(tree, index, depth, path, tree.array.length - 1, child, void 0);
  }
}
function sliceRight(node, depth, index, offset) {
  let {
    index: newIndex,
    path
  } = getPath(index, offset, depth, node.sizes);
  if (depth === 0) {
    newAffix = node.array.slice(0, path + 1);
    return void 0;
  } else {
    const child = sliceRight(node.array[path], depth - 1, newIndex, path === 0 ? offset : 0);
    if (child === void 0) {
      --path;
      if (path === -1) {
        return void 0;
      }
    }
    const array = node.array.slice(0, path + 1);
    if (child !== void 0) {
      array[array.length - 1] = child;
    }
    let sizes = node.sizes;
    if (sizes !== void 0) {
      sizes = sizes.slice(0, path + 1);
      if (child !== void 0) {
        const slicedOff = sizeOfSubtree(node.array[path], depth - 1) - sizeOfSubtree(child, depth - 1);
        sizes[sizes.length - 1] -= slicedOff;
      }
    }
    return new Node(sizes, array);
  }
}
function sliceTreeList(from2, to, tree, depth, offset, l) {
  const sizes = tree.sizes;
  let {
    index: newFrom,
    path: pathLeft
  } = getPath(from2, offset, depth, sizes);
  let {
    index: newTo,
    path: pathRight
  } = getPath(to, offset, depth, sizes);
  if (depth === 0) {
    l.prefix = emptyAffix;
    l.suffix = tree.array.slice(pathLeft, pathRight + 1);
    l.root = void 0;
    l.bits = setSuffix(pathRight - pathLeft + 1, 0);
    return l;
  } else if (pathLeft === pathRight) {
    l.bits = decrementDepth(l.bits);
    return sliceTreeList(newFrom, newTo, tree.array[pathLeft], depth - 1, pathLeft === 0 ? offset : 0, l);
  } else {
    const childRight = sliceRight(tree.array[pathRight], depth - 1, newTo, 0);
    l.bits = setSuffix(newAffix.length, l.bits);
    l.suffix = newAffix;
    if (childRight === void 0) {
      --pathRight;
    }
    newOffset = 0;
    const childLeft = sliceLeft(tree.array[pathLeft], depth - 1, newFrom, pathLeft === 0 ? offset : 0, pathLeft === pathRight);
    l.offset = newOffset;
    l.bits = setPrefix(newAffix.length, l.bits);
    l.prefix = newAffix;
    if (childLeft === void 0) {
      ++pathLeft;
    }
    if (pathLeft >= pathRight) {
      if (pathLeft > pathRight) {
        l.bits = setDepth(0, l.bits);
        l.root = void 0;
      } else {
        l.bits = decrementDepth(l.bits);
        const newRoot = childRight !== void 0 ? childRight : childLeft !== void 0 ? childLeft : tree.array[pathLeft];
        l.root = new Node(newRoot.sizes, newRoot.array);
      }
    } else {
      l.root = sliceNode(tree, from2, depth, pathLeft, pathRight, childLeft, childRight);
    }
    return l;
  }
}
function slice_(l, from2, to) {
  let {
    bits,
    length
  } = l;
  to = Math.min(length, to);
  if (from2 < 0) {
    from2 = length + from2;
  }
  if (to < 0) {
    to = length + to;
  }
  if (to <= from2 || to <= 0 || length <= from2) {
    return empty();
  }
  if (from2 <= 0 && length <= to) {
    return l;
  }
  const newLength = to - from2;
  let prefixSize = getPrefixSize(l);
  const suffixSize = getSuffixSize(l);
  if (to <= prefixSize) {
    return new List(setPrefix(newLength, 0), 0, newLength, l.prefix.slice(prefixSize - to, prefixSize - from2), void 0, emptyAffix);
  }
  const suffixStart = length - suffixSize;
  if (suffixStart <= from2) {
    return new List(setSuffix(newLength, 0), 0, newLength, emptyAffix, void 0, l.suffix.slice(from2 - suffixStart, to - suffixStart));
  }
  const newList = cloneList(l);
  newList.length = newLength;
  if (prefixSize <= from2 && to <= suffixStart) {
    sliceTreeList(from2 - prefixSize + l.offset, to - prefixSize + l.offset - 1, l.root, getDepth(l), l.offset, newList);
    return newList;
  }
  if (0 < from2) {
    if (from2 < prefixSize) {
      newList.prefix = l.prefix.slice(0, prefixSize - from2);
      bits = setPrefix(prefixSize - from2, bits);
    } else {
      newOffset = 0;
      newList.root = sliceLeft(newList.root, getDepth(l), from2 - prefixSize, l.offset, true);
      newList.offset = newOffset;
      if (newList.root === void 0) {
        bits = setDepth(0, bits);
      }
      bits = setPrefix(newAffix.length, bits);
      prefixSize = newAffix.length;
      newList.prefix = newAffix;
    }
  }
  if (to < length) {
    if (length - to < suffixSize) {
      bits = setSuffix(suffixSize - (length - to), bits);
      newList.suffix = l.suffix.slice(0, suffixSize - (length - to));
    } else {
      newList.root = sliceRight(newList.root, getDepth(l), to - prefixSize - 1, newList.offset);
      if (newList.root === void 0) {
        bits = setDepth(0, bits);
        newList.offset = 0;
      }
      bits = setSuffix(newAffix.length, bits);
      newList.suffix = newAffix;
    }
  }
  newList.bits = bits;
  return newList;
}
function slice(from2, to) {
  return (l) => slice_(l, from2, to);
}
function take_(l, n) {
  return slice_(l, 0, n);
}
function take(n) {
  return (l) => take_(l, n);
}
function findNotIndexCb(value, state) {
  if (state.predicate(value)) {
    ++state.index;
    return true;
  } else {
    return false;
  }
}
function takeWhile_(l, predicate) {
  const {
    index
  } = foldlCb(findNotIndexCb, {
    predicate,
    index: 0
  }, l);
  return slice_(l, 0, index);
}
function takeWhile(predicate) {
  return (l) => takeWhile_(l, predicate);
}
function takeLastWhile_(l, predicate) {
  const {
    index
  } = foldrCb(findNotIndexCb, {
    predicate,
    index: 0
  }, l);
  return slice_(l, l.length - index, l.length);
}
function takeLastWhile(predicate) {
  return (l) => takeLastWhile_(l, predicate);
}
function dropWhile_(l, predicate) {
  const {
    index
  } = foldlCb(findNotIndexCb, {
    predicate,
    index: 0
  }, l);
  return slice_(l, index, l.length);
}
function dropWhile(predicate) {
  return (l) => dropWhile_(l, predicate);
}
function dropRepeats(l) {
  return dropRepeatsWith_(l, elementEquals);
}
function dropRepeatsWith_(l, predicate) {
  return reduce_(l, emptyPushable(), (acc, a) => acc.length !== 0 && predicate(unsafeLast(acc), a) ? acc : push_(acc, a));
}
function dropRepeatsWith(predicate) {
  return (l) => dropRepeatsWith_(l, predicate);
}
function takeLast_(l, n) {
  return slice_(l, l.length - n, l.length);
}
function takeLast(n) {
  return (l) => takeLast_(l, n);
}
function splitAt_(l, index) {
  return [slice_(l, 0, index), slice_(l, index, l.length)];
}
function splitAt(index) {
  return (l) => splitAt_(l, index);
}
function splitWhen_(l, predicate) {
  const idx = findIndex_(l, predicate);
  return idx === -1 ? [l, empty()] : splitAt_(l, idx);
}
function splitWhen(predicate) {
  return (l) => splitWhen_(l, predicate);
}
function splitEvery_(l, size2) {
  const {
    buffer,
    l2
  } = reduce_(l, {
    l2: emptyPushable(),
    buffer: emptyPushable()
  }, ({
    buffer: buffer2,
    l2: l22
  }, elm) => {
    push_(buffer2, elm);
    if (buffer2.length === size2) {
      return {
        l2: push_(l22, buffer2),
        buffer: emptyPushable()
      };
    } else {
      return {
        l2: l22,
        buffer: buffer2
      };
    }
  });
  return buffer.length === 0 ? l2 : push_(l2, buffer);
}
function splitEvery(size2) {
  return (l) => splitEvery_(l, size2);
}
function remove_(l, from2, amount) {
  return concat_(slice_(l, 0, from2), slice_(l, from2 + amount, l.length));
}
function remove(from2, amount) {
  return (l) => remove_(l, from2, amount);
}
function drop_(l, n) {
  return slice_(l, n, l.length);
}
function drop(n) {
  return (l) => drop_(l, n);
}
function dropLast_(l, n) {
  return slice_(l, 0, l.length - n);
}
function dropLast(n) {
  return (l) => dropLast_(l, n);
}
function pop(l) {
  return slice_(l, 0, -1);
}
function tail(l) {
  return slice_(l, 1, l.length);
}
function arrayPush(array, a) {
  array.push(a);
  return array;
}
function toArray(l) {
  return reduce_(l, [], arrayPush);
}
function insert_(l, index, element) {
  return concat_(append_(slice_(l, 0, index), element), slice_(l, index, l.length));
}
function insert(index, element) {
  return (l) => insert_(l, index, element);
}
function insertAll_(l, index, elements) {
  return concat_(concat_(slice_(l, 0, index), elements), slice_(l, index, l.length));
}
function insertAll(index, elements) {
  return (l) => insertAll_(l, index, elements);
}
function reverse(l) {
  return reduce_(l, empty(), (newL, element) => prepend_(newL, element));
}
function isList(l) {
  return typeof l === "object" && Array.isArray(l.suffix);
}
function zip_(as, bs) {
  return zipWith_(as, bs, Tp.tuple);
}
function zip(bs) {
  return (as) => zip_(as, bs);
}
function zipWith_(as, bs, f) {
  const swapped = bs.length < as.length;
  const iterator = (swapped ? as : bs)[Symbol.iterator]();
  return map_(swapped ? bs : as, (a) => {
    const b = iterator.next().value;
    return swapped ? f(b, a) : f(a, b);
  });
}
function zipWith(bs, f) {
  return (as) => zipWith_(as, bs, f);
}
function sortWith_(l, ord) {
  const arr = [];
  let i = 0;
  forEach_(l, (elm) => arr.push({
    idx: i++,
    elm
  }));
  arr.sort(({
    elm: a,
    idx: i2
  }, {
    elm: b,
    idx: j
  }) => {
    const c = ord.compare(a, b);
    return c !== 0 ? c : i2 < j ? -1 : 1;
  });
  const newL = emptyPushable();
  for (let i2 = 0; i2 < arr.length; ++i2) {
    push_(newL, arr[i2].elm);
  }
  return newL;
}
function sortWith(ord) {
  return (l) => sortWith_(l, ord);
}
function group(l) {
  return groupWith_(l, elementEquals);
}
function groupWith_(l, f) {
  const result = emptyPushable();
  let buffer = emptyPushable();
  forEach_(l, (a) => {
    if (buffer.length !== 0 && !f(unsafeLast(buffer), a)) {
      push_(result, buffer);
      buffer = emptyPushable();
    }
    push_(buffer, a);
  });
  return buffer.length === 0 ? result : push_(result, buffer);
}
function groupWith(f) {
  return (l) => groupWith_(l, f);
}
function intersperse_(l, separator) {
  return pop(reduce_(l, emptyPushable(), (l2, a) => push_(push_(l2, a), separator)));
}
function intersperse(separator) {
  return (l) => intersperse_(l, separator);
}
function isEmpty(l) {
  return l.length === 0;
}
function builder() {
  return new ListBuilder(emptyPushable());
}
class ListBuilder {
  constructor(chunk) {
    this.chunk = chunk;
  }
  append(a) {
    push_(this.chunk, a);
    return this;
  }
  build() {
    return this.chunk;
  }
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  List,
  ListBuilder,
  Node,
  adjust,
  adjust_,
  ap,
  ap_,
  append,
  append_,
  backwards,
  builder,
  chain,
  chain_,
  compact,
  concat,
  concat_,
  contains,
  contains_,
  drop,
  dropLast,
  dropLast_,
  dropRepeats,
  dropRepeatsWith,
  dropRepeatsWith_,
  dropWhile,
  dropWhile_,
  drop_,
  empty,
  emptyPushable,
  equals,
  equalsWith,
  equalsWith_,
  equals_,
  every,
  every_,
  filter,
  filterMap,
  filterMap_,
  filterNot,
  filterNot_,
  filter_,
  find,
  findIndex,
  findIndex_,
  findLast,
  findLast_,
  find_,
  first,
  flatten,
  forEach,
  forEach_,
  from,
  group,
  groupWith,
  groupWith_,
  indexOf,
  indexOf_,
  insert,
  insertAll,
  insertAll_,
  insert_,
  intersperse,
  intersperse_,
  isEmpty,
  isList,
  join,
  join_,
  last,
  lastIndexOf,
  lastIndexOf_,
  list,
  map,
  map_,
  none,
  none_,
  nth,
  nth_,
  of,
  pair,
  pair_,
  partition,
  partitionMap,
  partitionMap_,
  partition_,
  pluck,
  pluck_,
  pop,
  prepend,
  prepend_,
  push_,
  range,
  range_,
  reduce,
  reduceRight,
  reduceRight_,
  reduceWhile,
  reduceWhile_,
  reduce_,
  remove,
  remove_,
  repeat,
  repeat_,
  reverse,
  scan,
  scan_,
  separate,
  size,
  slice,
  slice_,
  some,
  some_,
  sortWith,
  sortWith_,
  splitAt,
  splitAt_,
  splitEvery,
  splitEvery_,
  splitWhen,
  splitWhen_,
  tail,
  take,
  takeLast,
  takeLastWhile,
  takeLastWhile_,
  takeLast_,
  takeWhile,
  takeWhile_,
  take_,
  times,
  times_,
  toArray,
  unsafeFind,
  unsafeFindLast,
  unsafeFindLast_,
  unsafeFind_,
  unsafeFirst,
  unsafeLast,
  unsafeNth,
  unsafeNth_,
  update,
  update_,
  zip,
  zipWith,
  zipWith_,
  zip_
});
