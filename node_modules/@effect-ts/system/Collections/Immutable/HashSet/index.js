var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var HashSet_exports = {};
__export(HashSet_exports, {
  HashSet: () => HashSet,
  add: () => add,
  add_: () => add_,
  beginMutation: () => beginMutation,
  chain: () => chain,
  chain_: () => chain_,
  difference: () => difference,
  difference_: () => difference_,
  endMutation: () => endMutation,
  equal: () => equal,
  every: () => every,
  every_: () => every_,
  filter: () => filter,
  filter_: () => filter_,
  forEach_: () => forEach_,
  has_: () => has_,
  intersection: () => intersection,
  intersection_: () => intersection_,
  isSubset: () => isSubset,
  isSubset_: () => isSubset_,
  make: () => make,
  map: () => map,
  map_: () => map_,
  mutate_: () => mutate_,
  partition: () => partition,
  partition_: () => partition_,
  reduce: () => reduce,
  reduce_: () => reduce_,
  remove: () => remove,
  remove_: () => remove_,
  size: () => size,
  some: () => some,
  some_: () => some_,
  toggle: () => toggle,
  toggle_: () => toggle_,
  union: () => union,
  union_: () => union_,
  values: () => values
});
var import_Operator = require("../../../Operator/index.js");
var import_Function = require("../../../Function/index.js");
var I = __toESM(require("../../../Iterable/index.js"));
var St = __toESM(require("../../../Structural/index.js"));
var HM = __toESM(require("../HashMap/core.js"));
var Tp = __toESM(require("../Tuple/index.js"));
class HashSet {
  constructor(keyMap) {
    this.keyMap = keyMap;
  }
  [Symbol.iterator]() {
    return HM.keys(this.keyMap);
  }
  get [St.hashSym]() {
    return St.hashIterator(this[Symbol.iterator]());
  }
  [St.equalsSym](that) {
    return that instanceof HashSet && that.keyMap.size === this.keyMap.size && I.corresponds(this, that, St.equals);
  }
}
function make() {
  return new HashSet(HM.make());
}
function add_(set, v) {
  return set.keyMap.editable ? (HM.set_(set.keyMap, v, true), set) : new HashSet(HM.set_(set.keyMap, v, void 0));
}
function add(v) {
  return (set) => add_(set, v);
}
function remove_(set, v) {
  return set.keyMap.editable ? (HM.remove_(set.keyMap, v), set) : new HashSet(HM.remove_(set.keyMap, v));
}
function remove(v) {
  return (set) => remove_(set, v);
}
function values(set) {
  return HM.keys(set.keyMap);
}
function has_(set, v) {
  return HM.has_(set.keyMap, v);
}
function forEach_(map2, f) {
  HM.forEachWithIndex_(map2.keyMap, (k) => {
    f(k);
  });
}
function mutate_(set, transient) {
  const s = beginMutation(set);
  transient(s);
  return endMutation(s);
}
function intersection_(l, r) {
  const x = make();
  return mutate_(x, (y) => {
    for (const k of r) {
      if (has_(l, k)) {
        add_(y, k);
      }
    }
  });
}
function intersection(r) {
  return (l) => intersection_(l, r);
}
function map_(set, f) {
  const r = make();
  return mutate_(r, (r2) => {
    forEach_(set, (e) => {
      const v = f(e);
      if (!has_(r2, v)) {
        add_(r2, v);
      }
    });
  });
}
function map(f) {
  return (set) => map_(set, f);
}
function some(predicate) {
  return (set) => some_(set, predicate);
}
function some_(set, predicate) {
  let found = false;
  for (const e of set) {
    found = predicate(e);
    if (found) {
      break;
    }
  }
  return found;
}
function size(set) {
  return HM.size(set.keyMap);
}
function equal() {
  return {
    equals: (x, y) => {
      if (y === x) {
        return true;
      }
      if (size(x) !== size(y)) {
        return false;
      }
      let eq = true;
      for (const vx of x) {
        if (!has_(y, vx)) {
          eq = false;
          break;
        }
      }
      return eq;
    }
  };
}
function every(predicate) {
  return (set) => every_(set, predicate);
}
function every_(set, predicate) {
  return (0, import_Function.not)(some((0, import_Function.not)(predicate)))(set);
}
function chain(f) {
  return (set) => chain_(set, f);
}
function chain_(set, f) {
  const r = make();
  mutate_(r, (r2) => {
    forEach_(set, (e) => {
      for (const a of f(e)) {
        if (!has_(r2, a)) {
          add_(r2, a);
        }
      }
    });
  });
  return r;
}
function isSubset(y) {
  return (x) => isSubset_(y, x);
}
function isSubset_(x, y) {
  return every_(x, (a) => has_(y, a));
}
function filter(predicate) {
  return (set) => filter_(set, predicate);
}
function filter_(set, predicate) {
  const r = make();
  return mutate_(r, (r2) => {
    const values_ = values(set);
    let e;
    while (!(e = values_.next()).done) {
      const value = e.value;
      if (predicate(value)) {
        add_(r2, value);
      }
    }
    return r2;
  });
}
function partition(predicate) {
  return (set) => partition_(set, predicate);
}
function partition_(set, predicate) {
  const values_ = values(set);
  let e;
  const right = beginMutation(make());
  const left = beginMutation(make());
  while (!(e = values_.next()).done) {
    const value = e.value;
    if (predicate(value)) {
      add_(right, value);
    } else {
      add_(left, value);
    }
  }
  return Tp.tuple(endMutation(left), endMutation(right));
}
function beginMutation(set) {
  return new HashSet(HM.beginMutation(set.keyMap));
}
function endMutation(set) {
  set.keyMap.editable = false;
  return set;
}
function difference_(x, y) {
  return mutate_(x, (s) => {
    for (const k of y) {
      remove_(s, k);
    }
  });
}
function difference(y) {
  return (x) => difference_(x, y);
}
function reduce_(set, z, f) {
  return HM.reduceWithIndex_(set.keyMap, z, (z2, v) => f(z2, v));
}
function reduce(z, f) {
  return (set) => reduce_(set, z, f);
}
function toggle(a) {
  return (set) => toggle_(set, a);
}
function toggle_(set, a) {
  return (has_(set, a) ? remove : add)(a)(set);
}
function union_(l, r) {
  const x = make();
  return mutate_(x, (x2) => {
    forEach_(l, (a) => {
      add_(x2, a);
    });
    for (const a of r) {
      add_(x2, a);
    }
  });
}
function union(y) {
  return (x) => union_(x, y);
}
module.exports = __toCommonJS(HashSet_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HashSet,
  add,
  add_,
  beginMutation,
  chain,
  chain_,
  difference,
  difference_,
  endMutation,
  equal,
  every,
  every_,
  filter,
  filter_,
  forEach_,
  has_,
  intersection,
  intersection_,
  isSubset,
  isSubset_,
  make,
  map,
  map_,
  mutate_,
  partition,
  partition_,
  reduce,
  reduce_,
  remove,
  remove_,
  size,
  some,
  some_,
  toggle,
  toggle_,
  union,
  union_,
  values
});
