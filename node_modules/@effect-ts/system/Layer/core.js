var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  all: () => all,
  allSeq: () => allSeq,
  andSeq: () => andSeq,
  andSeq_: () => andSeq_,
  catchAll: () => catchAll,
  chain: () => chain,
  chain_: () => chain_,
  fail: () => fail,
  first: () => first,
  flatten: () => flatten,
  fresh: () => fresh,
  fromEffect: () => fromEffect,
  fromEffect_: () => fromEffect_,
  fromFunction: () => fromFunction,
  fromManaged: () => fromManaged,
  fromManaged_: () => fromManaged_,
  fromValue: () => fromValue,
  launch: () => launch,
  main: () => main,
  map: () => map,
  mapError: () => mapError,
  map_: () => map_,
  orDie: () => orDie,
  orElse: () => orElse,
  restrict: () => restrict,
  retry: () => retry,
  second: () => second,
  succeed: () => succeed,
  suspend: () => suspend,
  toRuntime: () => toRuntime,
  zip: () => zip,
  zipPar: () => zipPar,
  zipPar_: () => zipPar_,
  zipWithPar: () => zipWithPar,
  zipWithPar_: () => zipWithPar_,
  zip_: () => zip_
});
var C = __toESM(require("../Cause/index.js"));
var CL = __toESM(require("../Clock/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var import_Has = require("../Has/index.js");
var import_definitions = require("./definitions.js");
var T = __toESM(require("./deps-effect.js"));
var M = __toESM(require("./deps-managed.js"));
__reExport(core_exports, require("./definitions.js"));
function environmentFor(has, a) {
  return M.fromEffect(T.access((r) => ({
    [has.key]: (0, import_Has.mergeEnvironments)(has, r, a)[has.key]
  })));
}
function suspend(f) {
  return new import_definitions.LayerSuspend(f);
}
function zipWithPar_(self, that, f) {
  return new import_definitions.LayerZipWithPar(self, that, f);
}
function fail(e) {
  return (0, import_definitions.fromRawManaged)(M.fail(e));
}
function succeed(resource) {
  return (0, import_definitions.fromRawManaged)(M.succeed(resource));
}
function zipWithPar(that, f) {
  return (self) => zipWithPar_(self, that, f);
}
function zipPar_(self, that) {
  return zipWithPar_(self, that, Tp.tuple);
}
function zipPar(that) {
  return (self) => zipPar_(self, that);
}
function fromValue(has) {
  return (resource) => new import_definitions.LayerManaged(M.chain_(M.fromEffect(T.succeed(resource)), (a) => environmentFor(has, a))).setKey(has.key);
}
function fromEffect(has) {
  return (resource) => fromEffect_(resource, has);
}
function fromEffect_(resource, has) {
  return new import_definitions.LayerManaged(M.chain_(M.fromEffect(resource), (a) => environmentFor(has, a))).setKey(has.key);
}
function fromManaged(has) {
  return (resource) => new import_definitions.LayerManaged(M.chain_(resource, (a) => environmentFor(has, a))).setKey(has.key);
}
function fromManaged_(resource, has) {
  return new import_definitions.LayerManaged(M.chain_(resource, (a) => environmentFor(has, a))).setKey(has.key);
}
function fromFunction(tag) {
  return (f) => fromEffect(tag)(T.access(f));
}
function zip_(self, that) {
  return new import_definitions.LayerZipWithSeq(self, that, Tp.tuple);
}
function zip(right) {
  return (left) => zip_(left, right);
}
function andSeq(that) {
  return (self) => andSeq_(self, that);
}
function andSeq_(self, that) {
  return new import_definitions.LayerZipWithSeq(self, that, (l, r) => __spreadValues(__spreadValues({}, l), r));
}
function all(...ls) {
  return new import_definitions.LayerAllPar(ls);
}
function allSeq(...ls) {
  return new import_definitions.LayerAllSeq(ls);
}
function main(layer) {
  return layer;
}
function toRuntime(_) {
  return M.chain_((0, import_definitions.build)(_), (a) => M.fromEffect(T.checkPlatform((platform) => T.succeedWith(() => T.makeCustomRuntime(a, platform)))));
}
function fresh(layer) {
  return new import_definitions.LayerFresh(layer);
}
function map(f) {
  return (fa) => map_(fa, f);
}
function map_(fa, f) {
  return new import_definitions.LayerMap(fa, f);
}
function chain(f) {
  return (fa) => chain_(fa, f);
}
function chain_(fa, f) {
  return new import_definitions.LayerChain(fa, f);
}
function flatten(ffa) {
  return chain_(ffa, import_Function.identity);
}
function restrict(...ts) {
  return (self) => (0, import_definitions.compose_)(self, (0, import_definitions.fromRawEffect)(T.accessServicesT(...ts)((...servises) => servises.map((s, i) => ({
    [ts[i].key]: s
  })).reduce((x, y) => __spreadValues(__spreadValues({}, x), y)))));
}
function launch(self) {
  return M.useForever((0, import_definitions.build)(self));
}
function catchAll(handler) {
  return (self) => {
    return (0, import_definitions.fold)(self)((0, import_definitions.fromRawFunctionM)(({
      tuple: [r, cause]
    }) => E.fold_(C.failureOrCause(cause), (e) => T.succeed(Tp.tuple(r, e)), (c) => T.halt(c)))[">=>"](handler))((0, import_definitions.fromRawEffect)(T.environment()));
  };
}
function first() {
  return (0, import_definitions.fromRawFunction)((_) => _.get(0));
}
function second() {
  return (0, import_definitions.fromRawFunction)((_) => _.get(1));
}
function mapError(f) {
  return catchAll((0, import_definitions.fromRawFunctionM)((_) => T.fail(f(_.get(1)))));
}
function orDie(self) {
  return catchAll((0, import_definitions.fromRawFunctionM)((_) => T.die(_.get(1))))(self);
}
function orElse(that) {
  return catchAll(first()[">=>"](that));
}
function retryLoop(self) {
  const update = (0, import_definitions.fromRawFunctionM)(({
    tuple: [{
      tuple: [r, s]
    }, e]
  }) => T.provideAll_(T.chain_(T.orDie(CL.currentTime), (now) => T.chain_(s(now, e), (result) => {
    if (result._tag === "Done") {
      return T.fail(e);
    } else {
      return T.as_(CL.sleep(Math.abs(now - result.interval)), Tp.tuple(r, result.next));
    }
  })), r));
  return catchAll(update[">=>"](suspend(() => fresh(retryLoop(self)))))(first()[">=>"](self));
}
function retry(self, schedule) {
  return zipPar_((0, import_definitions.identity)(), (0, import_definitions.fromRawEffect)(T.succeed(schedule.step)))[">=>"](retryLoop(self));
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  all,
  allSeq,
  andSeq,
  andSeq_,
  catchAll,
  chain,
  chain_,
  fail,
  first,
  flatten,
  fresh,
  fromEffect,
  fromEffect_,
  fromFunction,
  fromManaged,
  fromManaged_,
  fromValue,
  launch,
  main,
  map,
  mapError,
  map_,
  orDie,
  orElse,
  restrict,
  retry,
  second,
  succeed,
  suspend,
  toRuntime,
  zip,
  zipPar,
  zipPar_,
  zipWithPar,
  zipWithPar_,
  zip_
});
