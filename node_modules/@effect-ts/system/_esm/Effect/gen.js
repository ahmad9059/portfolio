// ets_tracing: off

/**
 * inspired by https://github.com/tusharmath/qio/pull/22 (revised)
 */
import * as Tp from "../Collections/Immutable/Tuple/index.js";
import { ManagedImpl } from "../Managed/managed.js";
import { makeReleaseMap } from "../Managed/ReleaseMap/makeReleaseMap.js";
import { releaseAll } from "../Managed/ReleaseMap/releaseAll.js";
import * as Utils from "../Utils/index.js";
import { bracketExit_ } from "./bracketExit.js";
import { _A, _E, _R } from "./commons.js";
import { chain_, succeed, suspend, unit } from "./core.js";
import { sequential } from "./ExecutionStrategy.js";
import { fail } from "./fail.js";
import { fromEither } from "./fromEither.js";
import { getOrFail } from "./getOrFail.js";
import { service } from "./has.js";
import { map_ } from "./map.js";
import { provideSome_ } from "./provideSome.js";
export class GenEffect {
  constructor(effect, trace) {
    this.effect = effect;
    this.trace = trace;
  }

  *[Symbol.iterator]() {
    return yield this;
  }

}

function adapter(_, __, ___) {
  if (Utils.isEither(_)) {
    return new GenEffect(fromEither(() => _), __);
  }

  if (Utils.isOption(_)) {
    if (__ && typeof __ === "function") {
      return new GenEffect(_._tag === "None" ? fail(__()) : succeed(_.value), ___);
    }

    return new GenEffect(getOrFail(_), __);
  }

  if (Utils.isTag(_)) {
    return new GenEffect(service(_), __);
  }

  return new GenEffect(_, __);
}

export function genM(f, __trace) {
  return suspend(() => {
    const iterator = f(adapter);
    const state = iterator.next();

    function run(rm, state) {
      if (state.done) {
        return succeed(state.value);
      }

      return chain_(suspend(() => state.value.trace ? state.value["effect"] instanceof ManagedImpl ? map_(provideSome_(state.value["effect"]["effect"], r0 => Tp.tuple(r0, rm)), _ => _.get(1)) : state.value["effect"] : state.value["effect"] instanceof ManagedImpl ? map_(provideSome_(state.value["effect"]["effect"], r0 => Tp.tuple(r0, rm)), _ => _.get(1)) : state.value["effect"], state.value.trace), val => {
        const next = iterator.next(val);
        return run(rm, next);
      });
    }

    return chain_(makeReleaseMap, rm => bracketExit_(unit, () => run(rm, state), (_, e) => releaseAll(e, sequential)(rm)));
  }, __trace);
}
export function gen(f, __trace) {
  return suspend(() => {
    const iterator = f(adapter);
    const state = iterator.next();

    function run(state) {
      if (state.done) {
        return succeed(state.value);
      }

      return chain_(suspend(() => state.value["effect"], state.value.trace), val => run(iterator.next(val)));
    }

    return run(state);
  }, __trace);
}
//# sourceMappingURL=gen.js.map