// ets_tracing: off
import * as T from "../../../../Effect/index.js";
import { pipe } from "../../../../Function/index.js";
import * as M from "../../../../Managed/index.js";
import * as P from "../../../../Promise/index.js";
import * as Chain from "./chain.js";
import * as CrossRight from "./crossRight.js";
import * as FromEffect from "./fromEffect.js";
import * as InterruptWhenP from "./interruptWhenP.js";
import * as Managed from "./managed.js";
import * as RunForEachManaged from "./runForEachManaged.js";
/**
 * Drains the provided stream in the background for as long as this stream is running.
 * If this stream ends before `other`, `other` will be interrupted. If `other` fails,
 * this stream will fail with that error.
 */

export function drainFork_(self, other) {
  return Chain.chain_(FromEffect.fromEffect(P.make()), bgDied => CrossRight.crossRight_(Managed.managed(M.fork(M.catchAllCause_(RunForEachManaged.runForEachManaged_(other, _ => T.unit), _ => T.toManaged(P.halt_(bgDied, _))))), InterruptWhenP.interruptWhenP_(self, bgDied)));
}
/**
 * Drains the provided stream in the background for as long as this stream is running.
 * If this stream ends before `other`, `other` will be interrupted. If `other` fails,
 * this stream will fail with that error.
 *
 * @ets_data_first drainFork_
 */

export function drainFork(other) {
  return self => drainFork_(self, other);
}
//# sourceMappingURL=drainFork.js.map