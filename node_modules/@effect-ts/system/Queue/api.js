var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var api_exports = {};
__export(api_exports, {
  BackPressureStrategy: () => import_excl_forEach.BackPressureStrategy,
  both: () => both,
  bothWith: () => bothWith,
  bothWithM: () => bothWithM,
  bothWithM_: () => bothWithM_,
  bothWith_: () => bothWith_,
  both_: () => both_,
  contramap: () => contramap,
  contramapM: () => contramapM,
  contramapM_: () => contramapM_,
  contramap_: () => contramap_,
  createQueue: () => import_excl_forEach.createQueue,
  dimap: () => dimap,
  dimapM: () => dimapM,
  dimapM_: () => dimapM_,
  dimap_: () => dimap_,
  filterInput: () => filterInput,
  filterInputM: () => filterInputM,
  filterInputM_: () => filterInputM_,
  filterInput_: () => filterInput_,
  filterOutput: () => filterOutput,
  filterOutputM: () => filterOutputM,
  filterOutputM_: () => filterOutputM_,
  filterOutput_: () => filterOutput_,
  makeBounded: () => import_excl_forEach.makeBoundedQueue,
  makeDropping: () => makeDropping,
  makeSliding: () => makeSliding,
  makeUnbounded: () => makeUnbounded,
  map: () => map,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  poll: () => poll,
  takeBetween: () => takeBetween,
  takeBetween_: () => takeBetween_,
  unsafeCreate: () => import_excl_forEach.unsafeCreateQueue
});
var import_collect = require("../Collections/Immutable/Chunk/api/collect.js");
var import_filterEffect = require("../Collections/Immutable/Chunk/api/filterEffect.js");
var import_mapEffect = require("../Collections/Immutable/Chunk/api/mapEffect.js");
var import_zip = require("../Collections/Immutable/Chunk/api/zip.js");
var Chunk = __toESM(require("../Collections/Immutable/Chunk/core.js"));
var import_core = require("../Effect/core.js");
var exclForEach = __toESM(require("../Effect/excl-forEach.js"));
var import_excl_forEach = require("../Effect/excl-forEach.js");
var import_Function = require("../Function/index.js");
var O = __toESM(require("../Option/index.js"));
var import_MutableQueue = require("../Support/MutableQueue/index.js");
var import_core2 = require("./core.js");
var T = __toESM(require("./effect-api.js"));
var import_xqueue = require("./xqueue.js");
function makeSliding(capacity) {
  return T.chain_(T.succeedWith(() => new import_MutableQueue.Bounded(capacity)), exclForEach.createQueue(new import_core2.SlidingStrategy()));
}
function makeUnbounded() {
  return T.chain_(T.succeedWith(() => new import_MutableQueue.Unbounded()), exclForEach.createQueue(new import_core2.DroppingStrategy()));
}
function makeDropping(capacity) {
  return T.chain_(T.succeedWith(() => new import_MutableQueue.Bounded(capacity)), exclForEach.createQueue(new import_core2.DroppingStrategy()));
}
function takeRemainderLoop(self, n) {
  ;
  if (n <= 0) {
    return T.succeed(Chunk.empty());
  } else {
    return T.chain_(self.take, (a) => T.map_(takeRemainderLoop(self, n - 1), (_) => Chunk.append_(_, a)));
  }
}
function takeBetween(min, max) {
  return (self) => takeBetween_(self, min, max);
}
function takeBetween_(self, min, max) {
  ;
  if (max < min) {
    return T.succeed(Chunk.empty());
  } else {
    return T.chain_(self.takeUpTo(max), (bs) => {
      const remaining = min - Chunk.size(bs);
      if (remaining === 1) {
        return T.map_(self.take, (b) => Chunk.append_(bs, b));
      } else if (remaining > 1) {
        return T.map_(takeRemainderLoop(self, remaining), (list) => Chunk.concat_(bs, list));
      } else {
        return T.succeed(bs);
      }
    });
  }
}
function bothWithM(that, f) {
  return (self) => bothWithM_(self, that, f);
}
function bothWithM_(self, that, f) {
  ;
  ;
  return new BothWithM(self, that, f);
}
class BothWithM extends import_xqueue.XQueueInternal {
  constructor(self, that, f) {
    super();
    this.self = self;
    this.that = that;
    this.f = f;
    this.awaitShutdown = T.chain_(this.self.awaitShutdown, () => this.that.awaitShutdown);
    this.capacity = Math.min(this.self.capacity, this.that.capacity);
    this.isShutdown = this.self.isShutdown;
    this.shutdown = T.zipWithPar_(this.self.shutdown, this.that.shutdown, () => void 0);
    this.size = T.zipWithPar_(this.self.size, this.that.size, (x, y) => Math.max(x, y));
    this.take = T.chain_(T.zipPar_(this.self.take, this.that.take), ({
      tuple: [b, c]
    }) => this.f(b, c));
    this.takeAll = T.chain_(T.zipPar_(this.self.takeAll, this.that.takeAll), ({
      tuple: [bs, cs]
    }) => (0, import_mapEffect.mapEffect_)((0, import_zip.zip_)(bs, cs), ({
      tuple: [b, c]
    }) => this.f(b, c)));
  }
  offer(a) {
    return T.zipWithPar_(this.self.offer(a), this.that.offer(a), (x, y) => x && y);
  }
  offerAll(as) {
    return T.zipWithPar_(this.self.offerAll(as), this.that.offerAll(as), (x, y) => x && y);
  }
  takeUpTo(max) {
    return T.chain_(T.zipPar_(this.self.takeUpTo(max), this.that.takeUpTo(max)), ({
      tuple: [bs, cs]
    }) => (0, import_mapEffect.mapEffect_)((0, import_zip.zip_)(bs, cs), ({
      tuple: [b, c]
    }) => this.f(b, c)));
  }
}
function bothWith(that, f) {
  return (self) => bothWithM_(self, that, (b, c) => T.succeed(f(b, c)));
}
function bothWith_(self, that, f) {
  return bothWithM_(self, that, (b, c) => T.succeed(f(b, c)));
}
function both(that) {
  return (self) => bothWith_(self, that, (b, c) => (0, import_Function.tuple)(b, c));
}
function both_(self, that) {
  return bothWith_(self, that, (b, c) => (0, import_Function.tuple)(b, c));
}
function dimap(f, g) {
  return (self) => dimap_(self, f, g);
}
function dimap_(self, f, g) {
  return dimapM_(self, (c) => (0, import_core.succeed)(f(c)), (b) => (0, import_core.succeed)(g(b)));
}
function dimapM(f, g) {
  return (self) => dimapM_(self, f, g);
}
function dimapM_(self, f, g) {
  ;
  return new DimapM(self, f, g);
}
class DimapM extends import_xqueue.XQueueInternal {
  constructor(self, f, g) {
    super();
    this.self = self;
    this.f = f;
    this.g = g;
    this.awaitShutdown = this.self.awaitShutdown;
    this.capacity = this.self.capacity;
    this.isShutdown = this.self.isShutdown;
    this.shutdown = this.self.shutdown;
    this.size = this.self.size;
    this.take = T.chain_(this.self.take, this.g);
    this.takeAll = T.chain_(this.self.takeAll, (a) => (0, import_mapEffect.mapEffect_)(a, this.g));
  }
  offer(a) {
    return T.chain_(this.f(a), (a2) => this.self.offer(a2));
  }
  offerAll(as) {
    return T.chain_(T.forEach_(as, this.f), (as2) => this.self.offerAll(as2));
  }
  takeUpTo(n) {
    return T.chain_(this.self.takeUpTo(n), (bs) => (0, import_mapEffect.mapEffect_)(bs, this.g));
  }
}
function contramapM_(self, f) {
  return dimapM_(self, f, import_core.succeed);
}
function contramapM(f) {
  return (self) => contramapM_(self, f);
}
function contramap_(self, f) {
  return dimapM_(self, (c) => (0, import_core.succeed)(f(c)), import_core.succeed);
}
function contramap(f) {
  return (self) => contramap_(self, f);
}
function filterInputM(f) {
  return (self) => filterInputM_(self, f);
}
function filterInputM_(self, f) {
  ;
  return new FilterInputM(self, f);
}
class FilterInputM extends import_xqueue.XQueueInternal {
  constructor(self, f) {
    super();
    this.self = self;
    this.f = f;
    this.awaitShutdown = this.self.awaitShutdown;
    this.capacity = this.self.capacity;
    this.isShutdown = this.self.isShutdown;
    this.shutdown = this.self.shutdown;
    this.size = this.self.size;
    this.take = this.self.take;
    this.takeAll = this.self.takeAll;
  }
  offer(a) {
    return T.chain_(this.f(a), (b) => b ? this.self.offer(a) : T.succeed(false));
  }
  offerAll(as) {
    return T.chain_(T.forEach_(as, (a) => T.map_(this.f(a), (b) => b ? O.some(a) : O.none)), (maybeAs) => {
      const filtered = (0, import_collect.collect_)(maybeAs, import_Function.identity);
      if (Chunk.isEmpty(filtered)) {
        return T.succeed(false);
      } else {
        return this.self.offerAll(filtered);
      }
    });
  }
  takeUpTo(n) {
    return this.self.takeUpTo(n);
  }
}
function filterOutputM_(self, f) {
  ;
  return new FilterOutputM(self, f);
}
class FilterOutputM extends import_xqueue.XQueueInternal {
  constructor(self, f) {
    super();
    this.self = self;
    this.f = f;
    this.awaitShutdown = this.self.awaitShutdown;
    this.capacity = this.self.capacity;
    this.isShutdown = this.self.isShutdown;
    this.shutdown = this.self.shutdown;
    this.size = this.self.size;
    this.take = T.chain_(this.self.take, (b) => {
      return T.chain_(this.f(b), (p) => {
        return p ? T.succeed(b) : this.take;
      });
    });
    this.takeAll = T.chain_(this.self.takeAll, (bs) => (0, import_filterEffect.filterEffect_)(bs, this.f));
  }
  offer(a) {
    return this.self.offer(a);
  }
  offerAll(as) {
    return this.self.offerAll(as);
  }
  loop(max, acc) {
    return T.chain_(this.self.takeUpTo(max), (bs) => {
      if (Chunk.isEmpty(bs)) {
        return T.succeed(acc);
      }
      return T.chain_((0, import_filterEffect.filterEffect_)(bs, this.f), (filtered) => {
        const length = Chunk.size(filtered);
        if (length === max) {
          return T.succeed(Chunk.concat_(acc, filtered));
        } else {
          return this.loop(max - length, Chunk.concat_(acc, filtered));
        }
      });
    });
  }
  takeUpTo(n) {
    return T.suspend(() => {
      return this.loop(n, Chunk.empty());
    });
  }
}
function filterOutputM(f) {
  return (self) => filterOutputM_(self, f);
}
function filterOutput_(self, f) {
  return filterOutputM_(self, (b) => T.succeed(f(b)));
}
function filterOutput(f) {
  return (self) => filterOutput_(self, f);
}
function filterInput(f) {
  return (self) => filterInput_(self, f);
}
function filterInput_(self, f) {
  return filterInputM_(self, (a) => T.succeed(f(a)));
}
function map_(self, f) {
  return mapM_(self, (_) => T.succeed(f(_)));
}
function map(f) {
  return (self) => map_(self, f);
}
function mapM(f) {
  return (self) => mapM_(self, f);
}
function mapM_(self, f) {
  return dimapM_(self, (a) => T.succeed(a), f);
}
function poll(self) {
  ;
  return T.map_(self.takeUpTo(1), (x) => Chunk.unsafeGet_(x, 0));
}
module.exports = __toCommonJS(api_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BackPressureStrategy,
  both,
  bothWith,
  bothWithM,
  bothWithM_,
  bothWith_,
  both_,
  contramap,
  contramapM,
  contramapM_,
  contramap_,
  createQueue,
  dimap,
  dimapM,
  dimapM_,
  dimap_,
  filterInput,
  filterInputM,
  filterInputM_,
  filterInput_,
  filterOutput,
  filterOutputM,
  filterOutputM_,
  filterOutput_,
  makeBounded,
  makeDropping,
  makeSliding,
  makeUnbounded,
  map,
  mapM,
  mapM_,
  map_,
  poll,
  takeBetween,
  takeBetween_,
  unsafeCreate
});
