var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  DroppingStrategy: () => DroppingStrategy,
  SlidingStrategy: () => SlidingStrategy,
  awaitShutdown: () => awaitShutdown,
  capacity: () => capacity,
  isShutdown: () => isShutdown,
  offer: () => offer,
  offerAll: () => offerAll,
  offerAll_: () => offerAll_,
  offerTo: () => offerTo,
  offerTo_: () => offerTo_,
  offer_: () => offer_,
  shutdown: () => shutdown,
  size: () => size,
  take: () => take,
  takeAll: () => takeAll,
  takeAllUpTo: () => takeAllUpTo,
  takeAllUpTo_: () => takeAllUpTo_,
  unsafeCompletePromise: () => unsafeCompletePromise,
  unsafeCompleteTakers: () => unsafeCompleteTakers,
  unsafeOfferAll: () => unsafeOfferAll,
  unsafePollAll: () => unsafePollAll,
  unsafePollN: () => unsafePollN,
  unsafeRemove: () => unsafeRemove
});
var ChunkFilter = __toESM(require("../Collections/Immutable/Chunk/api/filter.js"));
var Chunk = __toESM(require("../Collections/Immutable/Chunk/core.js"));
var T = __toESM(require("./effect.js"));
var P = __toESM(require("./promise.js"));
var import_xqueue = require("./xqueue.js");
class DroppingStrategy {
  handleSurplus(_as, _queue, _takers, _isShutdown) {
    return T.succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue) {
  }
  get shutdown() {
    return T.unit;
  }
  get surplusSize() {
    return 0;
  }
}
class SlidingStrategy {
  handleSurplus(as, queue, takers, _isShutdown) {
    return T.succeedWith(() => {
      this.unsafeSlidingOffer(queue, as);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue) {
  }
  get shutdown() {
    return T.unit;
  }
  get surplusSize() {
    return 0;
  }
  unsafeSlidingOffer(queue, as) {
    let bs = as;
    while (Chunk.size(bs) > 0) {
      if (queue.capacity === 0) {
        return;
      }
      queue.poll(void 0);
      if (queue.offer(Chunk.unsafeGet_(bs, 0))) {
        bs = Chunk.drop_(bs, 1);
      }
    }
  }
}
function unsafeCompletePromise(p, a) {
  return P.unsafeDone(T.succeed(a))(p);
}
function unsafeCompleteTakers(strategy, queue, takers) {
  let keepPolling = true;
  while (keepPolling && !queue.isEmpty) {
    const taker = takers.poll(void 0);
    if (taker) {
      const element = queue.poll(void 0);
      if (element) {
        unsafeCompletePromise(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, Chunk.prepend_(unsafePollAll(takers), taker));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
}
function unsafeRemove(q, a) {
  ChunkFilter.filter_(unsafeOfferAll(q, unsafePollAll(q)), (b) => a !== b);
}
function unsafePollN(q, max) {
  return q.pollUpTo(max);
}
function unsafeOfferAll(q, as) {
  return q.offerAll(as);
}
function unsafePollAll(q) {
  let as = Chunk.empty();
  while (!q.isEmpty) {
    as = Chunk.append_(as, q.poll(void 0));
  }
  return as;
}
function awaitShutdown(self) {
  ;
  return self.awaitShutdown;
}
function capacity(self) {
  ;
  return self.capacity;
}
function isShutdown(self) {
  ;
  return self.isShutdown;
}
function offer(a) {
  return (self) => offer_(self, a);
}
function offer_(self, a) {
  ;
  return self.offer(a);
}
function offerTo(self) {
  return (a) => offer_(self, a);
}
function offerTo_(a, self) {
  return offer_(self, a);
}
function offerAll(as) {
  return (self) => offerAll_(self, as);
}
function offerAll_(self, as) {
  ;
  return self.offerAll(as);
}
function shutdown(self) {
  ;
  return self.shutdown;
}
function size(self) {
  ;
  return self.size;
}
function take(self) {
  ;
  return self.take;
}
function takeAll(self) {
  ;
  return self.takeAll;
}
function takeAllUpTo(n) {
  return (self) => takeAllUpTo_(self, n);
}
function takeAllUpTo_(self, n) {
  ;
  return self.takeUpTo(n);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DroppingStrategy,
  SlidingStrategy,
  awaitShutdown,
  capacity,
  isShutdown,
  offer,
  offerAll,
  offerAll_,
  offerTo,
  offerTo_,
  offer_,
  shutdown,
  size,
  take,
  takeAll,
  takeAllUpTo,
  takeAllUpTo_,
  unsafeCompletePromise,
  unsafeCompleteTakers,
  unsafeOfferAll,
  unsafePollAll,
  unsafePollN,
  unsafeRemove
});
