var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var api_exports = {};
__export(api_exports, {
  collect: () => collect,
  collectM: () => collectM,
  collectM_: () => collectM_,
  collect_: () => collect_,
  contramap: () => contramap,
  contramapM: () => contramapM,
  contramapM_: () => contramapM_,
  contramap_: () => contramap_,
  dequeueRef: () => dequeueRef,
  dimapError: () => dimapError,
  dimapError_: () => dimapError_,
  dimapM: () => dimapM,
  dimapM_: () => dimapM_,
  filterInput: () => filterInput,
  filterInputM: () => filterInputM,
  filterInputM_: () => filterInputM_,
  filterInput_: () => filterInput_,
  filterOutput: () => filterOutput,
  filterOutputM: () => filterOutputM,
  filterOutputM_: () => filterOutputM_,
  filterOutput_: () => filterOutput_,
  fold: () => fold,
  foldAllM: () => foldAllM,
  foldAllM_: () => foldAllM_,
  foldM: () => foldM,
  foldM_: () => foldM_,
  fold_: () => fold_,
  get: () => get,
  getAndSet: () => getAndSet,
  getAndSet_: () => getAndSet_,
  getAndUpdate: () => getAndUpdate,
  getAndUpdateSome: () => getAndUpdateSome,
  getAndUpdateSome_: () => getAndUpdateSome_,
  getAndUpdate_: () => getAndUpdate_,
  makeManagedRefM: () => makeManagedRefM,
  makeRefM: () => makeRefM,
  map: () => map,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  modify: () => modify,
  modifySome: () => modifySome,
  modifySome_: () => modifySome_,
  modify_: () => modify_,
  readOnly: () => readOnly,
  tapInput: () => tapInput,
  tapInput_: () => tapInput_,
  tapOutput: () => tapOutput,
  tapOutput_: () => tapOutput_,
  unsafeMakeRefM: () => unsafeMakeRefM,
  update: () => update,
  updateAndGet: () => updateAndGet,
  updateAndGet_: () => updateAndGet_,
  updateSome: () => updateSome,
  updateSomeAndGet: () => updateSomeAndGet,
  updateSomeAndGet_: () => updateSomeAndGet_,
  updateSome_: () => updateSome_,
  update_: () => update_,
  writeOnly: () => writeOnly
});
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var O = __toESM(require("../Option/index.js"));
var Q = __toESM(require("../Queue/index.js"));
var R = __toESM(require("../Ref/index.js"));
var S = __toESM(require("../Semaphore/index.js"));
var import_Utils = require("../Utils/index.js");
var T = __toESM(require("./effect.js"));
var import_XRefM = require("./XRefM.js");
function makeRefM(a) {
  return T.map_(T.bind_(T.bind_(T.do, "ref", () => R.makeRef(a)), "semaphore", () => S.makeSemaphore(1)), ({
    ref,
    semaphore
  }) => new import_XRefM.AtomicM(ref, semaphore));
}
function unsafeMakeRefM(a) {
  const ref = R.unsafeMakeRef(a);
  const semaphore = S.unsafeMakeSemaphore(1);
  return new import_XRefM.AtomicM(ref, semaphore);
}
function makeManagedRefM(a) {
  return T.toManaged(makeRefM(a));
}
function dequeueRef(a) {
  return T.map_(T.bind_(T.bind_(T.do, "ref", () => makeRefM(a)), "queue", () => Q.makeUnbounded()), ({
    queue,
    ref
  }) => [tapInput_(ref, (a2) => Q.offer_(queue, a2)), queue]);
}
function modify_(self, f) {
  return (0, import_Utils.matchTag)({
    AtomicM: (atomic) => S.withPermit_(T.chain_(T.chain_(atomic.ref.get, f), ({
      tuple: [b, a]
    }) => T.as_(atomic.ref.set(a), b)), atomic.semaphore),
    DerivedM: (derived) => derived.use((value, getEither, setEither) => S.withPermit_(T.chain_(value.ref.get, (a) => T.chain_(T.chain_(getEither(a), f), ({
      tuple: [b, a2]
    }) => T.as_(T.chain_(setEither(a2), (a3) => value.ref.set(a3)), b))), value.semaphore)),
    DerivedAllM: (derivedAll) => derivedAll.use((value, getEither, setEither) => S.withPermit_(T.chain_(value.ref.get, (s) => T.chain_(T.chain_(getEither(s), f), ({
      tuple: [b, a]
    }) => T.as_(T.chain_(setEither(a)(s), (a2) => value.ref.set(a2)), b))), value.semaphore))
  })((0, import_XRefM.concrete)(self));
}
function modify(f) {
  return (self) => modify_(self, f);
}
function get(self) {
  return self.get;
}
function getAndSet_(self, a) {
  return modify_(self, (v) => T.succeed(Tp.tuple(v, a)));
}
function getAndSet(a) {
  return (self) => getAndSet_(self, a);
}
function getAndUpdate_(self, f) {
  return modify_(self, (v) => T.map_(f(v), (r) => Tp.tuple(v, r)));
}
function getAndUpdate(f) {
  return (self) => getAndUpdate_(self, f);
}
function getAndUpdateSome_(self, f) {
  return modify_(self, (v) => T.map_(O.getOrElse_(f(v), () => T.succeed(v)), (r) => Tp.tuple(v, r)));
}
function getAndUpdateSome(f) {
  return (self) => getAndUpdateSome_(self, f);
}
function modifySome_(self, def, f) {
  return modify_(self, (v) => O.getOrElse_(f(v), () => T.succeed(Tp.tuple(def, v))));
}
function modifySome(def) {
  return (f) => (self) => modifySome_(self, def, f);
}
function update_(self, f) {
  return modify_(self, (v) => T.map_(f(v), (r) => Tp.tuple(void 0, r)));
}
function update(f) {
  return (self) => update_(self, f);
}
function updateAndGet_(self, f) {
  return modify_(self, (v) => T.map_(f(v), (r) => Tp.tuple(r, r)));
}
function updateAndGet(f) {
  return (self) => updateAndGet_(self, f);
}
function updateSome_(self, f) {
  return modify_(self, (v) => T.map_(O.getOrElse_(f(v), () => T.succeed(v)), (r) => Tp.tuple(void 0, r)));
}
function updateSome(f) {
  return (self) => updateSome_(self, f);
}
function updateSomeAndGet_(self, f) {
  return modify_(self, (v) => T.map_(O.getOrElse_(f(v), () => T.succeed(v)), (r) => Tp.tuple(r, r)));
}
function updateSomeAndGet(f) {
  return (self) => updateSomeAndGet_(self, f);
}
function fold_(self, ea, eb, ca, bd) {
  return self.foldM(ea, eb, (c) => T.fromEither(() => ca(c)), (b) => T.fromEither(() => bd(b)));
}
function fold(ea, eb, ca, bd) {
  return (self) => self.foldM(ea, eb, (c) => T.fromEither(() => ca(c)), (b) => T.fromEither(() => bd(b)));
}
function foldM_(self, ea, eb, ca, bd) {
  return self.foldM(ea, eb, ca, bd);
}
function foldM(ea, eb, ca, bd) {
  return (self) => self.foldM(ea, eb, ca, bd);
}
function foldAllM_(self, ea, eb, ec, ca, bd) {
  return self.foldAllM(ea, eb, ec, ca, bd);
}
function foldAllM(ea, eb, ec, ca, bd) {
  return (self) => self.foldAllM(ea, eb, ec, ca, bd);
}
function collectM_(self, f) {
  return self.foldM(import_Function.identity, (_) => O.some(_), (_) => T.succeed(_), (b) => O.getOrElse_(O.map_(f(b), (a) => T.asSomeError(a)), () => T.fail(O.none)));
}
function collectM(f) {
  return (self) => collectM_(self, f);
}
function collect_(self, f) {
  return collectM_(self, (b) => O.map_(f(b), T.succeed));
}
function collect(f) {
  return (self) => collect_(self, f);
}
function dimapM_(self, f, g) {
  return self.foldM((ea) => ea, (eb) => eb, f, g);
}
function dimapM(f, g) {
  return (self) => dimapM_(self, f, g);
}
function dimapError_(self, f, g) {
  return fold_(self, (ea) => f(ea), (eb) => g(eb), (a) => E.right(a), (b) => E.right(b));
}
function dimapError(f, g) {
  return (self) => dimapError_(self, f, g);
}
function filterInputM_(self, f) {
  return foldM_(self, (ea) => O.some(ea), import_Function.identity, (a) => T.ifM_(T.asSomeError(f(a)), () => T.succeed(a), () => T.fail(O.none)), T.succeed);
}
function filterInputM(f) {
  return (self) => filterInputM_(self, f);
}
function filterInput_(self, f) {
  return filterInputM_(self, (a) => T.succeed(f(a)));
}
function filterInput(f) {
  return (self) => filterInput_(self, f);
}
function filterOutputM_(self, f) {
  return foldM_(self, (ea) => ea, (eb) => O.some(eb), (a) => T.succeed(a), (b) => T.ifM_(T.asSomeError(f(b)), () => T.succeed(b), () => T.fail(O.none)));
}
function filterOutputM(f) {
  return (self) => filterOutputM_(self, f);
}
function filterOutput_(self, f) {
  return filterOutputM_(self, (b) => T.succeed(f(b)));
}
function filterOutput(f) {
  return (self) => filterOutput_(self, f);
}
function mapM_(self, f) {
  return dimapM_(self, T.succeed, f);
}
function mapM(f) {
  return (self) => mapM_(self, f);
}
function contramapM_(self, f) {
  return dimapM_(self, f, T.succeed);
}
function contramapM(f) {
  return (self) => contramapM_(self, f);
}
function contramap_(self, f) {
  return contramapM_(self, (c) => T.succeed(f(c)));
}
function contramap(f) {
  return (self) => contramap_(self, f);
}
function map_(self, f) {
  return mapM_(self, (b) => T.succeed(f(b)));
}
function map(f) {
  return (self) => map_(self, f);
}
function readOnly(self) {
  return self;
}
function writeOnly(self) {
  return fold_(self, import_Function.identity, () => void 0, E.right, () => E.left(void 0));
}
function tapInput_(self, f) {
  return contramapM_(self, (c) => T.as_(f(c), c));
}
function tapInput(f) {
  return (self) => tapInput_(self, f);
}
function tapOutput_(self, f) {
  return mapM_(self, (b) => T.as_(f(b), b));
}
function tapOutput(f) {
  return (self) => tapOutput_(self, f);
}
module.exports = __toCommonJS(api_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  collect,
  collectM,
  collectM_,
  collect_,
  contramap,
  contramapM,
  contramapM_,
  contramap_,
  dequeueRef,
  dimapError,
  dimapError_,
  dimapM,
  dimapM_,
  filterInput,
  filterInputM,
  filterInputM_,
  filterInput_,
  filterOutput,
  filterOutputM,
  filterOutputM_,
  filterOutput_,
  fold,
  foldAllM,
  foldAllM_,
  foldM,
  foldM_,
  fold_,
  get,
  getAndSet,
  getAndSet_,
  getAndUpdate,
  getAndUpdateSome,
  getAndUpdateSome_,
  getAndUpdate_,
  makeManagedRefM,
  makeRefM,
  map,
  mapM,
  mapM_,
  map_,
  modify,
  modifySome,
  modifySome_,
  modify_,
  readOnly,
  tapInput,
  tapInput_,
  tapOutput,
  tapOutput_,
  unsafeMakeRefM,
  update,
  updateAndGet,
  updateAndGet_,
  updateSome,
  updateSomeAndGet,
  updateSomeAndGet_,
  updateSome_,
  update_,
  writeOnly
});
