var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var api_exports = {};
__export(api_exports, {
  absorb: () => absorb,
  absorb_: () => absorb_,
  access: () => access,
  accessM: () => accessM,
  accessManaged: () => accessManaged,
  accessService: () => accessService,
  accessServiceM: () => accessServiceM,
  accessServices: () => accessServices,
  accessServicesM: () => accessServicesM,
  accessServicesT: () => accessServicesT,
  accessServicesTM: () => accessServicesTM,
  andThen: () => andThen,
  andThen_: () => andThen_,
  as: () => as,
  asService: () => asService,
  asService_: () => asService_,
  asSome: () => asSome,
  asSomeError: () => asSomeError,
  asUnit: () => asUnit,
  as_: () => as_,
  bimap: () => bimap,
  bimap_: () => bimap_,
  catchAll: () => catchAll,
  catchAllCause: () => catchAllCause,
  catchAllCause_: () => catchAllCause_,
  catchAll_: () => catchAll_,
  catchSome: () => catchSome,
  catchSomeCause: () => catchSomeCause,
  catchSomeCause_: () => catchSomeCause_,
  catchSome_: () => catchSome_,
  chainError: () => chainError,
  chainError_: () => chainError_,
  collect: () => collect,
  collectAll: () => collectAll,
  collectAllPar: () => collectAllPar,
  collectAllParN: () => collectAllParN,
  collectAllParN_: () => collectAllParN_,
  collectAllSuccesses: () => collectAllSuccesses,
  collectAllSuccessesPar: () => collectAllSuccessesPar,
  collectAllSuccessesParN: () => collectAllSuccessesParN,
  collectAllSuccessesParN_: () => collectAllSuccessesParN_,
  collectAllUnit: () => collectAllUnit,
  collectAllUnitPar: () => collectAllUnitPar,
  collectAllUnitParN: () => collectAllUnitParN,
  collectAllUnitParN_: () => collectAllUnitParN_,
  collectAllWith: () => collectAllWith,
  collectAllWithPar: () => collectAllWithPar,
  collectAllWithParN: () => collectAllWithParN,
  collectAllWithParN_: () => collectAllWithParN_,
  collectAllWithPar_: () => collectAllWithPar_,
  collectAllWith_: () => collectAllWith_,
  collectPar: () => collectPar,
  collectParN: () => collectParN,
  collectParN_: () => collectParN_,
  collectPar_: () => collectPar_,
  collect_: () => collect_,
  compose: () => compose,
  compose_: () => compose_,
  cond: () => cond,
  cond_: () => cond_,
  continueOrFail: () => continueOrFail,
  continueOrFailM: () => continueOrFailM,
  continueOrFailM_: () => continueOrFailM_,
  continueOrFail_: () => continueOrFail_,
  create: () => create,
  die: () => die,
  dieMessage: () => dieMessage,
  dieWith: () => dieWith,
  either: () => either,
  eventually: () => eventually,
  exposeTracer: () => exposeTracer,
  fiberId: () => fiberId,
  finalizer: () => finalizer,
  finalizerExit: () => finalizerExit,
  first: () => first,
  flatten: () => flatten,
  flattenM: () => flattenM,
  flip: () => flip,
  flipWith: () => flipWith,
  flipWith_: () => flipWith_,
  fold: () => fold,
  foldCause: () => foldCause,
  foldCause_: () => foldCause_,
  fold_: () => fold_,
  forEachUnitPar: () => forEachUnitPar,
  forEachUnitParN: () => forEachUnitParN,
  forEachUnitParN_: () => forEachUnitParN_,
  forEachUnitPar_: () => forEachUnitPar_,
  fromAutoClosable: () => fromAutoClosable,
  fromAutoClosableM: () => fromAutoClosableM,
  get: () => get,
  identityLeft: () => identityLeft,
  ignore: () => ignore,
  interrupt: () => interrupt,
  interruptAs: () => interruptAs,
  isFailure: () => isFailure,
  isSuccess: () => isSuccess,
  join: () => join,
  joinEither: () => joinEither,
  joinEither_: () => joinEither_,
  join_: () => join_,
  left: () => left,
  mapEffect: () => mapEffect,
  mapEffect_: () => mapEffect_,
  mapError: () => mapError,
  mapErrorCause: () => mapErrorCause,
  mapErrorCause_: () => mapErrorCause_,
  mapError_: () => mapError_,
  mapTryCatch: () => mapTryCatch,
  mapTryCatch_: () => mapTryCatch_,
  memoize: () => memoize,
  merge: () => merge,
  mergeAll: () => mergeAll,
  mergeAllPar: () => mergeAllPar,
  mergeAllParN: () => mergeAllParN,
  mergeAllParN_: () => mergeAllParN_,
  mergeAllPar_: () => mergeAllPar_,
  mergeAll_: () => mergeAll_,
  none: () => none,
  option: () => option,
  optional: () => optional,
  orDie: () => orDie,
  orDieWith: () => orDieWith,
  orDieWith_: () => orDieWith_,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseEither_: () => orElseEither_,
  orElseFail: () => orElseFail,
  orElseFail_: () => orElseFail_,
  orElseOptional: () => orElseOptional,
  orElseOptional_: () => orElseOptional_,
  orElseSucceed: () => orElseSucceed,
  orElseSucceed_: () => orElseSucceed_,
  orElse_: () => orElse_,
  preallocate: () => preallocate,
  preallocateManaged: () => preallocateManaged,
  provide: () => provide,
  provideLayer: () => provideLayer,
  provideLayer_: () => provideLayer_,
  provideService: () => provideService,
  provideServiceM: () => provideServiceM,
  provideSomeLayer: () => provideSomeLayer,
  reduce: () => reduce,
  reduceAll: () => reduceAll,
  reduceAllPar: () => reduceAllPar,
  reduceAllParN: () => reduceAllParN,
  reduceAllParN_: () => reduceAllParN_,
  reduceAllPar_: () => reduceAllPar_,
  reduceAll_: () => reduceAll_,
  reduceRight: () => reduceRight,
  reduceRight_: () => reduceRight_,
  reduce_: () => reduce_,
  refineOrDie: () => refineOrDie,
  refineOrDieWith: () => refineOrDieWith,
  refineOrDieWith_: () => refineOrDieWith_,
  refineOrDie_: () => refineOrDie_,
  reject: () => reject,
  rejectM: () => rejectM,
  rejectM_: () => rejectM_,
  reject_: () => reject_,
  release: () => release,
  replaceService: () => replaceService,
  replaceServiceM: () => replaceServiceM,
  replaceServiceM_: () => replaceServiceM_,
  replaceService_: () => replaceService_,
  result: () => result,
  retry: () => retry,
  retryOrElse: () => retryOrElse,
  retryOrElseEither: () => retryOrElseEither,
  retryOrElseEither_: () => retryOrElseEither_,
  retryOrElse_: () => retryOrElse_,
  retry_: () => retry_,
  right: () => right,
  sandbox: () => sandbox,
  sandboxWith: () => sandboxWith,
  sandboxWith_: () => sandboxWith_,
  scope: () => scope,
  second: () => second,
  service: () => service,
  services: () => services,
  some: () => some,
  someOrElse: () => someOrElse,
  someOrElseM: () => someOrElseM,
  someOrElseM_: () => someOrElseM_,
  someOrElse_: () => someOrElse_,
  someOrFail: () => someOrFail,
  someOrFailException: () => someOrFailException,
  someOrFail_: () => someOrFail_,
  tapBoth: () => tapBoth,
  tapBoth_: () => tapBoth_,
  tapCause: () => tapCause,
  tapCause_: () => tapCause_,
  tapError: () => tapError,
  tapError_: () => tapError_,
  tapM: () => tapM,
  tapM_: () => tapM_,
  timed: () => timed,
  timeout: () => timeout,
  timeout_: () => timeout_,
  toLayer: () => toLayer,
  toLayerMany: () => toLayerMany,
  toLayer_: () => toLayer_,
  tryCatch: () => tryCatch,
  unit: () => unit,
  unless: () => unless,
  unlessM: () => unlessM,
  unlessM_: () => unlessM_,
  unless_: () => unless_,
  unsandbox: () => unsandbox,
  unwrap: () => unwrap,
  when: () => when,
  whenM: () => whenM,
  withChildren: () => withChildren,
  withEarlyRelease: () => withEarlyRelease,
  withEarlyReleaseExit: () => withEarlyReleaseExit,
  withEarlyReleaseExit_: () => withEarlyReleaseExit_,
  zipLeft: () => zipLeft,
  zipLeftPar: () => zipLeftPar,
  zipLeftPar_: () => zipLeftPar_,
  zipLeft_: () => zipLeft_,
  zipPar: () => zipPar,
  zipPar_: () => zipPar_,
  zipRight: () => zipRight,
  zipRightPar: () => zipRightPar,
  zipRightPar_: () => zipRightPar_,
  zipRight_: () => zipRight_
});
var C = __toESM(require("../../Cause/index.js"));
var import_Cause = require("../../Cause/index.js");
var A = __toESM(require("../../Collections/Immutable/Array/index.js"));
var Chunk = __toESM(require("../../Collections/Immutable/Chunk/index.js"));
var R = __toESM(require("../../Collections/Immutable/Dictionary/index.js"));
var NA = __toESM(require("../../Collections/Immutable/NonEmptyArray/index.js"));
var SS = __toESM(require("../../Collections/Immutable/SortedSet/index.js"));
var Tp = __toESM(require("../../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../../Effect/index.js"));
var import_primitives = require("../../Effect/primitives.js");
var E = __toESM(require("../../Either/index.js"));
var Ex = __toESM(require("../../Exit/index.js"));
var F = __toESM(require("../../Fiber/index.js"));
var import_Function = require("../../Function/index.js");
var import_GlobalExceptions = require("../../GlobalExceptions/index.js");
var import_Has = require("../../Has/index.js");
var I = __toESM(require("../../Iterable/index.js"));
var L = __toESM(require("../../Layer/index.js"));
var O = __toESM(require("../../Option/index.js"));
var P = __toESM(require("../../Promise/index.js"));
var import_Supervisor = require("../../Supervisor/index.js");
var core = __toESM(require("../core.js"));
var forEach = __toESM(require("../forEach.js"));
var import_fromEffect = require("../fromEffect.js");
var import_makeExit = require("../makeExit.js");
var import_managed = require("../managed.js");
var add = __toESM(require("../ReleaseMap/add.js"));
var makeReleaseMap = __toESM(require("../ReleaseMap/makeReleaseMap.js"));
var releaseAll = __toESM(require("../ReleaseMap/releaseAll.js"));
var import_succeed = require("../succeed.js");
var import_absolve = require("./absolve.js");
var import_environment = require("./environment.js");
var import_foldM = require("./foldM.js");
var import_halt = require("./halt.js");
var import_releaseMap = require("./releaseMap.js");
var import_suspend = require("./suspend.js");
function absorb(f, __trace) {
  return (self) => absorb_(self, f, __trace);
}
function absorb_(self, f, __trace) {
  return (0, import_foldM.foldM_)(sandbox(self), (c) => core.fail(C.squash(f)(c)), import_succeed.succeed, __trace);
}
function get(self, __trace) {
  return (0, import_absolve.absolve)(core.map_(self, E.fromOption(() => O.none)), __trace);
}
function mapError_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.mapError_(self.effect, f, __trace));
}
function mapError(f, __trace) {
  return (self) => mapError_(self, f, __trace);
}
function mapErrorCause_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.mapErrorCause_(self.effect, f, __trace));
}
function mapErrorCause(f, __trace) {
  return (self) => mapErrorCause_(self, f, __trace);
}
function memoize(self, __trace) {
  return core.mapM_(import_releaseMap.releaseMap, (finalizers) => T.map_(T.bind_(T.bind_(T.do, "promise", () => P.make()), "complete", ({
    promise
  }) => T.once(T.accessM((r) => T.to_(T.map_(T.provideAll_(self.effect, Tp.tuple(r, finalizers)), (_) => _.get(1)), promise)))), ({
    complete,
    promise
  }) => T.toManaged(T.zipRight_(complete, P.await(promise)))), __trace);
}
function merge(self, __trace) {
  return (0, import_foldM.foldM_)(self, import_succeed.succeed, import_succeed.succeed, __trace);
}
const unit = /* @__PURE__ */ (0, import_suspend.suspend)(() => (0, import_fromEffect.fromEffect)(T.unit));
function none(self, __trace) {
  return (0, import_foldM.foldM_)(self, (x) => core.fail(O.some(x)), O.fold(() => unit, () => core.fail(O.none)), __trace);
}
function fold_(self, onFail, onSuccess, __trace) {
  return (0, import_foldM.foldM_)(self, (x) => (0, import_succeed.succeed)(onFail(x)), (x) => (0, import_succeed.succeed)(onSuccess(x)), __trace);
}
function fold(onFail, onSuccess, __trace) {
  return (self) => fold_(self, onFail, onSuccess, __trace);
}
function option(self, __trace) {
  return fold_(self, () => O.none, O.some, __trace);
}
function optional(self, __trace) {
  return (0, import_foldM.foldM_)(self, O.fold(() => (0, import_succeed.succeed)(O.none), core.fail), (x) => (0, import_succeed.succeed)(O.some(x)), __trace);
}
function orDieWith(f, __trace) {
  return (self) => orDieWith_(self, f, __trace);
}
function orDieWith_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.orDieWith_(self.effect, f, __trace));
}
function orDie(self, __trace) {
  return orDieWith_(self, import_Function.identity, __trace);
}
function orElse(that, __trace) {
  return (self) => orElse_(self, that, __trace);
}
function orElse_(self, that, __trace) {
  return (0, import_foldM.foldM_)(self, () => that(), import_succeed.succeed, __trace);
}
function orElseFail(e, __trace) {
  return (self) => orElseFail_(self, e, __trace);
}
function orElseFail_(self, e, __trace) {
  return orElse_(self, () => core.fail(e), __trace);
}
function orElseEither(that, __trace) {
  return (self) => orElseEither_(self, that, __trace);
}
function orElseEither_(self, that, __trace) {
  return (0, import_foldM.foldM_)(self, () => core.map_(that(), E.left), (x) => (0, import_succeed.succeed)(E.right(x)), __trace);
}
function orElseOptional_(self, that, __trace) {
  return catchAll_(self, O.fold(() => that(), (e) => core.fail(O.some(e))), __trace);
}
function orElseOptional(that, __trace) {
  return (self) => orElseOptional_(self, that, __trace);
}
function orElseSucceed_(self, that, __trace) {
  return orElse_(self, () => (0, import_succeed.succeed)(that()), __trace);
}
function orElseSucceed(that, __trace) {
  return (self) => orElseSucceed_(self, that, __trace);
}
function catchAll_(self, f, __trace) {
  return (0, import_foldM.foldM_)(self, f, import_succeed.succeed, __trace);
}
function catchAll(f, __trace) {
  return (self) => catchAll_(self, f, __trace);
}
function catchAllCause_(self, f, __trace) {
  return core.foldCauseM_(self, f, import_succeed.succeed, __trace);
}
function catchAllCause(f, __trace) {
  return (self) => core.foldCauseM_(self, f, import_succeed.succeed, __trace);
}
function catchSome_(self, pf, __trace) {
  return catchAll_(self, (e) => O.getOrElse_(pf(e), () => core.fail(e)), __trace);
}
function catchSome(pf, __trace) {
  return (self) => catchSome_(self, pf, __trace);
}
function catchSomeCause_(self, pf, __trace) {
  return catchAllCause_(self, (e) => O.getOrElse_(pf(e), () => (0, import_halt.halt)(e)), __trace);
}
function catchSomeCause(pf, __trace) {
  return (self) => catchSomeCause_(self, pf, __trace);
}
function continueOrFailM_(self, e, pf, __trace) {
  return core.chain_(self, (a) => O.getOrElse_(pf(a), () => core.fail(e())), __trace);
}
function continueOrFailM(e, pf, __trace) {
  return (self) => continueOrFailM_(self, e, pf, __trace);
}
function continueOrFail_(self, e, pf, __trace) {
  return continueOrFailM_(self, e, (x) => O.map_(pf(x), import_succeed.succeed), __trace);
}
function continueOrFail(e, pf, __trace) {
  return (self) => continueOrFail_(self, e, pf, __trace);
}
function provide(r, __trace) {
  return (next) => core.provideSome_(next, (r0) => __spreadValues(__spreadValues({}, r0), r), __trace);
}
function compose(that, __trace) {
  return (self) => compose_(self, that, __trace);
}
function compose_(self, that, __trace) {
  return core.chain_((0, import_environment.environment)(), (r1) => core.chain_(core.provideAll_(self, r1), (r) => core.provideAll_(that, r)));
}
function either(self, __trace) {
  return fold_(self, E.left, E.right, __trace);
}
function eventually(self, __trace) {
  return (0, import_managed.managedApply)(T.eventually(self.effect, __trace));
}
function first(self, __trace) {
  return core.zip_(self, (0, import_environment.environment)(), __trace);
}
function chainError_(self, f, __trace) {
  return flipWith_(self, core.chain(f, __trace));
}
function chainError(f, __trace) {
  return (self) => chainError_(self, f, __trace);
}
function flip(self, __trace) {
  return (0, import_foldM.foldM_)(self, import_succeed.succeed, core.fail, __trace);
}
function flipWith_(self, f, __trace) {
  return flip(f(flip(self)), __trace);
}
function flipWith(f, __trace) {
  return (self) => flipWith_(self, f, __trace);
}
function flatten(self, __trace) {
  return core.chain_(self, import_Function.identity, __trace);
}
function flattenM(self, __trace) {
  return core.mapM_(self, import_Function.identity, __trace);
}
function foldCause_(self, f, g, __trace) {
  return fold_(sandbox(self), f, g, __trace);
}
function foldCause(f, g, __trace) {
  return (self) => fold_(sandbox(self), f, g, __trace);
}
function ignore(self, __trace) {
  return fold_(self, import_Function.constVoid, import_Function.constVoid, __trace);
}
function isFailure(self, __trace) {
  return fold_(self, () => true, () => false, __trace);
}
function isSuccess(self, __trace) {
  return fold_(self, () => false, () => true, __trace);
}
function join(that, __trace) {
  return (self) => join_(self, that, __trace);
}
function join_(self, that, __trace) {
  return core.chain_((0, import_environment.environment)(), E.fold((r) => core.provideAll_(self, r), (r1) => core.provideAll_(that, r1)), __trace);
}
function joinEither(that, __trace) {
  return (self) => joinEither_(self, that, __trace);
}
function joinEither_(self, that, __trace) {
  return core.chain_((0, import_environment.environment)(), E.fold((r0) => core.provideAll_(core.map_(self, E.left), r0), (r1) => core.provideAll_(core.map_(that, E.right), r1)), __trace);
}
function identityLeft(__trace) {
  return (self) => joinEither_(self, (0, import_environment.environment)(), __trace);
}
function tryCatch(f, onThrow, __trace) {
  return (0, import_fromEffect.fromEffect)(T.tryCatch(f, onThrow), __trace);
}
function mapTryCatch(onThrow, f, __trace) {
  return (self) => mapTryCatch_(self, onThrow, f, __trace);
}
function mapTryCatch_(self, onThrow, f, __trace) {
  return (0, import_foldM.foldM_)(self, (e) => core.fail(e), (a) => tryCatch(() => f(a), onThrow), __trace);
}
function mapEffect_(self, f, __trace) {
  return mapTryCatch_(self, import_Function.identity, f, __trace);
}
function mapEffect(f, __trace) {
  return (self) => mapEffect_(self, f, __trace);
}
function preallocate(self, __trace) {
  return T.uninterruptibleMask(({
    restore
  }) => T.map_(T.bind_(T.bind_(T.bind_(T.do, "releaseMap", () => makeReleaseMap.makeReleaseMap), "tp", ({
    releaseMap: releaseMap2
  }) => T.result(restore(T.provideSome_(self.effect, (r) => Tp.tuple(r, releaseMap2)), __trace))), "preallocated", ({
    releaseMap: releaseMap2,
    tp
  }) => Ex.foldM_(tp, (c) => T.zipRight_(releaseAll.releaseAll(Ex.fail(c), T.sequential)(releaseMap2), T.halt(c)), ({
    tuple: [release2, a]
  }) => T.succeed((0, import_managed.managedApply)(T.accessM(({
    tuple: [_, releaseMap3]
  }) => T.map_(add.add(release2)(releaseMap3), (_2) => Tp.tuple(_2, a))))))), ({
    preallocated
  }) => preallocated));
}
function preallocateManaged(self, __trace) {
  return (0, import_managed.managedApply)(T.map_(self.effect, ({
    tuple: [release2, a]
  }) => Tp.tuple(release2, (0, import_managed.managedApply)(T.accessM(({
    tuple: [_, releaseMap2]
  }) => T.map_(add.add(release2)(releaseMap2), (_2) => Tp.tuple(_2, a))))), __trace));
}
function provideLayer(layer, __trace) {
  return (self) => provideLayer_(self, layer, __trace);
}
function provideLayer_(self, layer, __trace) {
  return core.chain_(L.build(layer), (r) => core.provideAll_(self, r), __trace);
}
function provideSomeLayer(layer, __trace) {
  return (self) => provideLayer_(self, layer["+++"](L.identity()), __trace);
}
function refineOrDieWith(pf, f, __trace) {
  return (self) => refineOrDieWith_(self, pf, f);
}
function refineOrDieWith_(self, pf, f, __trace) {
  return catchAll_(self, (e) => O.fold_(pf(e), () => die(f(e), __trace), (e1) => core.fail(e1, __trace)));
}
function refineOrDie(pf, __trace) {
  return (self) => refineOrDie_(self, pf, __trace);
}
function refineOrDie_(self, pf, __trace) {
  return refineOrDieWith_(self, pf, import_Function.identity, __trace);
}
function die(e, __trace) {
  return (0, import_fromEffect.fromEffect)(T.die(e, __trace));
}
function dieWith(e, __trace) {
  return (0, import_fromEffect.fromEffect)(T.dieWith(e, __trace));
}
function dieMessage(message, __trace) {
  return die(new import_Cause.RuntimeError(message), __trace);
}
function rejectM(pf, __trace) {
  return (self) => rejectM_(self, pf, __trace);
}
function rejectM_(self, pf, __trace) {
  return core.chain_(self, (a) => O.fold_(pf(a), () => (0, import_succeed.succeed)(a, __trace), (_) => core.chain_(_, (e1) => core.fail(e1), __trace)));
}
function reject(pf, __trace) {
  return (self) => reject_(self, pf, __trace);
}
function reject_(self, pf, __trace) {
  return rejectM_(self, (x) => O.map_(pf(x), core.fail), __trace);
}
function release(self, __trace) {
  return (0, import_fromEffect.fromEffect)(core.useNow(self), __trace);
}
function retryOrElseEither_(self, policy, orElse2, __trace) {
  return (0, import_managed.managedApply)(T.map_(T.accessM(({
    tuple: [env, releaseMap2]
  }) => T.provideAll_(T.retryOrElseEither_(T.provideAll_(self.effect, Tp.tuple(env, releaseMap2)), policy, (e, o) => T.provideAll_(orElse2(e, o).effect, Tp.tuple(env, releaseMap2)), __trace), env)), E.fold(({
    tuple: [f, a]
  }) => Tp.tuple(f, E.left(a)), ({
    tuple: [f, a]
  }) => Tp.tuple(f, E.right(a)))));
}
function retryOrElseEither(policy, orElse2, __trace) {
  return (self) => retryOrElseEither_(self, policy, orElse2, __trace);
}
function retryOrElse_(self, policy, orElse2, __trace) {
  return core.map_(retryOrElseEither_(self, policy, orElse2, __trace), E.fold(import_Function.identity, import_Function.identity));
}
function retryOrElse(policy, orElse2, __trace) {
  return (self) => retryOrElse_(self, policy, orElse2, __trace);
}
function retry_(self, policy, __trace) {
  return retryOrElse_(self, policy, (e, _) => core.fail(e), __trace);
}
function retry(policy, __trace) {
  return (self) => retry_(self, policy, __trace);
}
function result(self, __trace) {
  return core.foldCauseM_(self, (x) => (0, import_succeed.succeed)(Ex.halt(x)), (x) => (0, import_succeed.succeed)(Ex.succeed(x)), __trace);
}
function sandbox(self, __trace) {
  return (0, import_managed.managedApply)(T.sandbox(self.effect, __trace));
}
function unsandbox(self) {
  return mapErrorCause_(self, C.flatten);
}
function sandboxWith(f) {
  return (self) => sandboxWith_(self, f);
}
function sandboxWith_(self, f) {
  return unsandbox(f(sandbox(self)));
}
function second(self) {
  return core.zip_((0, import_environment.environment)(), self);
}
function some(self) {
  return (0, import_foldM.foldM_)(self, (x) => core.fail(O.some(x)), O.fold(() => core.fail(O.none), import_succeed.succeed));
}
function someOrElse(orElse2) {
  return (self) => someOrElse_(self, orElse2);
}
function someOrElse_(self, orElse2) {
  return core.map_(self, O.getOrElse(orElse2));
}
function someOrElseM(orElse2) {
  return (self) => someOrElseM_(self, orElse2);
}
function someOrElseM_(self, orElse2) {
  return core.chain_(self, O.fold(() => orElse2, import_succeed.succeed));
}
function someOrFail(e) {
  return (self) => someOrFail_(self, e);
}
function someOrFail_(self, e) {
  return core.chain_(self, O.fold(() => core.fail(e()), import_succeed.succeed));
}
function someOrFailException(self) {
  return someOrFail_(self, () => new import_GlobalExceptions.NoSuchElementException());
}
function tapBoth_(self, f, g) {
  return (0, import_foldM.foldM_)(self, (e) => core.chain_(f(e), () => core.fail(e)), (a) => core.map_(g(a), () => a));
}
function tapBoth(f, g) {
  return (self) => tapBoth_(self, f, g);
}
function tapCause_(self, f) {
  return catchAllCause_(self, (c) => core.chain_(f(c), () => (0, import_halt.halt)(c)));
}
function tapCause(f) {
  return (self) => tapCause_(self, f);
}
function tapError_(self, f) {
  return tapBoth_(self, f, import_succeed.succeed);
}
function tapError(f) {
  return (self) => tapError_(self, f);
}
function tapM(f) {
  return (self) => tapM_(self, f);
}
function tapM_(self, f) {
  return core.mapM_(self, (a) => T.as_(f(a), a));
}
function timed(self) {
  return (0, import_managed.managedApply)(T.chain_(T.environment(), ({
    tuple: [r, releaseMap2]
  }) => T.provideSome_(T.map_(T.timed(T.provideAll_(self.effect, Tp.tuple(r, releaseMap2))), ({
    tuple: [duration, {
      tuple: [fin, a]
    }]
  }) => Tp.tuple(fin, Tp.tuple(duration, a))), (r2) => r2.get(0))));
}
function timeout_(self, d) {
  return (0, import_managed.managedApply)(T.uninterruptibleMask(({
    restore
  }) => T.gen(function* (_) {
    const env = yield* _(T.environment());
    const {
      tuple: [r, outerReleaseMap]
    } = env;
    const innerReleaseMap = yield* _(makeReleaseMap.makeReleaseMap);
    const earlyRelease = yield* _(add.add((exit) => releaseAll.releaseAll(exit, T.sequential)(innerReleaseMap))(outerReleaseMap));
    const raceResult = yield* _(restore(T.provideAll_(T.raceWith_(T.provideAll_(self.effect, Tp.tuple(r, innerReleaseMap)), T.as_(T.sleep(d), O.none), (result2, sleeper) => T.zipRight_(F.interrupt(sleeper), T.done(Ex.map_(result2, (tp) => E.right(tp.get(1))))), (_2, resultFiber) => T.succeed(E.left(resultFiber))), r)));
    const a = yield* _(E.fold_(raceResult, (f) => T.as_(T.chain_(T.fiberId, (id) => T.forkDaemon(T.ensuring_(F.interrupt(f), releaseAll.releaseAll(Ex.interrupt(id), T.sequential)(innerReleaseMap)))), O.none), (v) => T.succeed(O.some(v))));
    return Tp.tuple(earlyRelease, a);
  })));
}
function timeout(d) {
  return (self) => timeout_(self, d);
}
function toLayer(tag) {
  return L.fromManaged(tag);
}
function toLayer_(self, tag) {
  return toLayer(tag)(self);
}
function toLayerMany(...tags) {
  return (self) => L.fromRawManaged(core.map_(self, (r) => {
    const env = {};
    for (const tag of tags) {
      env[tag.key] = tag.read(r);
    }
    return env;
  }));
}
function asUnit(self) {
  return as_(self, void 0);
}
function unlessM(b) {
  return (self) => unlessM_(self, b);
}
function unlessM_(self, b) {
  return core.chain_(b, (b2) => b2 ? unit : asUnit(self));
}
function unless(b) {
  return unlessM(core.succeedWith(b));
}
function unless_(self, b) {
  return unless(b)(self);
}
function as_(self, b) {
  return core.map_(self, () => b);
}
function as(b) {
  return (self) => as_(self, b);
}
function asSome(self) {
  return core.map_(self, O.some);
}
function asSomeError(self) {
  return mapError_(self, O.some);
}
function asService(tag) {
  return (self) => asService_(self, tag);
}
function asService_(self, tag) {
  return core.map_(self, tag.has);
}
function andThen_(self, that) {
  return core.chain_(self, (a) => core.provideAll_(that, a));
}
function andThen(that) {
  return (self) => andThen_(self, that);
}
function bimap(f, g) {
  return (self) => bimap_(self, f, g);
}
function bimap_(self, f, g) {
  return core.map_(mapError_(self, f), g);
}
function right() {
  return (self) => joinEither_((0, import_environment.environment)(), self);
}
function left() {
  return (self) => joinEither_(self, (0, import_environment.environment)());
}
function access(f, __trace) {
  return (0, import_fromEffect.fromEffect)(T.access(f), __trace);
}
function accessManaged(f) {
  return core.chain_((0, import_environment.environment)(), f);
}
function accessM(f) {
  return core.mapM_((0, import_environment.environment)(), f);
}
function accessServicesM(s) {
  return (f) => accessManaged((r) => f(R.map_(s, (v) => r[v.key])));
}
function accessServicesTM(...s) {
  return (f) => accessManaged((r) => f(...A.map_(s, (v) => r[v.key])));
}
function accessServicesT(...s) {
  return (f) => access((r) => f(...A.map_(s, (v) => r[v.key])));
}
function accessServices(s) {
  return (f) => access((r) => f(R.map_(s, (v) => r[v.key])));
}
function accessServiceM(s) {
  return (f) => accessManaged((r) => f(r[s.key]));
}
function accessService(s) {
  return (f) => accessServiceM(s)((a) => (0, import_succeed.succeed)(f(a)));
}
function service(s) {
  return accessServiceM(s)((a) => (0, import_succeed.succeed)(a));
}
function services(...s) {
  return access((r) => s.map((tag) => tag.read(r)));
}
function provideServiceM(_) {
  return (f) => (ma) => accessManaged((r) => core.chain_(f, (t) => core.provideAll_(ma, (0, import_Has.mergeEnvironments)(_, r, t))));
}
function provideService(_) {
  return (f) => (ma) => provideServiceM(_)((0, import_succeed.succeed)(f))(ma);
}
function replaceServiceM(_, f) {
  return (ma) => accessServiceM(_)((t) => provideServiceM(_)(f(t))(ma));
}
function replaceServiceM_(ma, _, f) {
  return accessServiceM(_)((t) => provideServiceM(_)(f(t))(ma));
}
function replaceService(_, f) {
  return (ma) => accessServiceM(_)((t) => provideServiceM(_)((0, import_succeed.succeed)(f(t)))(ma));
}
function replaceService_(ma, _, f) {
  return accessServiceM(_)((t) => provideServiceM(_)((0, import_succeed.succeed)(f(t)))(ma));
}
function whenM(b) {
  return unlessM(core.map_(b, (b2) => !b2));
}
function when(b) {
  return unless(() => !b());
}
function withEarlyReleaseExit_(self, exit) {
  return (0, import_managed.managedApply)(T.map_(self.effect, (tp) => Tp.tuple(tp.get(0), Tp.tuple(T.uninterruptible(tp.get(0)(exit)), tp.get(1)))));
}
function withEarlyReleaseExit(exit) {
  return (self) => withEarlyReleaseExit_(self, exit);
}
const fiberId = /* @__PURE__ */ (0, import_fromEffect.fromEffect)(T.fiberId);
function withEarlyRelease(self) {
  return core.chain_(fiberId, (id) => withEarlyReleaseExit_(self, Ex.interrupt(id)));
}
function zipLeft_(a, b) {
  return core.zipWith_(a, b, (a2) => a2);
}
function zipLeft(b) {
  return (a) => zipLeft_(a, b);
}
function zipLeftPar_(a, b) {
  return core.zipWithPar_(a, b, (a2) => a2);
}
function zipLeftPar(b) {
  return (a) => zipLeftPar_(a, b);
}
function zipRight_(a, b) {
  return core.zipWith_(a, b, (_, a2) => a2);
}
function zipRight(b) {
  return (a) => zipRight_(a, b);
}
function zipRightPar_(a, b) {
  return core.zipWithPar_(a, b, (_, a2) => a2);
}
function zipRightPar(b) {
  return (a) => zipRightPar_(a, b);
}
function zipPar_(a, b) {
  return core.zipWithPar_(a, b, (a2, b2) => [a2, b2]);
}
function zipPar(b) {
  return (a) => zipPar_(a, b);
}
function create(effect) {
  return (0, import_managed.managedApply)(effect);
}
function cond_(pred, result2, error) {
  return pred ? (0, import_succeed.succeed)(result2()) : core.fail(error());
}
function cond(result2, error) {
  return (pred) => cond_(pred, result2, error);
}
function forEachUnitPar_(as2, f, __trace) {
  return core.mapM_(core.makeManagedReleaseMap(T.parallel, __trace), (parallelReleaseMap) => {
    const makeInnerMap = T.provideSome_(T.map_(core.makeManagedReleaseMap(T.sequential).effect, (_) => _.get(1)), (r) => Tp.tuple(r, parallelReleaseMap));
    return T.forEachUnitPar_(as2, (a) => T.chain_(makeInnerMap, (innerMap) => T.provideSome_(T.map_(f(a).effect, (_) => _.get(1)), (r) => Tp.tuple(r, innerMap))));
  });
}
function forEachUnitPar(f, __trace) {
  return (as2) => forEachUnitPar_(as2, f, __trace);
}
function forEachUnitParN_(as2, n, f, __trace) {
  return core.mapM_(core.makeManagedReleaseMap(T.parallel, __trace), (parallelReleaseMap) => {
    const makeInnerMap = T.provideSome_(T.map_(core.makeManagedReleaseMap(T.sequential).effect, (_) => _.get(1)), (r) => Tp.tuple(r, parallelReleaseMap));
    return T.forEachUnitParN_(as2, n, (a) => T.chain_(makeInnerMap, (innerMap) => T.provideSome_(T.map_(f(a).effect, (_) => _.get(1)), (r) => Tp.tuple(r, innerMap))));
  });
}
function forEachUnitParN(n, f) {
  return (as2) => forEachUnitParN_(as2, n, f);
}
function collect(f) {
  return (self) => collect_(self, f);
}
function collect_(self, f) {
  return core.map_(forEach.forEach_(self, (a) => optional(f(a))), Chunk.compact);
}
function collectPar(f) {
  return (self) => collectPar_(self, f);
}
function collectPar_(self, f) {
  return core.map_(forEach.forEachPar_(self, (a) => optional(f(a))), Chunk.compact);
}
function collectParN_(self, n, f) {
  return core.map_(forEach.forEachParN_(self, n, (a) => optional(f(a))), Chunk.compact);
}
function collectParN(n, f) {
  return (self) => collectParN_(self, n, f);
}
function collectAll(as2, __trace) {
  return forEach.forEach_(as2, import_Function.identity, __trace);
}
function collectAllPar(as2, __trace) {
  return forEach.forEachPar_(as2, import_Function.identity, __trace);
}
function collectAllParN(n, __trace) {
  return (as2) => forEach.forEachParN_(as2, n, import_Function.identity, __trace);
}
function collectAllParN_(as2, n, __trace) {
  return forEach.forEachParN_(as2, n, import_Function.identity, __trace);
}
function collectAllUnit(as2, __trace) {
  return forEach.forEachUnit_(as2, import_Function.identity, __trace);
}
function collectAllUnitPar(as2, __trace) {
  return forEachUnitPar_(as2, import_Function.identity, __trace);
}
function collectAllUnitParN(n, __trace) {
  return (as2) => forEachUnitParN_(as2, n, import_Function.identity, __trace);
}
function collectAllUnitParN_(as2, n, __trace) {
  return forEachUnitParN_(as2, n, import_Function.identity, __trace);
}
function collectAllWith_(as2, pf, __trace) {
  return core.map_(collectAll(as2, __trace), Chunk.collect(pf));
}
function collectAllWith(pf, __trace) {
  return (as2) => collectAllWith_(as2, pf, __trace);
}
function collectAllWithPar_(as2, pf, __trace) {
  return core.map_(collectAllPar(as2, __trace), Chunk.collect(pf));
}
function collectAllWithPar(pf, __trace) {
  return (as2) => collectAllWithPar_(as2, pf, __trace);
}
function collectAllWithParN_(as2, n, pf, __trace) {
  return core.map_(collectAllParN_(as2, n, __trace), Chunk.collect(pf));
}
function collectAllWithParN(n, pf, __trace) {
  return (as2) => collectAllWithParN_(as2, n, pf, __trace);
}
function collectAllSuccesses(as2, __trace) {
  return collectAllWith_(I.map_(as2, (x) => result(x)), (e) => e._tag === "Success" ? O.some(e.value) : O.none, __trace);
}
function collectAllSuccessesPar(as2, __trace) {
  return collectAllWithPar_(I.map_(as2, (x) => result(x)), (e) => e._tag === "Success" ? O.some(e.value) : O.none, __trace);
}
function collectAllSuccessesParN(n, __trace) {
  return (as2) => collectAllSuccessesParN_(as2, n, __trace);
}
function collectAllSuccessesParN_(as2, n, __trace) {
  return collectAllWithParN_(I.map_(as2, (x) => result(x)), n, (e) => e._tag === "Success" ? O.some(e.value) : O.none, __trace);
}
function finalizerExit(f, __trace) {
  return (0, import_makeExit.makeExit_)(T.unit, (_, e) => f(e), __trace);
}
function finalizer(f, __trace) {
  return finalizerExit(() => f, __trace);
}
function reduce_(i, zero, f, __trace) {
  return (0, import_suspend.suspend)(() => A.reduce_(Array.from(i), (0, import_succeed.succeed)(zero), (acc, el) => core.chain_(acc, (a) => f(a, el))), __trace);
}
function reduce(zero, f, __trace) {
  return (i) => reduce_(i, zero, f, __trace);
}
function reduceRight_(i, zero, f, __trace) {
  return (0, import_suspend.suspend)(() => A.reduceRight_(Array.from(i), (0, import_succeed.succeed)(zero), (el, acc) => core.chain_(acc, (a) => f(el, a))), __trace);
}
function reduceRight(zero, f) {
  return (i) => reduceRight_(i, zero, f);
}
function reduceAll_(as2, f) {
  return A.reduce_(NA.tail(as2), NA.head(as2), (acc, a) => core.zipWith_(acc, a, f));
}
function reduceAll(f) {
  return (as2) => reduceAll_(as2, f);
}
function reduceAllPar_(as2, f) {
  return core.mapM_(core.makeManagedReleaseMap(T.parallel), (parallelReleaseMap) => T.provideSome_(T.reduceAllPar_(NA.map_(as2, (_) => T.map_(_.effect, (_2) => _2.get(1))), f), (r) => Tp.tuple(r, parallelReleaseMap)));
}
function reduceAllPar(f) {
  return (as2) => reduceAllPar_(as2, f);
}
function reduceAllParN_(as2, n, f) {
  return core.mapM_(core.makeManagedReleaseMap(T.parallel), (parallelReleaseMap) => T.provideSome_(T.reduceAllParN_(NA.map_(as2, (_) => T.map_(_.effect, (_2) => _2.get(1))), n, f), (r) => Tp.tuple(r, parallelReleaseMap)));
}
function reduceAllParN(n, f) {
  return (as2) => reduceAllParN_(as2, n, f);
}
function mergeAll(zero, f) {
  return (as2) => mergeAll_(as2, zero, f);
}
function mergeAll_(as2, zero, f) {
  return I.reduce_(as2, (0, import_succeed.succeed)(zero), (b, a) => core.zipWith_(b, a, f));
}
function mergeAllPar(zero, f) {
  return (as2) => mergeAllPar_(as2, zero, f);
}
function mergeAllPar_(as2, zero, f) {
  return core.mapM_(core.makeManagedReleaseMap(T.parallel), (parallelReleaseMap) => T.provideSome_(T.mergeAllPar_(I.map_(as2, (_) => T.map_(_.effect, (_2) => _2.get(1))), zero, f), (r) => Tp.tuple(r, parallelReleaseMap)));
}
function mergeAllParN(n, zero, f) {
  return (as2) => mergeAllParN_(as2, n, zero, f);
}
function mergeAllParN_(as2, n, zero, f) {
  return core.mapM_(core.makeManagedReleaseMap(T.parallel), (parallelReleaseMap) => T.provideSome_(T.mergeAllParN_(I.map_(as2, (_) => T.map_(_.effect, (_2) => _2.get(1))), n, zero, f), (r) => Tp.tuple(r, parallelReleaseMap)));
}
const scope = /* @__PURE__ */ core.map_(import_releaseMap.releaseMap, (finalizers) => (ma) => T.chain_(T.environment(), (r) => T.provideAll_(ma.effect, Tp.tuple(r, finalizers))));
function withChildren(get2) {
  return unwrap(T.map_(import_Supervisor.track, (supervisor) => (0, import_managed.managedApply)(T.supervised_(get2(T.chain_(supervisor.value, (children) => T.map_(T.descriptor, (d) => SS.filter_(children, (_) => _.id !== d.id)))).effect, supervisor))));
}
function unwrap(fa) {
  return flatten((0, import_fromEffect.fromEffect)(fa));
}
function fromAutoClosable(fa) {
  return core.make_(fa, (a) => T.succeedWith(() => a.close()));
}
function fromAutoClosableM(fa) {
  return core.make_(fa, (a) => a.close);
}
const interrupt = /* @__PURE__ */ core.chain_(/* @__PURE__ */ (0, import_fromEffect.fromEffect)(T.descriptor), (d) => interruptAs(d.id));
function interruptAs(id) {
  return (0, import_halt.halt)(C.interrupt(id));
}
function exposeTracer(f) {
  return (0, import_managed.managedApply)(new import_primitives.ITracer((tracer) => f(tracer).effect));
}
module.exports = __toCommonJS(api_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  absorb,
  absorb_,
  access,
  accessM,
  accessManaged,
  accessService,
  accessServiceM,
  accessServices,
  accessServicesM,
  accessServicesT,
  accessServicesTM,
  andThen,
  andThen_,
  as,
  asService,
  asService_,
  asSome,
  asSomeError,
  asUnit,
  as_,
  bimap,
  bimap_,
  catchAll,
  catchAllCause,
  catchAllCause_,
  catchAll_,
  catchSome,
  catchSomeCause,
  catchSomeCause_,
  catchSome_,
  chainError,
  chainError_,
  collect,
  collectAll,
  collectAllPar,
  collectAllParN,
  collectAllParN_,
  collectAllSuccesses,
  collectAllSuccessesPar,
  collectAllSuccessesParN,
  collectAllSuccessesParN_,
  collectAllUnit,
  collectAllUnitPar,
  collectAllUnitParN,
  collectAllUnitParN_,
  collectAllWith,
  collectAllWithPar,
  collectAllWithParN,
  collectAllWithParN_,
  collectAllWithPar_,
  collectAllWith_,
  collectPar,
  collectParN,
  collectParN_,
  collectPar_,
  collect_,
  compose,
  compose_,
  cond,
  cond_,
  continueOrFail,
  continueOrFailM,
  continueOrFailM_,
  continueOrFail_,
  create,
  die,
  dieMessage,
  dieWith,
  either,
  eventually,
  exposeTracer,
  fiberId,
  finalizer,
  finalizerExit,
  first,
  flatten,
  flattenM,
  flip,
  flipWith,
  flipWith_,
  fold,
  foldCause,
  foldCause_,
  fold_,
  forEachUnitPar,
  forEachUnitParN,
  forEachUnitParN_,
  forEachUnitPar_,
  fromAutoClosable,
  fromAutoClosableM,
  get,
  identityLeft,
  ignore,
  interrupt,
  interruptAs,
  isFailure,
  isSuccess,
  join,
  joinEither,
  joinEither_,
  join_,
  left,
  mapEffect,
  mapEffect_,
  mapError,
  mapErrorCause,
  mapErrorCause_,
  mapError_,
  mapTryCatch,
  mapTryCatch_,
  memoize,
  merge,
  mergeAll,
  mergeAllPar,
  mergeAllParN,
  mergeAllParN_,
  mergeAllPar_,
  mergeAll_,
  none,
  option,
  optional,
  orDie,
  orDieWith,
  orDieWith_,
  orElse,
  orElseEither,
  orElseEither_,
  orElseFail,
  orElseFail_,
  orElseOptional,
  orElseOptional_,
  orElseSucceed,
  orElseSucceed_,
  orElse_,
  preallocate,
  preallocateManaged,
  provide,
  provideLayer,
  provideLayer_,
  provideService,
  provideServiceM,
  provideSomeLayer,
  reduce,
  reduceAll,
  reduceAllPar,
  reduceAllParN,
  reduceAllParN_,
  reduceAllPar_,
  reduceAll_,
  reduceRight,
  reduceRight_,
  reduce_,
  refineOrDie,
  refineOrDieWith,
  refineOrDieWith_,
  refineOrDie_,
  reject,
  rejectM,
  rejectM_,
  reject_,
  release,
  replaceService,
  replaceServiceM,
  replaceServiceM_,
  replaceService_,
  result,
  retry,
  retryOrElse,
  retryOrElseEither,
  retryOrElseEither_,
  retryOrElse_,
  retry_,
  right,
  sandbox,
  sandboxWith,
  sandboxWith_,
  scope,
  second,
  service,
  services,
  some,
  someOrElse,
  someOrElseM,
  someOrElseM_,
  someOrElse_,
  someOrFail,
  someOrFailException,
  someOrFail_,
  tapBoth,
  tapBoth_,
  tapCause,
  tapCause_,
  tapError,
  tapError_,
  tapM,
  tapM_,
  timed,
  timeout,
  timeout_,
  toLayer,
  toLayerMany,
  toLayer_,
  tryCatch,
  unit,
  unless,
  unlessM,
  unlessM_,
  unless_,
  unsandbox,
  unwrap,
  when,
  whenM,
  withChildren,
  withEarlyRelease,
  withEarlyReleaseExit,
  withEarlyReleaseExit_,
  zipLeft,
  zipLeftPar,
  zipLeftPar_,
  zipLeft_,
  zipPar,
  zipPar_,
  zipRight,
  zipRightPar,
  zipRightPar_,
  zipRight_
});
