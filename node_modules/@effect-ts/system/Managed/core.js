var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  Reservation: () => Reservation,
  chain: () => chain,
  chain_: () => chain_,
  ensuring: () => ensuring,
  ensuring_: () => ensuring_,
  fail: () => fail,
  failWith: () => failWith,
  finalizerRef: () => finalizerRef,
  foldCauseM: () => foldCauseM,
  foldCauseM_: () => foldCauseM_,
  make: () => make,
  makeInterruptible: () => makeInterruptible,
  makeInterruptible_: () => makeInterruptible_,
  makeManagedReleaseMap: () => makeManagedReleaseMap,
  makeReservation: () => makeReservation,
  makeReservation_: () => makeReservation_,
  makeReserve: () => makeReserve,
  make_: () => make_,
  managedReserve: () => managedReserve,
  map: () => map,
  mapM: () => mapM,
  mapM_: () => mapM_,
  map_: () => map_,
  onExit: () => onExit,
  onExitFirst: () => onExitFirst,
  onExitFirst_: () => onExitFirst_,
  onExit_: () => onExit_,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  provideSome: () => provideSome,
  provideSome_: () => provideSome_,
  reserve: () => reserve,
  succeedWith: () => succeedWith,
  tap: () => tap,
  tap_: () => tap_,
  useForever: () => useForever,
  useNow: () => useNow,
  zip: () => zip,
  zipWith: () => zipWith,
  zipWithPar: () => zipWithPar,
  zipWithPar_: () => zipWithPar_,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var import_ExecutionStrategy = require("../Effect/ExecutionStrategy.js");
var import_Function = require("../Function/index.js");
var import_Ref = require("../Ref/index.js");
var T = __toESM(require("./deps-core.js"));
var import_fromEffect = require("./fromEffect.js");
var import_makeExit = require("./makeExit.js");
var import_managed = require("./managed.js");
var add = __toESM(require("./ReleaseMap/add.js"));
var addIfOpen = __toESM(require("./ReleaseMap/addIfOpen.js"));
var makeReleaseMap = __toESM(require("./ReleaseMap/makeReleaseMap.js"));
var release = __toESM(require("./ReleaseMap/release.js"));
var releaseAll = __toESM(require("./ReleaseMap/releaseAll.js"));
var import_use = require("./use.js");
function chain(f, __trace) {
  return (self) => chain_(self, f, __trace);
}
function chain_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.chain_(self.effect, ({
    tuple: [releaseSelf, a]
  }) => T.map_(f(a).effect, ({
    tuple: [releaseThat, b]
  }) => Tp.tuple((e) => T.chain_(T.result(releaseThat(e)), (e1) => T.chain_(T.result(releaseSelf(e)), (e2) => T.done(T.exitZipRight_(e1, e2), __trace))), b), __trace)));
}
function succeedWith(effect, __trace) {
  return (0, import_fromEffect.fromEffect)(T.succeedWith(effect, __trace));
}
function ensuring_(self, f, __trace) {
  return onExit_(self, () => f, __trace);
}
function ensuring(f, __trace) {
  return (self) => ensuring_(self, f, __trace);
}
function fail(e, __trace) {
  return (0, import_fromEffect.fromEffect)(T.fail(e, __trace));
}
function failWith(e, __trace) {
  return (0, import_fromEffect.fromEffect)(T.failWith(e, __trace));
}
function finalizerRef(initial, __trace) {
  return (0, import_makeExit.makeExit_)((0, import_Ref.makeRef)(initial), (ref, exit) => T.chain_(ref.get, (f) => f(exit)), __trace);
}
function foldCauseM(f, g, __trace) {
  return (self) => foldCauseM_(self, f, g, __trace);
}
function foldCauseM_(self, f, g, __trace) {
  return (0, import_managed.managedApply)(T.foldCauseM_(self.effect, (c) => f(c).effect, ({
    tuple: [_, a]
  }) => g(a).effect, __trace));
}
function make(release2, __trace) {
  return (acquire) => make_(acquire, release2, __trace);
}
function make_(acquire, release2, __trace) {
  return (0, import_makeExit.makeExit_)(acquire, release2, __trace);
}
function makeInterruptible(release2, __trace) {
  return (acquire) => makeInterruptible_(acquire, release2, __trace);
}
function makeInterruptible_(acquire, release2, __trace) {
  return onExitFirst_((0, import_fromEffect.fromEffect)(acquire, __trace), T.exitForeach(release2), __trace);
}
function makeManagedReleaseMap(es, __trace) {
  return (0, import_makeExit.makeExit_)(makeReleaseMap.makeReleaseMap, (rm, e) => releaseAll.releaseAll(e, es)(rm), __trace);
}
function makeReserve(reservation, __trace) {
  return (0, import_managed.managedApply)(T.uninterruptibleMask(({
    restore
  }) => T.map_(T.bind_(T.bind_(T.bind_(T.let_(T.let_(T.bind_(T.do, "tp", () => T.environment()), "r", (s) => s.tp.get(0)), "releaseMap", (s) => s.tp.get(1)), "reserved", (s) => T.provideAll_(reservation, s.r)), "releaseKey", (s) => addIfOpen.addIfOpen((x) => T.provideAll_(s.reserved.release(x), s.r, __trace))(s.releaseMap)), "finalizerAndA", (s) => {
    const k = s.releaseKey;
    switch (k._tag) {
      case "None": {
        return T.interrupt;
      }
      case "Some": {
        return T.map_(restore(T.provideSome_(s.reserved.acquire, ({
          tuple: [r]
        }) => r, __trace)), (a) => Tp.tuple((e) => release.release(k.value, e)(s.releaseMap), a));
      }
    }
  }), (s) => s.finalizerAndA)));
}
function map(f, __trace) {
  return (self) => map_(self, f, __trace);
}
function map_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.map_(self.effect, ({
    tuple: [fin, a]
  }) => Tp.tuple(fin, f(a)), __trace));
}
function mapM_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.chain_(self.effect, ({
    tuple: [fin, a]
  }) => T.provideSome_(T.map_(f(a), (b) => Tp.tuple(fin, b), __trace), ({
    tuple: [r]
  }) => r)));
}
function mapM(f, __trace) {
  return (self) => mapM_(self, f, __trace);
}
function onExit_(self, cleanup, __trace) {
  return (0, import_managed.managedApply)(T.uninterruptibleMask(({
    restore
  }) => T.map_(T.bind_(T.bind_(T.bind_(T.bind_(T.let_(T.let_(T.bind_(T.do, "tp", () => T.environment()), "r", (s) => s.tp.get(0)), "outerReleaseMap", (s) => s.tp.get(1)), "innerReleaseMap", () => makeReleaseMap.makeReleaseMap), "exitEA", (s) => T.provideAll_(T.result(restore(T.map_(self.effect, ({
    tuple: [_, a]
  }) => a))), Tp.tuple(s.r, s.innerReleaseMap))), "releaseMapEntry", (s) => add.add((e) => T.flatten(T.zipWith_(T.result(releaseAll.releaseAll(e, import_ExecutionStrategy.sequential)(s.innerReleaseMap)), T.result(T.provideAll_(cleanup(s.exitEA), s.r)), (l, r) => T.done(T.exitZipRight_(l, r)), __trace)))(s.outerReleaseMap)), "a", (s) => T.done(s.exitEA)), (s) => Tp.tuple(s.releaseMapEntry, s.a))));
}
function onExit(cleanup, __trace) {
  return (self) => onExit_(self, cleanup, __trace);
}
function onExitFirst(cleanup, __trace) {
  return (self) => onExitFirst_(self, cleanup, __trace);
}
function onExitFirst_(self, cleanup, __trace) {
  return (0, import_managed.managedApply)(T.uninterruptibleMask(({
    restore
  }) => T.map_(T.bind_(T.bind_(T.bind_(T.bind_(T.let_(T.let_(T.bind_(T.do, "tp", () => T.environment()), "r", (s) => s.tp.get(0)), "outerReleaseMap", (s) => s.tp.get(1)), "innerReleaseMap", () => makeReleaseMap.makeReleaseMap), "exitEA", (s) => T.provideAll_(T.result(restore(T.map_(self.effect, ({
    tuple: [_, a]
  }) => a))), Tp.tuple(s.r, s.innerReleaseMap))), "releaseMapEntry", (s) => add.add((e) => T.flatten(T.zipWith_(T.result(T.provideAll_(cleanup(s.exitEA), s.r, __trace)), T.result(releaseAll.releaseAll(e, import_ExecutionStrategy.sequential)(s.innerReleaseMap)), (l, r) => T.done(T.exitZipRight_(l, r)))))(s.outerReleaseMap)), "a", (s) => T.done(s.exitEA)), (s) => Tp.tuple(s.releaseMapEntry, s.a))));
}
function provideSome_(self, f, __trace) {
  return (0, import_managed.managedApply)(T.accessM(({
    tuple: [r0, rm]
  }) => T.provideAll_(self.effect, Tp.tuple(f(r0), rm), __trace)));
}
function provideSome(f, __trace) {
  return (self) => provideSome_(self, f, __trace);
}
function provideAll(r, __trace) {
  return (self) => provideAll_(self, r);
}
function provideAll_(self, r, __trace) {
  return provideSome_(self, () => r, __trace);
}
class Reservation {
  constructor(acquire, release2) {
    this.acquire = acquire;
    this.release = release2;
  }
}
Reservation.of = (acquire, release2) => new Reservation(acquire, release2);
function makeReservation_(acquire, release2) {
  return Reservation.of(acquire, release2);
}
function makeReservation(release2) {
  return (acquire) => Reservation.of(acquire, release2);
}
function reserve(reservation, __trace) {
  return makeReserve(T.succeed(reservation), __trace);
}
function tap_(self, f, __trace) {
  return chain_(self, (a) => map_(f(a), () => a), __trace);
}
function tap(f, __trace) {
  return (self) => tap_(self, f, __trace);
}
function useNow(self, __trace) {
  return (0, import_use.use_)(self, T.succeed, __trace);
}
function useForever(self, __trace) {
  return (0, import_use.use_)(self, () => T.never, __trace);
}
function zip_(self, that, __trace) {
  return zipWith_(self, that, (a, a2) => [a, a2], __trace);
}
function zip(that, __trace) {
  return (self) => zip_(self, that, __trace);
}
function zipWith(that, f, __trace) {
  return (self) => zipWith_(self, that, f, __trace);
}
function zipWith_(self, that, f, __trace) {
  return chain_(self, (a) => map_(that, (a2) => f(a, a2)), __trace);
}
function zipWithPar(that, f, __trace) {
  return (self) => zipWithPar_(self, that, f, __trace);
}
function zipWithPar_(self, that, f, __trace) {
  return mapM_(makeManagedReleaseMap(import_ExecutionStrategy.parallel), (parallelReleaseMap) => {
    const innerMap = T.provideSome_(makeManagedReleaseMap(import_ExecutionStrategy.sequential).effect, (r) => Tp.tuple(r, parallelReleaseMap));
    return T.chain_(T.zip_(innerMap, innerMap, __trace), ({
      tuple: [{
        tuple: [_, l]
      }, {
        tuple: [__, r]
      }]
    }) => T.zipWithPar_(T.provideSome_(self.effect, (_2) => Tp.tuple(_2, l)), T.provideSome_(that.effect, (_2) => Tp.tuple(_2, r)), ({
      tuple: [_2, a]
    }, {
      tuple: [__2, a2]
    }) => f(a, a2), __trace));
  });
}
function managedReserve(self) {
  return T.map_(makeReleaseMap.makeReleaseMap, (releaseMap) => Reservation.of(T.map_(T.provideSome_(self.effect, (_) => Tp.tuple(_, releaseMap)), Tp.get(1)), (_) => releaseAll.releaseAll(_, T.sequential)(releaseMap)));
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Reservation,
  chain,
  chain_,
  ensuring,
  ensuring_,
  fail,
  failWith,
  finalizerRef,
  foldCauseM,
  foldCauseM_,
  make,
  makeInterruptible,
  makeInterruptible_,
  makeManagedReleaseMap,
  makeReservation,
  makeReservation_,
  makeReserve,
  make_,
  managedReserve,
  map,
  mapM,
  mapM_,
  map_,
  onExit,
  onExitFirst,
  onExitFirst_,
  onExit_,
  provideAll,
  provideAll_,
  provideSome,
  provideSome_,
  reserve,
  succeedWith,
  tap,
  tap_,
  useForever,
  useNow,
  zip,
  zipWith,
  zipWithPar,
  zipWithPar_,
  zipWith_,
  zip_
});
