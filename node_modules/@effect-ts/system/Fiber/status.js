var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var status_exports = {};
__export(status_exports, {
  Done: () => Done,
  Finishing: () => Finishing,
  Running: () => Running,
  Suspended: () => Suspended,
  isDone: () => isDone,
  toFinishing: () => toFinishing,
  toFinishingSafe: () => toFinishingSafe,
  withInterrupting: () => withInterrupting,
  withInterruptingSafe: () => withInterruptingSafe
});
var St = __toESM(require("../Structural/index.js"));
var S = __toESM(require("../Sync/index.js"));
class Done {
  constructor() {
    this._tag = "Done";
  }
  get [St.hashSym]() {
    return St.hashString(this._tag);
  }
  [St.equalsSym](that) {
    return that instanceof Done;
  }
}
class Finishing {
  constructor(interrupting) {
    this.interrupting = interrupting;
    this._tag = "Finishing";
  }
  get [St.hashSym]() {
    return St.combineHash(St.hashString(this._tag), St.hash(this.interrupting));
  }
  [St.equalsSym](that) {
    return that instanceof Finishing && this.interrupting === that.interrupting;
  }
}
class Running {
  constructor(interrupting) {
    this.interrupting = interrupting;
    this._tag = "Running";
  }
  get [St.hashSym]() {
    return St.combineHash(St.hashString(this._tag), St.hash(this.interrupting));
  }
  [St.equalsSym](that) {
    return that instanceof Running && this.interrupting === that.interrupting;
  }
}
class Suspended {
  constructor(previous, interruptible, epoch, blockingOn) {
    this.previous = previous;
    this.interruptible = interruptible;
    this.epoch = epoch;
    this.blockingOn = blockingOn;
    this._tag = "Suspended";
  }
  get [St.hashSym]() {
    return St.combineHash(St.combineHash(St.hashString(this._tag), St.hashPlainObject({
      previous: this.previous,
      interruptible: this.interruptible,
      epoch: this.epoch
    })), St.hashArray(this.blockingOn));
  }
  [St.equalsSym](that) {
    return that instanceof Suspended && St.equals(this.previous, that.previous) && this.interruptible === that.interruptible && this.epoch === that.epoch && this.eqArr(this.blockingOn, that.blockingOn);
  }
  eqArr(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    return a.every((v, i) => St.equals(v, b[i]));
  }
}
function isDone(s) {
  return s._tag === "Done";
}
function withInterruptingSafe(b) {
  return (s) => {
    return S.gen(function* (_) {
      switch (s._tag) {
        case "Done": {
          return s;
        }
        case "Finishing": {
          return new Finishing(b);
        }
        case "Running": {
          return new Running(b);
        }
        case "Suspended": {
          return new Suspended(yield* _(withInterruptingSafe(b)(s.previous)), s.interruptible, s.epoch, s.blockingOn);
        }
      }
    });
  };
}
function withInterrupting(b) {
  return (s) => S.run(withInterruptingSafe(b)(s));
}
function toFinishing(s) {
  return S.run(toFinishingSafe(s));
}
function toFinishingSafe(s) {
  return S.gen(function* (_) {
    switch (s._tag) {
      case "Done": {
        return s;
      }
      case "Finishing": {
        return s;
      }
      case "Running": {
        return s;
      }
      case "Suspended": {
        return yield* _(toFinishingSafe(s.previous));
      }
    }
  });
}
module.exports = __toCommonJS(status_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Done,
  Finishing,
  Running,
  Suspended,
  isDone,
  toFinishing,
  toFinishingSafe,
  withInterrupting,
  withInterruptingSafe
});
