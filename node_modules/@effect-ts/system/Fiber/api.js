var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var api_exports = {};
__export(api_exports, {
  as: () => as,
  asUnit: () => asUnit,
  await: () => wait,
  collectAll: () => collectAll,
  done: () => done,
  fail: () => fail,
  fold: () => fold,
  fromEffect: () => fromEffect,
  halt: () => halt,
  interruptAll: () => interruptAll,
  interruptAllAs: () => interruptAllAs,
  interruptAs: () => interruptAs,
  interruptFork: () => interruptFork,
  joinAll: () => joinAll,
  makeSynthetic: () => makeSynthetic,
  map: () => map,
  mapFiber: () => mapFiber,
  mapFiber_: () => mapFiber_,
  mapM: () => mapM,
  map_: () => map_,
  never: () => never,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  succeed: () => succeed,
  toManaged: () => toManaged,
  unit: () => unit,
  waitAll: () => waitAll,
  zipLeft_: () => zipLeft_,
  zipRight_: () => zipRight_,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var Cause = __toESM(require("../Cause/core.js"));
var import_reduceRight = require("../Collections/Immutable/Chunk/api/reduceRight.js");
var Chunk = __toESM(require("../Collections/Immutable/Chunk/core.js"));
var E = __toESM(require("../Either/index.js"));
var Exit = __toESM(require("../Exit/api.js"));
var import_Function = require("../Function/index.js");
var IT = __toESM(require("../Iterable/index.js"));
var import_core = require("../Managed/core.js");
var O = __toESM(require("../Option/index.js"));
var T = __toESM(require("./_internal/effect-api.js"));
var Fiber = __toESM(require("./core.js"));
var import_interrupt = require("./interrupt.js");
function fromEffect(effect) {
  return T.map_(T.result(effect), done);
}
function interruptAllAs(id) {
  return (fs) => IT.reduce_(fs, T.unit, (io, f) => T.asUnit(T.chain_(io, () => f.interruptAs(id))));
}
function interruptAll(fs) {
  return T.chain_(T.fiberId, (id) => interruptAllAs(id)(fs));
}
function interruptFork(fiber) {
  return T.asUnit(T.forkDaemon((0, import_interrupt.interrupt)(fiber)));
}
function mapM(f) {
  return (fiber) => ({
    await: T.chain_(fiber.await, Exit.forEach(f)),
    getRef: (ref) => fiber.getRef(ref),
    inheritRefs: fiber.inheritRefs,
    interruptAs: (id) => T.chain_(fiber.interruptAs(id), Exit.forEach(f)),
    poll: T.chain_(fiber.poll, O.fold(() => T.succeed(O.none), (a) => T.map_(Exit.forEach_(a, f), O.some)))
  });
}
function map(f) {
  return mapM((a) => T.succeed(f(a)));
}
function joinAll(as2) {
  return T.tap_(T.chain_(waitAll(as2), T.done), () => T.forEach_(as2, (f) => f.inheritRefs));
}
function waitAll(as2) {
  return T.result(T.forEachPar_(as2, (f) => T.chain_(f.await, T.done)));
}
function map_(fiber, f) {
  return map(f)(fiber);
}
function mapFiber(f) {
  return (fiber) => T.map_(fiber.await, (e) => {
    switch (e._tag) {
      case "Success": {
        return f(e.value);
      }
      case "Failure": {
        return halt(e.cause);
      }
    }
  });
}
function mapFiber_(fiber, f) {
  return T.map_(fiber.await, (e) => {
    switch (e._tag) {
      case "Success": {
        return f(e.value);
      }
      case "Failure": {
        return halt(e.cause);
      }
    }
  });
}
function orElse(that) {
  return (fiber) => ({
    await: T.zipWith_(fiber.await, that.await, (a, b) => a._tag === "Success" ? a : b),
    getRef: (ref) => T.zipWith_(fiber.getRef(ref), that.getRef(ref), (a, b) => a === ref.initial ? b : a),
    inheritRefs: T.chain_(fiber.inheritRefs, () => that.inheritRefs),
    interruptAs: (id) => T.chain_(fiber.interruptAs(id), () => that.interruptAs(id)),
    poll: T.zipWith_(fiber.poll, that.poll, (a, b) => {
      switch (a._tag) {
        case "Some": {
          return a.value._tag === "Success" ? a : b;
        }
        case "None": {
          return O.none;
        }
      }
    })
  });
}
function orElseEither(that) {
  return (fiber) => orElse(map_(that, E.right))(map_(fiber, E.left));
}
function as(b) {
  return (fiber) => map_(fiber, () => b);
}
function asUnit(fiber) {
  return map_(fiber, () => void 0);
}
function zipWith_(fiberA, fiberB, f) {
  return {
    getRef: (ref) => T.zipWith_(fiberA.getRef(ref), fiberB.getRef(ref), (a, b) => ref.join(a, b)),
    inheritRefs: T.chain_(fiberA.inheritRefs, () => fiberB.inheritRefs),
    interruptAs: (id) => T.zipWith_(fiberA.interruptAs(id), fiberB.interruptAs(id), (ea, eb) => Exit.zipWith_(ea, eb, f, Cause.both)),
    poll: T.zipWith_(fiberA.poll, fiberB.poll, (oa, ob) => O.chain_(oa, (ea) => O.map_(ob, (eb) => Exit.zipWith_(ea, eb, f, Cause.both)))),
    await: T.result(T.zipWithPar_(T.chain_(fiberA.await, T.done), T.chain_(fiberB.await, T.done), f))
  };
}
function zip_(fiberA, fiberB) {
  return zipWith_(fiberA, fiberB, (a, b) => [a, b]);
}
function zipRight_(fiberA, fiberB) {
  return zipWith_(fiberA, fiberB, (_, b) => b);
}
function zipLeft_(fiberA, fiberB) {
  return zipWith_(fiberA, fiberB, (a, _) => a);
}
function collectAll(fibers) {
  return {
    getRef: (ref) => T.reduce_(fibers, ref.initial, (a, fiber) => T.map_(fiber.getRef(ref), (a2) => ref.join(a, a2))),
    inheritRefs: T.forEachUnit_(fibers, (f) => f.inheritRefs),
    interruptAs: (fiberId) => T.map_(T.forEach_(fibers, (f) => f.interruptAs(fiberId)), (0, import_reduceRight.reduceRight)(Exit.succeed(Chunk.empty()), (a, b) => Exit.zipWith_(a, b, (_a, _b) => Chunk.prepend_(_b, _a), Cause.both))),
    poll: T.map_(T.forEach_(fibers, (f) => f.poll), (0, import_reduceRight.reduceRight)(O.some(Exit.succeed(Chunk.empty())), (a, b) => O.fold_(a, () => O.none, (ra) => O.fold_(b, () => O.none, (rb) => O.some(Exit.zipWith_(ra, rb, (_a, _b) => Chunk.prepend_(_b, _a), Cause.both)))))),
    await: waitAll(fibers)
  };
}
function makeSynthetic(_) {
  return new Fiber.Synthetic(_.await, _.getRef, _.inheritRefs, _.interruptAs, _.poll);
}
function fold(runtime, syntetic) {
  return (fiber) => {
    switch (fiber._tag) {
      case "RuntimeFiber": {
        return runtime(fiber);
      }
      case "SyntheticFiber": {
        return syntetic(fiber);
      }
    }
  };
}
function done(exit) {
  return {
    await: T.succeed(exit),
    getRef: (ref) => T.succeed(ref.initial),
    inheritRefs: T.unit,
    interruptAs: () => T.succeed(exit),
    poll: T.succeed(O.some(exit))
  };
}
function succeed(a) {
  return done(Exit.succeed(a));
}
function fail(e) {
  return done(Exit.fail(e));
}
function halt(cause) {
  return done(Exit.halt(cause));
}
function interruptAs(id) {
  return done(Exit.interrupt(id));
}
function toManaged(fiber) {
  return (0, import_core.make)(import_interrupt.interrupt)(T.succeed(fiber));
}
const never = {
  await: T.never,
  getRef: (fiberRef) => T.succeed(fiberRef.initial),
  interruptAs: /* @__PURE__ */ (0, import_Function.constant)(T.never),
  inheritRefs: T.unit,
  poll: /* @__PURE__ */ T.succeed(O.none)
};
const unit = /* @__PURE__ */ succeed(void 0);
function wait(fiber) {
  return fiber.await;
}
module.exports = __toCommonJS(api_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  as,
  asUnit,
  await,
  collectAll,
  done,
  fail,
  fold,
  fromEffect,
  halt,
  interruptAll,
  interruptAllAs,
  interruptAs,
  interruptFork,
  joinAll,
  makeSynthetic,
  map,
  mapFiber,
  mapFiber_,
  mapM,
  map_,
  never,
  orElse,
  orElseEither,
  succeed,
  toManaged,
  unit,
  waitAll,
  zipLeft_,
  zipRight_,
  zipWith_,
  zip_
});
