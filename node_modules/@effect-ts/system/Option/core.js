var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  None: () => None,
  PartialException: () => PartialException,
  PartialExceptionTypeId: () => PartialExceptionTypeId,
  Some: () => Some,
  ap: () => ap,
  ap_: () => ap_,
  chain: () => chain,
  chain_: () => chain_,
  duplicate: () => duplicate,
  emptyOf: () => emptyOf,
  exists: () => exists,
  exists_: () => exists_,
  extend: () => extend,
  extend_: () => extend_,
  flatten: () => flatten,
  fold: () => fold,
  fold_: () => fold_,
  fromEither: () => fromEither,
  fromNullable: () => fromNullable,
  fromPredicate: () => fromPredicate,
  fromPredicate_: () => fromPredicate_,
  getLeft: () => getLeft,
  getOrElse: () => getOrElse,
  getOrElseS: () => getOrElseS,
  getOrElseS_: () => getOrElseS_,
  getOrElse_: () => getOrElse_,
  getRefinement: () => getRefinement,
  getRight: () => getRight,
  isNone: () => isNone,
  isSome: () => isSome,
  map: () => map,
  mapNullable: () => mapNullable,
  map_: () => map_,
  none: () => none,
  partial: () => partial,
  some: () => some,
  tap: () => tap,
  tap_: () => tap_,
  toNullable: () => toNullable,
  toUndefined: () => toUndefined,
  tryCatch: () => tryCatch,
  zip: () => zip,
  zipFirst: () => zipFirst,
  zipFirst_: () => zipFirst_,
  zipSecond: () => zipSecond,
  zipSecond_: () => zipSecond_,
  zip_: () => zip_
});
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var import_core = require("../Function/core.js");
var St = __toESM(require("../Structural/index.js"));
const _noneHash = /* @__PURE__ */ St.hashString("@effect-ts/system/Option/None");
const _someHash = /* @__PURE__ */ St.hashString("@effect-ts/system/Option/Some");
class None {
  constructor() {
    this._tag = "None";
  }
  [St.equalsSym](that) {
    return that instanceof None;
  }
  get [St.hashSym]() {
    return _noneHash;
  }
}
class Some {
  constructor(value) {
    this.value = value;
    this._tag = "Some";
  }
  [St.equalsSym](that) {
    return that instanceof Some && St.equals(this.value, that.value);
  }
  get [St.hashSym]() {
    return St.combineHash(_someHash, St.hash(this.value));
  }
}
const none = /* @__PURE__ */ new None();
function emptyOf() {
  return none;
}
function some(a) {
  return new Some(a);
}
function ap_(fab, fa) {
  return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));
}
function ap(fa) {
  return (fab) => ap_(fab, fa);
}
function zip_(fa, fb) {
  return chain_(fa, (a) => map_(fb, (b) => Tp.tuple(a, b)));
}
function zip(fb) {
  return (fa) => zip_(fa, fb);
}
function zipFirst(fb) {
  return (fa) => zipFirst_(fa, fb);
}
function zipFirst_(fa, fb) {
  return ap_(map_(fa, (a) => () => a), fb);
}
function zipSecond(fb) {
  return (fa) => zipSecond_(fa, fb);
}
function zipSecond_(fa, fb) {
  return ap_(map_(fa, () => (b) => b), fb);
}
function chain_(self, f) {
  return isNone(self) ? none : f(self.value);
}
function chain(f) {
  return (self) => chain_(self, f);
}
function tap(f) {
  return (ma) => chain_(ma, (a) => map_(f(a), () => a));
}
function tap_(ma, f) {
  return chain_(ma, (a) => map_(f(a), () => a));
}
function flatten(fa) {
  return chain_(fa, import_core.identity);
}
function duplicate(ma) {
  return isNone(ma) ? none : some(ma);
}
function exists(predicate) {
  return (ma) => isNone(ma) ? false : predicate(ma.value);
}
function exists_(ma, predicate) {
  return isNone(ma) ? false : predicate(ma.value);
}
function extend(f) {
  return (self) => extend_(self, f);
}
function extend_(self, f) {
  return isNone(self) ? none : some(f(self));
}
function fold(onNone, onSome) {
  return (ma) => fold_(ma, onNone, onSome);
}
function fold_(ma, onNone, onSome) {
  return isNone(ma) ? onNone() : onSome(ma.value);
}
function fromEither(ma) {
  return ma._tag === "Left" ? none : some(ma.right);
}
function fromNullable(a) {
  return a == null ? none : some(a);
}
function fromPredicate(predicate) {
  return (a) => predicate(a) ? some(a) : none;
}
function fromPredicate_(a, predicate) {
  return predicate(a) ? some(a) : none;
}
function getLeft(ma) {
  return ma._tag === "Right" ? none : some(ma.left);
}
function getOrElse(onNone) {
  return (o) => getOrElse_(o, onNone);
}
function getOrElseS(onNone) {
  return getOrElse(onNone);
}
function getOrElse_(ma, onNone) {
  return ma._tag === "None" ? onNone() : ma.value;
}
function getOrElseS_(ma, onNone) {
  return getOrElse_(ma, onNone);
}
function getRefinement(getOption) {
  return (a) => isSome(getOption(a));
}
function getRight(ma) {
  return ma._tag === "Left" ? none : some(ma.right);
}
function isNone(fa) {
  return fa._tag === "None";
}
function isSome(fa) {
  return fa._tag === "Some";
}
function map_(ma, f) {
  return isNone(ma) ? none : some(f(ma.value));
}
function map(f) {
  return (fa) => map_(fa, f);
}
function mapNullable(f) {
  return (ma) => isNone(ma) ? none : fromNullable(f(ma.value));
}
function toNullable(ma) {
  return isNone(ma) ? null : ma.value;
}
function toUndefined(ma) {
  return isNone(ma) ? void 0 : ma.value;
}
function tryCatch(f) {
  try {
    return some(f());
  } catch (e) {
    return none;
  }
}
const PartialExceptionTypeId = /* @__PURE__ */ Symbol();
class PartialException {
  constructor() {
    this._typeId = PartialExceptionTypeId;
  }
}
function raisePartial() {
  throw new PartialException();
}
function partial(f) {
  return (...args) => {
    try {
      return some(f(raisePartial)(...args));
    } catch (e) {
      if (e instanceof PartialException) {
        return none;
      }
      throw e;
    }
  };
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  None,
  PartialException,
  PartialExceptionTypeId,
  Some,
  ap,
  ap_,
  chain,
  chain_,
  duplicate,
  emptyOf,
  exists,
  exists_,
  extend,
  extend_,
  flatten,
  fold,
  fold_,
  fromEither,
  fromNullable,
  fromPredicate,
  fromPredicate_,
  getLeft,
  getOrElse,
  getOrElseS,
  getOrElseS_,
  getOrElse_,
  getRefinement,
  getRight,
  isNone,
  isSome,
  map,
  mapNullable,
  map_,
  none,
  partial,
  some,
  tap,
  tap_,
  toNullable,
  toUndefined,
  tryCatch,
  zip,
  zipFirst,
  zipFirst_,
  zipSecond,
  zipSecond_,
  zip_
});
