var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var semaphore_exports = {};
__export(semaphore_exports, {
  Semaphore: () => Semaphore,
  available: () => available,
  makeSemaphore: () => makeSemaphore,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore,
  withPermit: () => withPermit,
  withPermitManaged: () => withPermitManaged,
  withPermit_: () => withPermit_,
  withPermits: () => withPermits,
  withPermitsManaged: () => withPermitsManaged,
  withPermits_: () => withPermits_
});
var L = __toESM(require("../Collections/Immutable/List/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var O = __toESM(require("../Option/index.js"));
var R = __toESM(require("../Ref/index.js"));
var import_ImmutableQueue = require("../Support/ImmutableQueue/index.js");
var T = __toESM(require("./effect.js"));
var M = __toESM(require("./managed.js"));
var P = __toESM(require("./promise.js"));
var import_state = require("./state.js");
class Semaphore {
  constructor(state) {
    this.state = state;
    this.loop = this.loop.bind(this);
    this.restore = this.restore.bind(this);
    this.releaseN = this.releaseN.bind(this);
    this.restore = this.restore.bind(this);
  }
  get available() {
    return T.map_(this.state.get, E.fold(() => 0, import_Function.identity));
  }
  loop(n, state, acc) {
    while (1) {
      switch (state._tag) {
        case "Right": {
          return Tp.tuple(acc, E.right(n + state.right));
        }
        case "Left": {
          const d = state.left.dequeue();
          if (O.isNone(d)) {
            return Tp.tuple(acc, E.right(n));
          } else {
            const {
              tuple: [{
                tuple: [p, m]
              }, q]
            } = d.value;
            if (n > m) {
              n = n - m;
              state = E.left(q);
              acc = T.zipLeft_(acc, P.succeed_(p, void 0));
            } else if (n === m) {
              return Tp.tuple(T.zipLeft_(acc, P.succeed_(p, void 0)), E.left(q));
            } else {
              return Tp.tuple(acc, E.left(q.prepend(Tp.tuple(p, m - n))));
            }
          }
          break;
        }
      }
    }
    throw new Error("Bug: we should never get here");
  }
  releaseN(toRelease) {
    return T.uninterruptible(T.flatten(T.chain_((0, import_state.assertNonNegative)(toRelease), () => R.modify_(this.state, (s) => this.loop(toRelease, s, T.unit)))));
  }
  restore(p, n) {
    return T.flatten(R.modify_(this.state, E.fold((q) => O.fold_(q.find(({
      tuple: [a]
    }) => a === p), () => Tp.tuple(this.releaseN(n), E.left(q)), (x) => Tp.tuple(this.releaseN(n - x[1]), E.left(q.filter(({
      tuple: [a]
    }) => a !== p)))), (m) => Tp.tuple(T.unit, E.right(n + m)))));
  }
  prepare(n) {
    if (n === 0) {
      return T.succeed(new import_state.Acquisition(T.unit, T.unit));
    } else {
      return T.chain_(P.make(), (p) => R.modify_(this.state, E.fold((q) => Tp.tuple(new import_state.Acquisition(P.await(p), this.restore(p, n)), E.left(q.push(Tp.tuple(p, n)))), (m) => {
        if (m >= n) {
          return Tp.tuple(new import_state.Acquisition(T.unit, this.releaseN(n)), E.right(m - n));
        }
        return Tp.tuple(new import_state.Acquisition(P.await(p), this.restore(p, n)), E.left(new import_ImmutableQueue.ImmutableQueue(L.of(Tp.tuple(p, n - m)))));
      })));
    }
  }
}
function withPermits_(e, s, n) {
  return T.bracket_(s.prepare(n), (a) => T.chain_(a.waitAcquire, () => e), (a) => a.release);
}
function withPermits(s, n) {
  return (e) => T.bracket_(s.prepare(n), (a) => T.chain_(a.waitAcquire, () => e), (a) => a.release);
}
function withPermit_(self, s) {
  return withPermits_(self, s, 1);
}
function withPermit(s) {
  return (self) => withPermit_(self, s);
}
function withPermitsManaged(s, n) {
  return M.makeReserve(T.map_(s.prepare(n), (a) => M.makeReservation_(a.waitAcquire, () => a.release)));
}
function withPermitManaged(s) {
  return withPermitsManaged(s, 1);
}
function available(s) {
  return s.available;
}
function makeSemaphore(permits) {
  return T.map_(R.makeRef(E.right(permits)), (state) => new Semaphore(state));
}
function unsafeMakeSemaphore(permits) {
  const state = R.unsafeMakeRef(E.right(permits));
  return new Semaphore(state);
}
module.exports = __toCommonJS(semaphore_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Semaphore,
  available,
  makeSemaphore,
  unsafeMakeSemaphore,
  withPermit,
  withPermitManaged,
  withPermit_,
  withPermits,
  withPermitsManaged,
  withPermits_
});
