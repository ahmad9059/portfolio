var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var utils_exports = {};
__export(utils_exports, {
  addToCache: () => addToCache,
  areArraysEqual: () => areArraysEqual,
  areMapsEqual: () => areMapsEqual,
  areObjectsEqual: () => areObjectsEqual,
  areRegExpsEqual: () => areRegExpsEqual,
  areSetsEqual: () => areSetsEqual,
  createCircularEqualCreator: () => createCircularEqualCreator,
  getNewCache: () => getNewCache,
  getNewCacheFallback: () => getNewCacheFallback,
  hasPair: () => hasPair,
  hasValue: () => hasValue,
  isPlainObject: () => isPlainObject,
  isPromiseLike: () => isPromiseLike,
  isReactElement: () => isReactElement,
  sameValueZeroEqual: () => sameValueZeroEqual,
  toPairs: () => toPairs,
  toValues: () => toValues
});
const HAS_WEAKSET_SUPPORT = typeof WeakSet === "function";
const {
  keys
} = Object;
function addToCache(value, cache) {
  if (value && typeof value === "object") {
    cache.add(value);
  }
}
function hasPair(pairs, pairToMatch, isEqual, meta) {
  const {
    length
  } = pairs;
  let pair;
  for (let index = 0; index < length; index++) {
    pair = pairs[index];
    if (isEqual(pair[0], pairToMatch[0], meta) && isEqual(pair[1], pairToMatch[1], meta)) {
      return true;
    }
  }
  return false;
}
function hasValue(values, valueToMatch, isEqual, meta) {
  const {
    length
  } = values;
  for (let index = 0; index < length; index++) {
    if (isEqual(values[index], valueToMatch, meta)) {
      return true;
    }
  }
  return false;
}
function sameValueZeroEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function isPlainObject(value) {
  return value.constructor === Object || value.constructor == null;
}
function isPromiseLike(value) {
  return !!value && typeof value.then === "function";
}
function isReactElement(value) {
  return !!(value && value.$$typeof);
}
function getNewCacheFallback() {
  return /* @__PURE__ */ Object.create({
    _values: [],
    add(value) {
      this._values.push(value);
    },
    has(value) {
      return this._values.indexOf(value) !== -1;
    }
  });
}
const getNewCache = /* @__PURE__ */ ((canUseWeakMap) => {
  if (canUseWeakMap) {
    return function _getNewCache() {
      return /* @__PURE__ */ new WeakSet();
    };
  }
  return getNewCacheFallback;
})(HAS_WEAKSET_SUPPORT);
function createCircularEqualCreator(isEqual) {
  return function createCircularEqual(comparator) {
    const _comparator = isEqual ? isEqual(comparator) : comparator;
    return function circularEqual(a, b, cache = getNewCache()) {
      const hasA = cache.has(a);
      const hasB = cache.has(b);
      if (hasA || hasB) {
        return hasA && hasB;
      }
      addToCache(a, cache);
      addToCache(b, cache);
      return _comparator(a, b, cache);
    };
  };
}
function toPairs(map) {
  const pairs = new Array(map.size);
  let index = 0;
  map.forEach((value, key) => {
    pairs[index++] = [key, value];
  });
  return pairs;
}
function toValues(set) {
  const values = new Array(set.size);
  let index = 0;
  set.forEach((value) => {
    values[index++] = value;
  });
  return values;
}
function areArraysEqual(a, b, isEqual, meta) {
  const {
    length
  } = a;
  if (b.length !== length) {
    return false;
  }
  for (let index = 0; index < length; index++) {
    if (!isEqual(a[index], b[index], meta)) {
      return false;
    }
  }
  return true;
}
function areMapsEqual(a, b, isEqual, meta) {
  if (a.size !== b.size) {
    return false;
  }
  const pairsA = toPairs(a);
  const pairsB = toPairs(b);
  return isEqual(pairsA, pairsB, meta);
}
const OWNER = "_owner";
const hasOwnProperty = /* @__PURE__ */ Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
function areObjectsEqual(a, b, isEqual, meta) {
  const keysA = keys(a);
  const {
    length
  } = keysA;
  if (keys(b).length !== length) {
    return false;
  }
  let key;
  for (let index = 0; index < length; index++) {
    key = keysA[index];
    if (!hasOwnProperty(b, key)) {
      return false;
    }
    if (key === OWNER && isReactElement(a)) {
      if (!isReactElement(b)) {
        return false;
      }
    } else if (!isEqual(a[key], b[key], meta)) {
      return false;
    }
  }
  return true;
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.unicode === b.unicode && a.sticky === b.sticky && a.lastIndex === b.lastIndex;
}
function areSetsEqual(a, b, isEqual, meta) {
  if (a.size !== b.size) {
    return false;
  }
  const valuesA = toValues(a);
  const valuesB = toValues(b);
  return isEqual(valuesA, valuesB, meta);
}
module.exports = __toCommonJS(utils_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addToCache,
  areArraysEqual,
  areMapsEqual,
  areObjectsEqual,
  areRegExpsEqual,
  areSetsEqual,
  createCircularEqualCreator,
  getNewCache,
  getNewCacheFallback,
  hasPair,
  hasValue,
  isPlainObject,
  isPromiseLike,
  isReactElement,
  sameValueZeroEqual,
  toPairs,
  toValues
});
