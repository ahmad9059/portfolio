var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var HasHash_exports = {};
__export(HasHash_exports, {
  _combineHash: () => _combineHash,
  _hash: () => _hash,
  _hashArray: () => _hashArray,
  _hashIterator: () => _hashIterator,
  _hashMiscRef: () => _hashMiscRef,
  _hashNumber: () => _hashNumber,
  _hashObject: () => _hashObject,
  _hashPlainObject: () => _hashPlainObject,
  _hashString: () => _hashString,
  combineHash: () => combineHash,
  hasHash: () => hasHash,
  hash: () => hash,
  hashArgs: () => hashArgs,
  hashArray: () => hashArray,
  hashIterator: () => hashIterator,
  hashMiscRef: () => hashMiscRef,
  hashNumber: () => hashNumber,
  hashObject: () => hashObject,
  hashPlainObject: () => hashPlainObject,
  hashString: () => hashString,
  hashSym: () => hashSym,
  hashUnknown: () => hashUnknown,
  isDefined: () => isDefined,
  isIterable: () => isIterable,
  opt: () => opt,
  randomInt: () => randomInt
});
var import_PCG = require("../../Random/PCG/index.js");
const hashSym = /* @__PURE__ */ Symbol();
function hasHash(u) {
  return typeof u === "object" && u !== null && hashSym in u;
}
let _current = 0;
function opt(n) {
  return n & 3221225471 | n >>> 1 & 1073741824;
}
function hash(arg) {
  return opt(_hash(arg));
}
function hashUnknown(arg) {
  return opt(_hash(arg));
}
function hashArray(arr) {
  return opt(_hashArray(arr));
}
function hashArgs() {
  let h = 5381;
  for (let i = 0; i < arguments.length; i++) {
    h = _combineHash(h, hash(arguments[i]));
  }
  return opt(h);
}
function combineHash(a, b) {
  return opt(_combineHash(a, b));
}
function hashObject(value) {
  return opt(_hashObject(value));
}
function hashMiscRef(o) {
  return opt(_hashMiscRef(o));
}
function hashIterator(it) {
  return opt(_hashIterator(it));
}
function hashPlainObject(o) {
  return opt(_hashPlainObject(o));
}
function hashNumber(n) {
  return opt(_hashNumber(n));
}
function hashString(str) {
  return opt(_hashString(str));
}
function isZero(value) {
  return value === null || value === void 0 || value === false;
}
const RANDOM = /* @__PURE__ */ new import_PCG.PCGRandom(/* @__PURE__ */ Math.random() * 4294967296 >>> 0);
const CACHE = /* @__PURE__ */ new WeakMap();
function randomInt() {
  return RANDOM.integer(2147483647);
}
function _hash(arg) {
  if (isZero(arg))
    return 0;
  if (typeof arg.valueOf === "function" && arg.valueOf !== Object.prototype.valueOf) {
    arg = arg.valueOf();
    if (isZero(arg))
      return 0;
  }
  switch (typeof arg) {
    case "number":
      return _hashNumber(arg);
    case "string":
      return _hashString(arg);
    case "function":
      return _hashMiscRef(arg);
    case "object":
      return _hashObject(arg);
    case "boolean":
      return arg === true ? 1 : 0;
    case "symbol":
      return _hashString(String(arg));
    case "bigint":
      return _hashString(arg.toString(10));
    case "undefined": {
      return 0;
    }
  }
}
function _hashArray(arr) {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = _combineHash(h, _hash(arr[i]));
  }
  return h;
}
function _combineHash(a, b) {
  return a * 53 ^ b;
}
function isDefined(value) {
  return value !== void 0;
}
function isIterable(value) {
  return Symbol.iterator in value;
}
function _hashObject(value) {
  if (hasHash(value)) {
    return value[hashSym];
  } else {
    let h = CACHE.get(value);
    if (isDefined(h))
      return h;
    h = _current++;
    CACHE.set(value, h);
    return h;
  }
}
function _hashMiscRef(o) {
  let h = CACHE.get(o);
  if (isDefined(h))
    return h;
  h = randomInt();
  CACHE.set(o, h);
  return h;
}
function _hashIterator(it) {
  let h = 6151;
  let current;
  while (!(current = it.next()).done) {
    h = _combineHash(h, hash(current.value));
  }
  return h;
}
function _hashPlainObject(o) {
  CACHE.set(o, randomInt());
  const keys = Object.keys(o).sort();
  let h = 12289;
  for (let i = 0; i < keys.length; i++) {
    h = _combineHash(h, _hashString(keys[i]));
    h = _combineHash(h, hash(o[keys[i]]));
  }
  return h;
}
function _hashNumber(n) {
  if (n !== n || n === Infinity)
    return 0;
  let h = n | 0;
  if (h !== n)
    h ^= n * 4294967295;
  while (n > 4294967295)
    h ^= n /= 4294967295;
  return n;
}
function _hashString(str) {
  let h = 5381, i = str.length;
  while (i)
    h = h * 33 ^ str.charCodeAt(--i);
  return h;
}
module.exports = __toCommonJS(HasHash_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  _combineHash,
  _hash,
  _hashArray,
  _hashIterator,
  _hashMiscRef,
  _hashNumber,
  _hashObject,
  _hashPlainObject,
  _hashString,
  combineHash,
  hasHash,
  hash,
  hashArgs,
  hashArray,
  hashIterator,
  hashMiscRef,
  hashNumber,
  hashObject,
  hashPlainObject,
  hashString,
  hashSym,
  hashUnknown,
  isDefined,
  isIterable,
  opt,
  randomInt
});
