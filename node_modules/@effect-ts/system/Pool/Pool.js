var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Pool_exports = {};
__export(Pool_exports, {
  DefaultPool: () => DefaultPool,
  fromIterable: () => fromIterable,
  get: () => get,
  invalidate: () => invalidate,
  invalidate_: () => invalidate_,
  make: () => make,
  makeFixed: () => makeFixed,
  makeWith: () => makeWith
});
var CS = __toESM(require("../Cause/index.js"));
var HS = __toESM(require("../Collections/Immutable/HashSet/index.js"));
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var T = __toESM(require("../Effect/index.js"));
var Ex = __toESM(require("../Exit/index.js"));
var F = __toESM(require("../Fiber/index.js"));
var import_Function = require("../Function/index.js");
var M = __toESM(require("../Managed/index.js"));
var Q = __toESM(require("../Queue/index.js"));
var Ref = __toESM(require("../Ref/index.js"));
var AT = __toESM(require("./Attempted.js"));
var STR = __toESM(require("./Strategy.js"));
class Pool {
}
T._E, T._A;
class PoolInternal extends Pool {
}
T._E, T._A;
function concrete(pool) {
}
function get(self) {
  concrete(self);
  return self.get();
}
function invalidate_(self, item) {
  concrete(self);
  return self.invalidate(item);
}
function invalidate(item) {
  return (self) => invalidate_(self, item);
}
class DefaultPool extends PoolInternal {
  constructor(creator, range, isShuttingDown, state, items, invalidated, track) {
    super();
    this.creator = creator;
    this.range = range;
    this.isShuttingDown = isShuttingDown;
    this.state = state;
    this.items = items;
    this.invalidated = invalidated;
    this.track = track;
    this.excess = this.excess.bind(this);
    this.get = this.get.bind(this);
    this.initialize = this.initialize.bind(this);
    this.invalidate = this.invalidate.bind(this);
    this.shrink = this.shrink.bind(this);
    this.allocate = this.allocate.bind(this);
    this.getAndShutdown = this.getAndShutdown.bind(this);
    this.shutdown = this.shutdown.bind(this);
  }
  excess() {
    return T.map_(this.state.get, ({
      free,
      size
    }) => size - Math.min(Tp.get_(this.range, 0), free));
  }
  get() {
    const acquire = T.chain_(this.isShuttingDown.get, (down) => {
      if (down) {
        return T.interrupt;
      } else {
        return T.flatten(Ref.modify_(this.state, ({
          free,
          size
        }) => {
          if (free > 0 || size >= Tp.get_(this.range, 1)) {
            return Tp.tuple(T.chain_(Q.take(this.items), (acquired) => {
              if (acquired.result._tag === "Success") {
                const item = acquired.result.value;
                return T.chain_(this.invalidated.get, (set) => {
                  if (HS.has_(set, item)) {
                    return T.zipRight_(T.zipRight_(Ref.update_(this.state, (state) => __spreadProps(__spreadValues({}, state), {
                      free: state.free + 1
                    })), this.allocate()), acquire);
                  } else {
                    return T.succeed(acquired);
                  }
                });
              } else {
                return T.succeed(acquired);
              }
            }), {
              size,
              free: free - 1
            });
          } else if (size >= 0) {
            return Tp.tuple(T.zipRight_(this.allocate(), acquire), {
              size: size + 1,
              free: free + 1
            });
          } else {
            return Tp.tuple(T.interrupt, {
              size,
              free
            });
          }
        }));
      }
    });
    const release = (attempted) => {
      if (AT.isFailure(attempted)) {
        return T.flatten(Ref.modify_(this.state, ({
          free,
          size
        }) => {
          if (size <= Tp.get_(this.range, 0)) {
            return Tp.tuple(this.allocate(), {
              size,
              free: free + 1
            });
          } else {
            return Tp.tuple(T.unit, {
              size: size - 1,
              free
            });
          }
        }));
      } else {
        return T.zipRight_(T.zipRight_(T.zipRight_(Ref.update_(this.state, (state) => __spreadProps(__spreadValues({}, state), {
          free: state.free + 1
        })), Q.offer_(this.items, attempted)), this.track(attempted.result)), T.whenM_(this.getAndShutdown(), this.isShuttingDown.get));
      }
    };
    return M.chain_(M.make_(acquire, release), AT.toManaged);
  }
  initialize() {
    return T.replicateMUnit_(T.uninterruptibleMask(({
      restore
    }) => T.flatten(Ref.modify_(this.state, ({
      free,
      size
    }) => {
      if (size < Tp.get_(this.range, 0) && size >= 0) {
        return Tp.tuple(T.map_(T.tap_(T.tap_(T.tap_(T.bind_(T.bind_(T.bind_(T.do, "reservation", () => M.managedReserve(this.creator)), "exit", ({
          reservation
        }) => T.result(restore(reservation.acquire))), "attempted", ({
          exit,
          reservation
        }) => T.succeed(new AT.Attempted(exit, reservation.release(Ex.succeed(void 0))))), ({
          attempted
        }) => Q.offer_(this.items, attempted)), ({
          attempted
        }) => this.track(attempted.result)), () => T.whenM_(this.getAndShutdown(), this.isShuttingDown.get)), ({
          attempted
        }) => attempted), {
          size: size + 1,
          free: free + 1
        });
      } else {
        return Tp.tuple(T.unit, {
          size,
          free
        });
      }
    }))), Tp.get_(this.range, 0));
  }
  invalidate(item) {
    return Ref.update_(this.invalidated, (_) => HS.add_(_, item));
  }
  shrink() {
    return T.uninterruptible(T.flatten(Ref.modify_(this.state, ({
      free,
      size
    }) => {
      if (size > Tp.get_(this.range, 0) && free > 0) {
        return Tp.tuple(T.chain_(Q.take(this.items), (attempted) => T.zipRight_(T.zipRight_(AT.forEachUnit((a) => Ref.update_(this.invalidated, (_) => HS.remove_(_, a)))(attempted), attempted.finalizer), Ref.update_(this.state, (state) => __spreadProps(__spreadValues({}, state), {
          size: state.size - 1
        })))), {
          size,
          free: free - 1
        });
      } else {
        return Tp.tuple(T.unit, {
          size,
          free
        });
      }
    })));
  }
  allocate() {
    return T.uninterruptibleMask(({
      restore
    }) => T.map_(T.tap_(T.tap_(T.tap_(T.bind_(T.bind_(T.bind_(T.do, "reservation", () => M.managedReserve(this.creator)), "exit", ({
      reservation
    }) => T.result(restore(reservation.acquire))), "attempted", ({
      exit,
      reservation
    }) => T.succeed(new AT.Attempted(exit, reservation.release(Ex.succeed(void 0))))), ({
      attempted
    }) => Q.offer_(this.items, attempted)), ({
      attempted
    }) => this.track(attempted.result)), () => T.whenM_(this.getAndShutdown(), this.isShuttingDown.get)), ({
      attempted
    }) => attempted));
  }
  getAndShutdown() {
    return T.flatten(Ref.modify_(this.state, ({
      free,
      size
    }) => {
      if (free > 0) {
        return Tp.tuple(T.foldCauseM_(Q.take(this.items), (_) => T.unit, (attempted) => T.zipRight_(T.zipRight_(T.zipRight_(AT.forEachUnit((a) => Ref.update_(this.invalidated, (_) => HS.remove_(_, a)))(attempted), attempted.finalizer), Ref.update_(this.state, (state) => __spreadProps(__spreadValues({}, state), {
          size: state.size - 1
        }))), this.getAndShutdown())), {
          size,
          free: free - 1
        });
      } else if (size > 0) {
        return Tp.tuple(T.unit, {
          size,
          free
        });
      } else {
        return Tp.tuple(Q.shutdown(this.items), {
          size: size - 1,
          free
        });
      }
    }));
  }
  shutdown() {
    return T.flatten(Ref.modify_(this.isShuttingDown, (down) => {
      if (down) {
        return Tp.tuple(Q.awaitShutdown(this.items), true);
      } else {
        return Tp.tuple(T.zipRight_(this.getAndShutdown(), Q.awaitShutdown(this.items)), true);
      }
    }));
  }
}
function fromIterable(iterable0) {
  return M.map_(M.bind_(M.let_(M.bind_(M.bind_(M.do, "iterable", () => M.succeed(Array.from(iterable0))), "source", ({
    iterable
  }) => T.toManaged(Ref.makeRef(iterable))), "get", ({
    iterable,
    source
  }) => {
    if (!iterable.length) {
      return T.never;
    } else {
      return Ref.modify_(source, (a) => {
        if (a.length > 0) {
          return Tp.tuple(a[0], a.slice(1));
        }
        throw new CS.IllegalArgumentException("No item in array");
      });
    }
  }), "pool", ({
    get: get2,
    iterable
  }) => makeFixed(M.fromEffect(get2), iterable.length)), ({
    pool
  }) => pool);
}
function makeFixed(get2, min) {
  return makeWith(get2, Tp.tuple(min, min), new STR.None());
}
function make(get2, range, timeToLive) {
  return makeWith(get2, range, new STR.TimeToLive(timeToLive));
}
function makeWith(get2, range, strategy) {
  return M.map_(M.tap_(M.bind_(M.bind_(M.let_(M.bind_(M.bind_(M.bind_(M.bind_(M.bind_(M.bind_(M.do, "env", () => M.environment()), "down", () => T.toManaged(Ref.makeRef(false))), "state", () => T.toManaged(Ref.makeRef({
    size: 0,
    free: 0
  }))), "items", () => T.toManaged(Q.makeBounded(Tp.get_(range, 1)))), "inv", () => T.toManaged(Ref.makeRef(HS.make()))), "initial", () => T.toManaged(strategy.initial())), "pool", ({
    down,
    env,
    initial,
    inv,
    items,
    state
  }) => new DefaultPool(M.provideAll_(get2, env), range, down, state, items, inv, strategy.track(initial))), "fiber", ({
    pool
  }) => T.toManaged(T.forkDaemon(pool.initialize()))), "shrink", ({
    initial,
    pool
  }) => T.toManaged(T.forkDaemon(strategy.run(initial, pool.excess(), pool.shrink())))), ({
    fiber,
    pool,
    shrink
  }) => M.finalizer(T.zipRight_(T.zipRight_(F.interrupt(fiber), F.interrupt(shrink)), pool.shutdown()))), ({
    pool
  }) => pool);
}
module.exports = __toCommonJS(Pool_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DefaultPool,
  fromIterable,
  get,
  invalidate,
  invalidate_,
  make,
  makeFixed,
  makeWith
});
