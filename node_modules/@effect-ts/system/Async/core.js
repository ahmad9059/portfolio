var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  Async: () => Async,
  InterruptionState: () => InterruptionState,
  Tracer: () => Tracer,
  access: () => access,
  accessM: () => accessM,
  bimap: () => bimap,
  bimap_: () => bimap_,
  catchAll: () => catchAll,
  catchAll_: () => catchAll_,
  chain: () => chain,
  chain_: () => chain_,
  default: () => tryCatchOption_,
  delay: () => delay,
  done: () => done,
  either: () => either,
  environment: () => environment,
  fail: () => fail,
  failExit: () => failExit,
  fold: () => fold,
  foldM: () => foldM,
  foldM_: () => foldM_,
  fold_: () => fold_,
  fromEither: () => fromEither,
  interruptExit: () => interruptExit,
  map: () => map,
  mapError: () => mapError,
  mapError_: () => mapError_,
  map_: () => map_,
  orElseEither: () => orElseEither,
  orElseEither_: () => orElseEither_,
  promise: () => promise,
  provide: () => provide,
  provideAll: () => provideAll,
  provideAll_: () => provideAll_,
  provideSome: () => provideSome,
  runAsync: () => runAsync,
  runAsyncEnv: () => runAsyncEnv,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runPromiseExitEnv: () => runPromiseExitEnv,
  sleep: () => sleep,
  succeed: () => succeed,
  succeedWith: () => succeedWith,
  successExit: () => successExit,
  suspend: () => suspend,
  tap: () => tap,
  tapError: () => tapError,
  tap_: () => tap_,
  tracingContext: () => tracingContext,
  tryCatch: () => tryCatch,
  tryCatchOption: () => tryCatchOption,
  unfailable: () => unfailable,
  union: () => union,
  unionFn: () => unionFn,
  unit: () => unit,
  zip: () => zip,
  zipWith: () => zipWith,
  zipWith_: () => zipWith_,
  zip_: () => zip_
});
var Tp = __toESM(require("../Collections/Immutable/Tuple/index.js"));
var import_commons = require("../Effect/commons.js");
var E = __toESM(require("../Either/index.js"));
var import_Function = require("../Function/index.js");
var import_Stack = require("../Stack/index.js");
class Async {
}
function concrete(_) {
  return _;
}
class ISucceed extends Async {
  constructor(a) {
    super();
    this.a = a;
    this._asyncTag = "Succeed";
  }
}
class ISuspend extends Async {
  constructor(f) {
    super();
    this.f = f;
    this._asyncTag = "Suspend";
  }
}
class IFail extends Async {
  constructor(e) {
    super();
    this.e = e;
    this._asyncTag = "Fail";
  }
}
class IFlatMap extends Async {
  constructor(value, cont) {
    super();
    this.value = value;
    this.cont = cont;
    this._asyncTag = "FlatMap";
  }
}
class IFold extends Async {
  constructor(value, failure, success) {
    super();
    this.value = value;
    this.failure = failure;
    this.success = success;
    this._asyncTag = "Fold";
  }
}
class IAccess extends Async {
  constructor(access2) {
    super();
    this.access = access2;
    this._asyncTag = "Access";
  }
}
class IProvide extends Async {
  constructor(r, cont) {
    super();
    this.r = r;
    this.cont = cont;
    this._asyncTag = "Provide";
  }
}
class IPromise extends Async {
  constructor(promise2, onError) {
    super();
    this.promise = promise2;
    this.onError = onError;
    this._asyncTag = "Promise";
  }
}
class IDone extends Async {
  constructor(exit) {
    super();
    this.exit = exit;
    this._asyncTag = "Done";
  }
}
class FoldFrame {
  constructor(failure, apply) {
    this.failure = failure;
    this.apply = apply;
    this._asyncTag = "FoldFrame";
  }
}
class ApplyFrame {
  constructor(apply) {
    this.apply = apply;
    this._asyncTag = "ApplyFrame";
  }
}
class InterruptionState {
  constructor() {
    this.isInterrupted = false;
    this.listeners = /* @__PURE__ */ new Set();
  }
  listen(f) {
    this.listeners.add(f);
    return () => {
      this.listeners.delete(f);
    };
  }
  get interrupted() {
    return this.isInterrupted;
  }
  interrupt() {
    if (!this.isInterrupted) {
      this.isInterrupted = true;
      this.listeners.forEach((i) => {
        i();
      });
    }
  }
}
const failExit = (e) => ({
  _tag: "Failure",
  e
});
const interruptExit = {
  _tag: "Interrupt"
};
const successExit = (a) => ({
  _tag: "Success",
  a
});
class CancelablePromise {
  constructor(promiseFactory, is) {
    this.promiseFactory = promiseFactory;
    this.is = is;
    this.rejection = void 0;
    this.current = void 0;
    this.promise = () => {
      if (this.current) {
        throw new Error("Bug: promise() have been called twice");
      } else if (this.is.interrupted) {
        throw new Error("Bug: trying to create a promise already interrupted");
      } else {
        const onInterrupt = [];
        const removeListener = this.is.listen(() => {
          onInterrupt.forEach((f) => {
            f();
          });
          this.interrupt();
        });
        const p = new Promise((res, rej) => {
          this.rejection = rej;
          this.promiseFactory((f) => {
            onInterrupt.push(f);
          }).then((a) => {
            removeListener();
            if (!this.is.interrupted) {
              res(a);
            }
          }).catch((e) => {
            removeListener();
            if (!this.is.interrupted) {
              rej(e);
            }
          });
        });
        this.current = p;
        return p;
      }
    };
    this.interrupt = () => {
      var _a;
      (_a = this.rejection) === null || _a === void 0 ? void 0 : _a.call(this, interruptExit);
    };
  }
}
class Tracer {
  constructor() {
    this.running = /* @__PURE__ */ new Set();
    this.traced = this.traced.bind(this);
    this.wait = this.wait.bind(this);
    this.clear = this.clear.bind(this);
  }
  traced(promise2) {
    return async () => {
      const p = promise2();
      this.running.add(p);
      try {
        const a = await p;
        this.running.delete(p);
        return Promise.resolve(a);
      } catch (e) {
        this.running.delete(p);
        return Promise.reject(e);
      }
    };
  }
  async wait() {
    const t = await Promise.all(Array.from(this.running).map((p) => p.then((a) => successExit(a)).catch((e) => Promise.resolve(e))));
    return await new Promise((r) => {
      setTimeout(() => {
        r(t);
      }, 0);
    });
  }
  clear() {
    this.running.clear();
  }
}
const tracingContext = /* @__PURE__ */ new Tracer();
function runPromiseExitEnv(self, ri, is = new InterruptionState()) {
  return tracingContext.traced(async () => {
    let stack = void 0;
    let a = null;
    let r = ri;
    let failed = false;
    let curAsync = self;
    let cnt = 0;
    let interruptedLocal = false;
    function isInterruted() {
      return interruptedLocal || is.interrupted;
    }
    function pop() {
      const nextInstr = stack;
      if (nextInstr) {
        stack = stack === null || stack === void 0 ? void 0 : stack.previous;
      }
      return nextInstr === null || nextInstr === void 0 ? void 0 : nextInstr.value;
    }
    function push(cont) {
      stack = new import_Stack.Stack(cont, stack);
    }
    function findNextErrorHandler() {
      let unwinding = true;
      while (unwinding) {
        const nextInstr = pop();
        if (nextInstr == null) {
          unwinding = false;
        } else {
          if (nextInstr._asyncTag === "FoldFrame") {
            unwinding = false;
            push(new ApplyFrame(nextInstr.failure));
          }
        }
      }
    }
    while (curAsync != null && !isInterruted()) {
      if (cnt > 1e4) {
        await new Promise((r2) => {
          setTimeout(() => {
            r2(void 0);
          }, 0);
        });
        cnt = 0;
      }
      cnt += 1;
      const xp = curAsync;
      switch (xp._asyncTag) {
        case "FlatMap": {
          const nested = xp.value;
          const continuation = xp.cont;
          switch (nested._asyncTag) {
            case "Succeed": {
              curAsync = continuation(nested.a);
              break;
            }
            default: {
              curAsync = nested;
              push(new ApplyFrame(continuation));
            }
          }
          break;
        }
        case "Suspend": {
          curAsync = xp.f();
          break;
        }
        case "Succeed": {
          a = xp.a;
          const nextInstr = pop();
          if (nextInstr) {
            curAsync = nextInstr.apply(a);
          } else {
            curAsync = void 0;
          }
          break;
        }
        case "Fail": {
          findNextErrorHandler();
          const nextInst = pop();
          if (nextInst) {
            curAsync = nextInst.apply(xp.e);
          } else {
            failed = true;
            a = xp.e;
            curAsync = void 0;
          }
          break;
        }
        case "Fold": {
          curAsync = xp.value;
          push(new FoldFrame(xp.failure, xp.success));
          break;
        }
        case "Done": {
          switch (xp.exit._tag) {
            case "Failure": {
              curAsync = new IFail(xp.exit.e);
              break;
            }
            case "Interrupt": {
              interruptedLocal = true;
              curAsync = void 0;
              break;
            }
            case "Success": {
              curAsync = new ISucceed(xp.exit.a);
              break;
            }
          }
          break;
        }
        case "Access": {
          curAsync = xp.access(r);
          break;
        }
        case "Provide": {
          r = xp.r;
          curAsync = xp.cont;
          break;
        }
        case "Promise": {
          try {
            curAsync = new ISucceed(await new CancelablePromise((s) => xp.promise(s).catch((e) => Promise.reject(failExit(xp.onError(e)))), is).promise());
          } catch (e) {
            const e_ = e;
            switch (e_._tag) {
              case "Failure": {
                curAsync = new IFail(e_.e);
                break;
              }
              case "Interrupt": {
                interruptedLocal = true;
                curAsync = void 0;
                break;
              }
            }
          }
          break;
        }
      }
    }
    if (is.interrupted) {
      return interruptExit;
    }
    if (failed) {
      return failExit(a);
    }
    return successExit(a);
  })();
}
function runPromiseExit(self, is = new InterruptionState()) {
  return runPromiseExitEnv(self, {}, is);
}
async function runPromise(task, is = new InterruptionState()) {
  return runPromiseExit(task, is).then((e) => e._tag === "Failure" ? Promise.reject(e.e) : e._tag === "Interrupt" ? Promise.reject(e) : Promise.resolve(e.a));
}
function runAsync(task, cb) {
  const is = new InterruptionState();
  runPromiseExit(task, is).then(cb);
  return () => {
    is.interrupt();
  };
}
function runAsyncEnv(task, r, cb) {
  const is = new InterruptionState();
  runPromiseExitEnv(task, r, is).then(cb);
  return () => {
    is.interrupt();
  };
}
function chain(f) {
  return (self) => new IFlatMap(self, f);
}
function chain_(self, f) {
  return new IFlatMap(self, f);
}
function tap(f) {
  return (self) => tap_(self, f);
}
function tap_(self, f) {
  return chain_(self, (a) => map_(f(a), () => a));
}
function succeed(a) {
  return new ISucceed(a);
}
function fail(a) {
  return new IFail(a);
}
function map_(self, f) {
  return chain_(self, (a) => succeed(f(a)));
}
function map(f) {
  return (self) => map_(self, f);
}
function foldM_(self, failure, success) {
  return new IFold(self, failure, success);
}
function foldM(failure, success) {
  return (self) => foldM_(self, failure, success);
}
function fold(failure, success) {
  return (self) => fold_(self, failure, success);
}
function fold_(self, failure, success) {
  return foldM_(self, (e) => succeed(failure(e)), (a) => succeed(success(a)));
}
function catchAll(failure) {
  return (self) => catchAll_(self, failure);
}
function catchAll_(self, failure) {
  return foldM_(self, failure, (a) => succeed(a));
}
function bimap(f, g) {
  return (self) => bimap_(self, f, g);
}
function bimap_(self, f, g) {
  return foldM_(self, (e) => fail(f(e)), (a) => succeed(() => g(a)));
}
function mapError(f) {
  return (self) => mapError_(self, f);
}
function mapError_(self, f) {
  return catchAll_(self, (e) => fail(f(e)));
}
const unit = /* @__PURE__ */ succeed(void 0);
function provideSome(f) {
  return (self) => accessM((r) => provideAll(f(r))(self));
}
function provideAll(r) {
  return (self) => new IProvide(r, self);
}
function provideAll_(self, r) {
  return new IProvide(r, self);
}
function provide(r) {
  return (next) => provideSome((r0) => __spreadValues(__spreadValues({}, r0), r))(next);
}
function accessM(f) {
  return new IAccess(f);
}
function access(f) {
  return accessM((r) => succeed(f(r)));
}
function environment() {
  return accessM((r) => succeed(r));
}
function either(self) {
  return fold_(self, E.left, E.right);
}
function orElseEither(that) {
  return (self) => orElseEither_(self, that);
}
function orElseEither_(self, that) {
  return foldM_(self, () => map_(that(), (a) => E.right(a)), (a) => succeed(E.left(a)));
}
function zipWith(that, f) {
  return (self) => zipWith_(self, that, f);
}
function zipWith_(self, that, f) {
  return chain_(self, (a) => map_(that, (b) => f(a, b)));
}
function zip(that) {
  return (self) => zip_(self, that);
}
function zip_(self, that) {
  return zipWith_(self, that, Tp.tuple);
}
function suspend(f) {
  return new ISuspend(f);
}
function succeedWith(f) {
  return suspend(() => succeed(f()));
}
function tryCatch(f, onThrow) {
  return suspend(() => {
    try {
      return succeed(f());
    } catch (u) {
      return fail(onThrow(u));
    }
  });
}
function promise(promise2, onError) {
  return new IPromise(promise2, onError);
}
function unfailable(promise2) {
  return new IPromise(promise2, () => void 0);
}
function done(exit) {
  return new IDone(exit);
}
function tapError(f) {
  return (self) => catchAll((e) => chain((_) => fail(e))(f(e)))(self);
}
function sleep(ms) {
  return unfailable((onInterrupt) => new Promise((res) => {
    const timer = setTimeout(() => {
      res(void 0);
    }, ms);
    onInterrupt(() => {
      clearTimeout(timer);
    });
  }));
}
function delay(ms) {
  return (self) => chain(() => self)(sleep(ms));
}
function fromEither(e) {
  return e._tag === "Right" ? succeed(e.right) : fail(e.left);
}
function unionFn(_) {
  return _;
}
function union(_) {
  return _;
}
function tryCatchOption_(ma, onNone) {
  return fromEither(E.fromOption_(ma, onNone));
}
function tryCatchOption(onNone) {
  return (ma) => tryCatchOption_(ma, onNone);
}
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Async,
  InterruptionState,
  Tracer,
  access,
  accessM,
  bimap,
  bimap_,
  catchAll,
  catchAll_,
  chain,
  chain_,
  delay,
  done,
  either,
  environment,
  fail,
  failExit,
  fold,
  foldM,
  foldM_,
  fold_,
  fromEither,
  interruptExit,
  map,
  mapError,
  mapError_,
  map_,
  orElseEither,
  orElseEither_,
  promise,
  provide,
  provideAll,
  provideAll_,
  provideSome,
  runAsync,
  runAsyncEnv,
  runPromise,
  runPromiseExit,
  runPromiseExitEnv,
  sleep,
  succeed,
  succeedWith,
  successExit,
  suspend,
  tap,
  tapError,
  tap_,
  tracingContext,
  tryCatch,
  tryCatchOption,
  unfailable,
  union,
  unionFn,
  unit,
  zip,
  zipWith,
  zipWith_,
  zip_
});
