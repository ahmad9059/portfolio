var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Set_exports = {};
__export(Set_exports, {
  chain: () => chain,
  chain_: () => chain_,
  compact: () => compact,
  difference: () => difference,
  difference_: () => difference_,
  elem: () => elem,
  elem_: () => elem_,
  empty: () => empty,
  every: () => every,
  every_: () => every_,
  filter: () => filter,
  filterMap: () => filterMap,
  filterMap_: () => filterMap_,
  filter_: () => filter_,
  foldMap: () => foldMap,
  foldMap_: () => foldMap_,
  fromArray: () => fromArray,
  fromMutable: () => fromMutable,
  getEqual: () => getEqual,
  getIntersectionAssociative: () => getIntersectionAssociative,
  getShow: () => getShow,
  getUnionIdentity: () => getUnionIdentity,
  insert: () => insert,
  insert_: () => insert_,
  intersection: () => intersection,
  intersection_: () => intersection_,
  isSubset: () => isSubset,
  isSubset_: () => isSubset_,
  map: () => map,
  map_: () => map_,
  partition: () => partition,
  partitionMap: () => partitionMap,
  partitionMap_: () => partitionMap_,
  partition_: () => partition_,
  reduce: () => reduce,
  reduce_: () => reduce_,
  remove: () => remove,
  remove_: () => remove_,
  separate: () => separate,
  singleton: () => singleton,
  some: () => some,
  some_: () => some_,
  toArray: () => toArray,
  toArray_: () => toArray_,
  toMutable: () => toMutable,
  toggle: () => toggle,
  toggle_: () => toggle_,
  union: () => union,
  union_: () => union_
});
var import_Operator = require("../../../Operator/index.js");
var import_Associative = require("../../../Associative/index.js");
var import_Equal = require("../../../Equal/index.js");
var import_Function = require("../../../Function/index.js");
var import_Identity = require("../../../Identity/index.js");
var Tp = __toESM(require("../Tuple/index.js"));
const empty = /* @__PURE__ */ new Set();
function getIntersectionAssociative(E) {
  return (0, import_Associative.makeAssociative)(intersection_(E));
}
function getUnionIdentity(E) {
  return (0, import_Identity.makeIdentity)(empty, union_(E));
}
function intersection_(E) {
  const elemE = elem_(E);
  return (x, y) => {
    if (x === empty || y === empty) {
      return empty;
    }
    const r = /* @__PURE__ */ new Set();
    x.forEach((e) => {
      if (elemE(y, e)) {
        r.add(e);
      }
    });
    return r;
  };
}
function intersection(E) {
  const i = intersection_(E);
  return (x) => (y) => i(x, y);
}
function fromMutable(s) {
  return new Set(s);
}
function toMutable(s) {
  return new Set(s);
}
function getShow(S) {
  return {
    show: (s) => {
      let elements = "";
      s.forEach((a) => {
        elements += S.show(a) + ", ";
      });
      if (elements !== "") {
        elements = elements.substring(0, elements.length - 2);
      }
      return `new Set([${elements}])`;
    }
  };
}
function toArray(O) {
  return (x) => {
    const r = [];
    x.forEach((e) => r.push(e));
    return r.sort(O.compare);
  };
}
function toArray_(x, O) {
  return toArray(O)(x);
}
function getEqual(E) {
  const subsetE = isSubset_(E);
  return (0, import_Equal.makeEqual)((x, y) => subsetE(x, y) && subsetE(y, x));
}
function some(predicate) {
  return (set) => {
    const values = set.values();
    let e;
    let found = false;
    while (!found && !(e = values.next()).done) {
      found = predicate(e.value);
    }
    return found;
  };
}
function some_(set, predicate) {
  return some(predicate)(set);
}
function map(E) {
  const m = map_(E);
  return (f) => (set) => m(set, f);
}
function map_(E) {
  const elemE = elem_(E);
  return (set, f) => {
    const r = /* @__PURE__ */ new Set();
    set.forEach((e) => {
      const v = f(e);
      if (!elemE(r, v)) {
        r.add(v);
      }
    });
    return r;
  };
}
function every(predicate) {
  return (set) => every_(set, predicate);
}
function every_(set, predicate) {
  return (0, import_Function.not)(some((0, import_Function.not)(predicate)))(set);
}
function chain(E) {
  const c = chain_(E);
  return (f) => (set) => c(set, f);
}
function chain_(E) {
  const elemE = elem_(E);
  return (set, f) => {
    const r = /* @__PURE__ */ new Set();
    set.forEach((e) => {
      f(e).forEach((e2) => {
        if (!elemE(r, e2)) {
          r.add(e2);
        }
      });
    });
    return r;
  };
}
function isSubset(E) {
  const i = isSubset_(E);
  return (y) => (x) => i(y, x);
}
function isSubset_(E) {
  const elemE = elem_(E);
  return (x, y) => every((a) => elemE(y, a))(x);
}
function filter(predicate) {
  return (set) => filter_(set, predicate);
}
function filter_(set, predicate) {
  const values = set.values();
  let e;
  const r = /* @__PURE__ */ new Set();
  while (!(e = values.next()).done) {
    const value = e.value;
    if (predicate(value)) {
      r.add(value);
    }
  }
  return r;
}
function partition(predicate) {
  return (set) => partition_(set, predicate);
}
function partition_(set, predicate) {
  const values = set.values();
  let e;
  const right = /* @__PURE__ */ new Set();
  const left = /* @__PURE__ */ new Set();
  while (!(e = values.next()).done) {
    const value = e.value;
    if (predicate(value)) {
      right.add(value);
    } else {
      left.add(value);
    }
  }
  return Tp.tuple(left, right);
}
function elem_(E) {
  return (set, a) => {
    const values = set.values();
    let e;
    let found = false;
    while (!found && !(e = values.next()).done) {
      found = E.equals(a, e.value);
    }
    return found;
  };
}
function elem(E) {
  const e = elem_(E);
  return (a) => (set) => e(set, a);
}
function partitionMap(EB, EC) {
  const pm = partitionMap_(EB, EC);
  return (f) => (set) => pm(set, f);
}
function partitionMap_(EB, EC) {
  return (set, f) => {
    const values = set.values();
    let e;
    const left = /* @__PURE__ */ new Set();
    const right = /* @__PURE__ */ new Set();
    const hasB = elem_(EB);
    const hasC = elem_(EC);
    while (!(e = values.next()).done) {
      const v = f(e.value);
      switch (v._tag) {
        case "Left":
          if (!hasB(left, v.left)) {
            left.add(v.left);
          }
          break;
        case "Right":
          if (!hasC(right, v.right)) {
            right.add(v.right);
          }
          break;
      }
    }
    return Tp.tuple(left, right);
  };
}
function difference_(E) {
  const elemE = elem_(E);
  return (x, y) => filter((a) => !elemE(y, a))(x);
}
function difference(E) {
  const diff = difference_(E);
  return (y) => (x) => diff(x, y);
}
function reduce(O) {
  const red = reduce_(O);
  return (b, f) => (fa) => red(fa, b, f);
}
function reduce_(O) {
  const toArrayO = toArray(O);
  return (fa, b, f) => toArrayO(fa).reduce(f, b);
}
function foldMap(O, M) {
  const fm = foldMap_(O, M);
  return (f) => (fa) => fm(fa, f);
}
function foldMap_(O, M) {
  const toArrayO = toArray(O);
  return (fa, f) => toArrayO(fa).reduce((b, a) => M.combine(b, f(a)), M.identity);
}
function singleton(a) {
  return /* @__PURE__ */ new Set([a]);
}
function insert(E) {
  const i = insert_(E);
  return (a) => (set) => i(set, a);
}
function insert_(E) {
  const elemE = elem_(E);
  return (set, a) => {
    if (!elemE(set, a)) {
      const r = new Set(set);
      r.add(a);
      return r;
    } else {
      return set;
    }
  };
}
function remove(E) {
  const rem = remove_(E);
  return (a) => (set) => rem(set, a);
}
function remove_(E) {
  return (set, a) => filter((ax) => !E.equals(a, ax))(set);
}
function toggle(E) {
  const t = toggle_(E);
  return (a) => (set) => t(set, a);
}
function toggle_(E) {
  const elemE = elem_(E);
  const removeE = remove(E);
  const insertE = insert(E);
  return (set, a) => (elemE(set, a) ? removeE : insertE)(a)(set);
}
function fromArray(E) {
  return (as) => {
    const len = as.length;
    const r = /* @__PURE__ */ new Set();
    const has = elem_(E);
    for (let i = 0; i < len; i++) {
      const a = as[i];
      if (!has(r, a)) {
        r.add(a);
      }
    }
    return r;
  };
}
function compact(E) {
  return filterMap(E)(import_Function.identity);
}
function separate(EE, EA) {
  return (fa) => {
    const elemEE = elem_(EE);
    const elemEA = elem_(EA);
    const left = /* @__PURE__ */ new Set();
    const right = /* @__PURE__ */ new Set();
    fa.forEach((e) => {
      switch (e._tag) {
        case "Left":
          if (!elemEE(left, e.left)) {
            left.add(e.left);
          }
          break;
        case "Right":
          if (!elemEA(right, e.right)) {
            right.add(e.right);
          }
          break;
      }
    });
    return Tp.tuple(left, right);
  };
}
function filterMap(E) {
  const fm = filterMap_(E);
  return (f) => (fa) => fm(fa, f);
}
function filterMap_(E) {
  const elemE = elem_(E);
  return (fa, f) => {
    const r = /* @__PURE__ */ new Set();
    fa.forEach((a) => {
      const ob = f(a);
      if (ob._tag === "Some" && !elemE(r, ob.value)) {
        r.add(ob.value);
      }
    });
    return r;
  };
}
function union_(E) {
  const elemE = elem_(E);
  return (x, y) => {
    if (x === empty) {
      return y;
    }
    if (y === empty) {
      return x;
    }
    const r = new Set(x);
    y.forEach((e) => {
      if (!elemE(r, e)) {
        r.add(e);
      }
    });
    return r;
  };
}
function union(E) {
  const u = union_(E);
  return (y) => (x) => u(x, y);
}
module.exports = __toCommonJS(Set_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  chain,
  chain_,
  compact,
  difference,
  difference_,
  elem,
  elem_,
  empty,
  every,
  every_,
  filter,
  filterMap,
  filterMap_,
  filter_,
  foldMap,
  foldMap_,
  fromArray,
  fromMutable,
  getEqual,
  getIntersectionAssociative,
  getShow,
  getUnionIdentity,
  insert,
  insert_,
  intersection,
  intersection_,
  isSubset,
  isSubset_,
  map,
  map_,
  partition,
  partitionMap,
  partitionMap_,
  partition_,
  reduce,
  reduce_,
  remove,
  remove_,
  separate,
  singleton,
  some,
  some_,
  toArray,
  toArray_,
  toMutable,
  toggle,
  toggle_,
  union,
  union_
});
