var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var operations_exports = {};
__export(operations_exports, {
  compactF: () => compactF,
  difference: () => difference,
  difference_: () => difference_,
  elem: () => elem,
  elem_: () => elem_,
  foldMap: () => foldMap,
  foldMap_: () => foldMap_,
  forEachF: () => forEachF,
  getEqual: () => getEqual,
  getIdentity: () => getIdentity,
  getShow: () => getShow,
  intersection: () => intersection,
  intersection_: () => intersection_,
  separateF: () => separateF,
  sortBy: () => sortBy,
  sortBy_: () => sortBy_,
  union: () => union,
  union_: () => union_,
  uniq: () => uniq
});
var List = __toESM(require("@effect-ts/system/Collections/Immutable/List"));
var import_Equal = require("../../../Equal/index.js");
var import_Function = require("../../../Function/index.js");
var import_Identity = require("../../../Identity/index.js");
var P = __toESM(require("../../../Prelude/index.js"));
var A = __toESM(require("../Array/index.js"));
__reExport(operations_exports, require("@effect-ts/system/Collections/Immutable/List"));
const forEachF = /* @__PURE__ */ P.implementForEachF()(() => (G) => (f) => (fa) => List.reduceRight_(fa, P.succeedF(G)(List.empty()), (a, acc) => G.map(({
  tuple: [b, l]
}) => List.prepend_(l, b))(G.both(acc)(f(a)))));
function sortBy(O) {
  const so = sortBy_(O);
  return (f) => (l) => so(l, f);
}
function sortBy_(O) {
  return (l, f) => {
    if (l.length === 0) {
      return l;
    }
    const arr = [];
    let i = 0;
    List.forEach_(l, (elm) => arr.push({
      idx: i++,
      elm,
      prop: f(elm)
    }));
    arr.sort(({
      idx: i2,
      prop: a
    }, {
      idx: j,
      prop: b
    }) => {
      const c = O.compare(a, b);
      return c !== 0 ? c : i2 < j ? -1 : 1;
    });
    const newL = List.emptyPushable();
    for (let i2 = 0; i2 < arr.length; ++i2) {
      List.push_(newL, arr[i2].elm);
    }
    return newL;
  };
}
const separateF = /* @__PURE__ */ P.implementSeparateF()((_) => (G) => (f) => (x) => G.map(List.separate)(forEachF(G)(f)(x)));
const compactF = /* @__PURE__ */ P.implementCompactF()((_) => (G) => (f) => (x) => G.map(List.compact)(forEachF(G)(f)(x)));
function elem(E) {
  const elemE = elem_(E);
  return (a) => (as) => elemE(as, a);
}
function elem_(E) {
  return (as, a) => List.find_(as, (y) => E.equals(y, a))._tag === "Some";
}
function difference_(E) {
  const elemE = elem_(E);
  return (xs, ys) => List.filter_(xs, (a) => !elemE(ys, a));
}
function difference(E) {
  const diff = difference_(E);
  return (ys) => (xs) => diff(xs, ys);
}
function getEqual(E) {
  const eq = A.getEqual(E);
  return (0, import_Equal.makeEqual)((xs, ys) => xs === ys || xs.length === ys.length && eq.equals(List.toArray(xs), List.toArray(ys)));
}
function getIdentity() {
  return (0, import_Identity.makeIdentity)(List.empty(), List.concat_);
}
function getShow(S) {
  return {
    show: (as) => `[${List.join_(List.map_(as, S.show), ", ")}]`
  };
}
function intersection_(E) {
  const elemE = elem_(E);
  return (xs, ys) => List.filter_(xs, (a) => elemE(ys, a));
}
function intersection(E) {
  const int = intersection_(E);
  return (ys) => (xs) => int(xs, ys);
}
function foldMap_(M) {
  return (fa, f) => List.reduce_(fa, M.identity, (b, a) => M.combine(b, f(a)));
}
function foldMap(M) {
  const fmap = foldMap_(M);
  return (f) => (fa) => fmap(fa, f);
}
function union_(E) {
  const elemE = elem_(E);
  return (xs, ys) => List.concat_(xs, List.filter_(ys, (a) => !elemE(xs, a)));
}
function union(E) {
  const un = union_(E);
  return (ys) => (xs) => un(xs, ys);
}
function uniq(E) {
  const elemS = elem_(E);
  return (as) => List.reduce_(as, List.emptyPushable(), (acc, a) => {
    if (!elemS(acc, a)) {
      List.push_(acc, a);
    }
    return acc;
  });
}
module.exports = __toCommonJS(operations_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  compactF,
  difference,
  difference_,
  elem,
  elem_,
  foldMap,
  foldMap_,
  forEachF,
  getEqual,
  getIdentity,
  getShow,
  intersection,
  intersection_,
  separateF,
  sortBy,
  sortBy_,
  union,
  union_,
  uniq
});
