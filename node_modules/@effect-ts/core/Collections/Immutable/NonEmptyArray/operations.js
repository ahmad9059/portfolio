var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var operations_exports = {};
__export(operations_exports, {
  difference: () => difference,
  difference_: () => difference_,
  elem: () => elem,
  elem_: () => elem_,
  foldMap: () => foldMap,
  foldMapWithIndex: () => foldMapWithIndex,
  foldMapWithIndex_: () => foldMapWithIndex_,
  foldMap_: () => foldMap_,
  forEachF: () => forEachF,
  forEachWithIndexF: () => forEachWithIndexF,
  getAssociative: () => getAssociative,
  getEqual: () => getEqual,
  getOrd: () => getOrd,
  getShow: () => getShow,
  intersection: () => intersection,
  intersection_: () => intersection_,
  sort: () => sort,
  sortBy: () => sortBy,
  union: () => union,
  uniq: () => uniq
});
var A = __toESM(require("@effect-ts/system/Collections/Immutable/Array"));
var L = __toESM(require("@effect-ts/system/Collections/Immutable/List"));
var NA = __toESM(require("@effect-ts/system/Collections/Immutable/NonEmptyArray"));
var import_Function = require("@effect-ts/system/Function");
var import_Associative = require("../../../Associative/index.js");
var import_Equal = require("../../../Equal/index.js");
var Ord = __toESM(require("../../../Ord/index.js"));
var DSL = __toESM(require("../../../Prelude/DSL/index.js"));
var P = __toESM(require("../../../Prelude/index.js"));
__reExport(operations_exports, require("@effect-ts/system/Collections/Immutable/NonEmptyArray"));
const forEachWithIndexF = /* @__PURE__ */ P.implementForEachWithIndexF()((_) => (G) => (f) => (x) => G.map(L.toArray)(A.reduceWithIndex_(x, DSL.succeedF(G)(L.empty()), (k, b, a) => G.map(({
  tuple: [x2, y]
}) => L.append_(x2, y))(G.both(f(k, a))(b)))));
const forEachF = /* @__PURE__ */ P.implementForEachF()((_) => (G) => (f) => forEachWithIndexF(G)((_2, a) => f(a)));
function elem(E) {
  const elemE = elem_(E);
  return (a) => (as) => elemE(as, a);
}
function elem_(E) {
  return (as, a) => {
    const predicate = (element) => E.equals(element, a);
    let i = 0;
    const len = as.length;
    for (; i < len; i++) {
      if (predicate(as[i])) {
        return true;
      }
    }
    return false;
  };
}
function difference_(E) {
  const elemE = elem_(E);
  return (xs, ys) => xs.filter((a) => !elemE(ys, a));
}
function difference(E) {
  const elemE = elem_(E);
  return (ys) => (xs) => xs.filter((a) => !elemE(ys, a));
}
function getEqual(E) {
  return (0, import_Equal.makeEqual)((xs, ys) => xs === ys || xs.length === ys.length && xs.every((x, i) => E.equals(x, ys[i])));
}
function getOrd(O) {
  return Ord.makeOrd((a, b) => {
    const aLen = a.length;
    const bLen = b.length;
    const len = Math.min(aLen, bLen);
    for (let i = 0; i < len; i++) {
      const ordering = O.compare(a[i], b[i]);
      if (ordering !== 0) {
        return ordering;
      }
    }
    return Ord.number.compare(aLen, bLen);
  });
}
function getShow(S) {
  return {
    show: (as) => `[${as.map(S.show).join(", ")}]`
  };
}
function intersection_(E) {
  const elemE = elem_(E);
  return (xs, ys) => xs.filter((a) => elemE(ys, a));
}
function intersection(E) {
  const int = intersection_(E);
  return (ys) => (xs) => int(xs, ys);
}
function foldMap(M) {
  return (f) => foldMapWithIndex(M)((_, a) => f(a));
}
function foldMap_(M) {
  return (fa, f) => foldMapWithIndex_(M)(fa, (_, a) => f(a));
}
function foldMapWithIndex(M) {
  return (f) => (fa) => foldMapWithIndex_(M)(fa, f);
}
function foldMapWithIndex_(M) {
  return ([fa0, ...fa], f) => fa.reduce((b, a, i) => M.combine(b, f(i + 1, a)), f(0, fa0));
}
function sort(O) {
  return (as) => [...as].sort(O.compare);
}
function sortBy(ords) {
  const M = Ord.getIdentity();
  return sort(ords.reduce(M.combine, M.identity));
}
function union(E) {
  const elemE = elem_(E);
  return (xs, ys) => NA.concat_(xs, ys.filter((a) => !elemE(xs, a)));
}
function uniq(E) {
  const elemS = elem_(E);
  return (as) => {
    const r = [];
    const len = as.length;
    let i = 0;
    for (; i < len; i++) {
      const a = as[i];
      if (!elemS(r, a)) {
        r.push(a);
      }
    }
    return len === r.length ? as : r;
  };
}
function getAssociative() {
  return (0, import_Associative.makeAssociative)(NA.concat_);
}
module.exports = __toCommonJS(operations_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  difference,
  difference_,
  elem,
  elem_,
  foldMap,
  foldMapWithIndex,
  foldMapWithIndex_,
  foldMap_,
  forEachF,
  forEachWithIndexF,
  getAssociative,
  getEqual,
  getOrd,
  getShow,
  intersection,
  intersection_,
  sort,
  sortBy,
  union,
  uniq
});
