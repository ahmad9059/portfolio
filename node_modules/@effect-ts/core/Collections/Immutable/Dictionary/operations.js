var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var operations_exports = {};
__export(operations_exports, {
  compactF: () => compactF,
  compactWithIndexF: () => compactWithIndexF,
  foldMap: () => foldMap,
  foldMapWithIndex: () => foldMapWithIndex,
  forEachF: () => forEachF,
  forEachWithIndexF: () => forEachWithIndexF,
  fromFoldable: () => fromFoldable,
  fromFoldableMap: () => fromFoldableMap,
  fromFoldableMap_: () => fromFoldableMap_,
  getEqual: () => getEqual,
  getIdentity: () => getIdentity,
  getShow: () => getShow,
  isSubrecord: () => isSubrecord,
  isSubrecord_: () => isSubrecord_,
  separateF: () => separateF,
  separateWithIndexF: () => separateWithIndexF
});
var R = __toESM(require("@effect-ts/system/Collections/Immutable/Dictionary"));
var Tp = __toESM(require("@effect-ts/system/Collections/Immutable/Tuple"));
var O = __toESM(require("@effect-ts/system/Option"));
var E = __toESM(require("../../../Either/index.js"));
var import_Equal = require("../../../Equal/index.js");
var import_Function = require("../../../Function/index.js");
var import_Identity = require("../../../Identity/index.js");
var P = __toESM(require("../../../Prelude/index.js"));
var import_Prelude = require("../../../Prelude/index.js");
var A = __toESM(require("../Array/index.js"));
__reExport(operations_exports, require("@effect-ts/system/Collections/Immutable/Dictionary"));
const forEachWithIndexF = /* @__PURE__ */ P.implementForEachWithIndexF()((_) => (G) => {
  const succeed = (0, import_Prelude.succeedF)(G);
  return (f) => (fa) => {
    let base = succeed({});
    for (const k of Object.keys(fa)) {
      base = G.map(({
        tuple: [x, b]
      }) => Object.assign(x, {
        [k]: b
      }))(G.both(f(k, fa[k]))(base));
    }
    return base;
  };
});
const forEachF = /* @__PURE__ */ P.implementForEachF()((_) => (G) => (f) => forEachWithIndexF(G)((_2, a) => f(a)));
const foldMapWithIndex = (I) => (f) => R.reduceWithIndex(I.identity, (k, b, a) => I.combine(b, f(k, a)));
const foldMap = (I) => (f) => foldMapWithIndex(I)((_, a) => f(a));
const separateWithIndexF = /* @__PURE__ */ P.implementSeparateWithIndexF()(() => (G) => (f) => (x) => G.map(({
  tuple: [left, right]
}) => Tp.tuple(R.fromArray(left), R.fromArray(right)))(A.separateF(G)(([k, a]) => G.map(E.bimap((b) => Tp.tuple(k, b), (a2) => Tp.tuple(k, a2)))(f(k, a)))(R.collect(import_Function.tuple)(x))));
const separateF = /* @__PURE__ */ P.implementSeparateF()(() => (G) => (f) => separateWithIndexF(G)((_, a) => f(a)));
const compactWithIndexF = /* @__PURE__ */ P.implementCompactWithIndexF()(() => (G) => (f) => (x) => G.map(R.fromArray)(A.compactF(G)(([k, a]) => G.map(O.map((b) => Tp.tuple(k, b)))(f(k, a)))(R.collect(import_Function.tuple)(x))));
const compactF = /* @__PURE__ */ P.implementCompactF()(() => (G) => (f) => compactWithIndexF(G)((_, a) => f(a)));
function fromFoldableMap_(M, F) {
  return (fa, f) => {
    return F.reduce({}, (r, a) => {
      const [k, b] = f(a).tuple;
      r[k] = Object.prototype.hasOwnProperty.call(r, k) ? M.combine(r[k], b) : b;
      return r;
    })(fa);
  };
}
function fromFoldableMap(M, F) {
  const ff = fromFoldableMap_(M, F);
  return (f) => (fa) => ff(fa, f);
}
function fromFoldable(M, F) {
  const fromFoldableMapM = fromFoldableMap(M, F);
  return fromFoldableMapM(import_Function.identity);
}
function getShow(S) {
  return {
    show: (r) => {
      const elements = R.collect((k, a) => `${JSON.stringify(k)}: ${S.show(a)}`)(r).join(", ");
      return elements === "" ? "{}" : `{ ${elements} }`;
    }
  };
}
function isSubrecord_(E2) {
  return (x, y) => {
    for (const k in x) {
      if (!Object.prototype.hasOwnProperty.call(y, k) || !E2.equals(x[k], y[k])) {
        return false;
      }
    }
    return true;
  };
}
function isSubrecord(E2) {
  const is = isSubrecord_(E2);
  return (y) => (x) => is(x, y);
}
function getEqual(E2) {
  const isSubrecordE = isSubrecord_(E2);
  return (0, import_Equal.makeEqual)((x, y) => isSubrecordE(x, y) && isSubrecordE(y, x));
}
function getIdentity(S) {
  return (0, import_Identity.makeIdentity)(R.empty, (x, y) => {
    if (x === R.empty) {
      return y;
    }
    if (y === R.empty) {
      return x;
    }
    const keys = Object.keys(y);
    const len = keys.length;
    if (len === 0) {
      return x;
    }
    const r = __spreadValues({}, x);
    for (let i = 0; i < len; i++) {
      const k = keys[i];
      r[k] = Object.prototype.hasOwnProperty.call(x, k) ? S.combine(x[k], y[k]) : y[k];
    }
    return r;
  });
}
module.exports = __toCommonJS(operations_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  compactF,
  compactWithIndexF,
  foldMap,
  foldMapWithIndex,
  forEachF,
  forEachWithIndexF,
  fromFoldable,
  fromFoldableMap,
  fromFoldableMap_,
  getEqual,
  getIdentity,
  getShow,
  isSubrecord,
  isSubrecord_,
  separateF,
  separateWithIndexF
});
