var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var operations_exports = {};
__export(operations_exports, {
  compactF: () => compactF,
  compactWithIndexF: () => compactWithIndexF,
  difference: () => difference,
  difference_: () => difference_,
  elem: () => elem,
  elem_: () => elem_,
  foldMap: () => foldMap,
  foldMapWithIndex: () => foldMapWithIndex,
  foldMapWithIndex_: () => foldMapWithIndex_,
  foldMap_: () => foldMap_,
  forEachF: () => forEachF,
  forEachWithIndexF: () => forEachWithIndexF,
  getEqual: () => getEqual,
  getIdentity: () => getIdentity,
  getOrd: () => getOrd,
  getShow: () => getShow,
  intersection: () => intersection,
  intersection_: () => intersection_,
  partition: () => partition,
  partitionMap: () => partitionMap,
  partitionMapWithIndex: () => partitionMapWithIndex,
  partitionMapWithIndex_: () => partitionMapWithIndex_,
  partitionMap_: () => partitionMap_,
  partitionWithIndex: () => partitionWithIndex,
  partitionWithIndex_: () => partitionWithIndex_,
  partition_: () => partition_,
  separateF: () => separateF,
  separateWithIndexF: () => separateWithIndexF,
  sort: () => sort,
  sortBy: () => sortBy,
  union: () => union,
  union_: () => union_,
  uniq: () => uniq
});
var A = __toESM(require("@effect-ts/system/Collections/Immutable/Array"));
var import_Function = require("@effect-ts/system/Function");
var import_Equal = require("../../../Equal/index.js");
var import_Identity = require("../../../Identity/index.js");
var Ord = __toESM(require("../../../Ord/index.js"));
var P = __toESM(require("../../../Prelude/index.js"));
var C = __toESM(require("../Chunk/operations.js"));
var Tp = __toESM(require("../Tuple/index.js"));
__reExport(operations_exports, require("@effect-ts/system/Collections/Immutable/Array"));
const forEachWithIndexF = /* @__PURE__ */ P.implementForEachWithIndexF()((_) => (G) => (f) => (fa) => G.map(C.toArray)(C.forEachWithIndexF(G)(f)(C.from(fa))));
const forEachF = /* @__PURE__ */ P.implementForEachF()((_) => (G) => (f) => forEachWithIndexF(G)((_2, a) => f(a)));
const separateF = /* @__PURE__ */ P.implementSeparateF()((_) => (G) => (f) => (x) => G.map(A.separate)(forEachF(G)(f)(x)));
const separateWithIndexF = /* @__PURE__ */ P.implementSeparateWithIndexF()((_) => (G) => (f) => (x) => G.map(A.separate)(forEachWithIndexF(G)(f)(x)));
const compactF = /* @__PURE__ */ P.implementCompactF()((_) => (G) => (f) => (x) => G.map(A.compact)(forEachF(G)(f)(x)));
const compactWithIndexF = /* @__PURE__ */ P.implementCompactWithIndexF()((_) => (G) => (f) => (x) => G.map(A.compact)(forEachWithIndexF(G)(f)(x)));
function elem(E) {
  const elemE = elem_(E);
  return (a) => (as) => elemE(as, a);
}
function elem_(E) {
  return (as, a) => {
    const predicate = (element) => E.equals(element, a);
    let i = 0;
    const len = as.length;
    for (; i < len; i++) {
      if (predicate(as[i])) {
        return true;
      }
    }
    return false;
  };
}
function difference_(E) {
  const elemE = elem_(E);
  return (xs, ys) => xs.filter((a) => !elemE(ys, a));
}
function difference(E) {
  const elemE = elem_(E);
  return (ys) => (xs) => xs.filter((a) => !elemE(ys, a));
}
function getEqual(E) {
  return (0, import_Equal.makeEqual)((xs, ys) => xs === ys || xs.length === ys.length && xs.every((x, i) => E.equals(x, ys[i])));
}
function getIdentity() {
  return (0, import_Identity.makeIdentity)(A.empty(), A.concat_);
}
function getOrd(O) {
  return Ord.makeOrd((a, b) => {
    const aLen = a.length;
    const bLen = b.length;
    const len = Math.min(aLen, bLen);
    for (let i = 0; i < len; i++) {
      const ordering = O.compare(a[i], b[i]);
      if (ordering !== 0) {
        return ordering;
      }
    }
    return Ord.number.compare(aLen, bLen);
  });
}
function getShow(S) {
  return {
    show: (as) => `[${as.map(S.show).join(", ")}]`
  };
}
function intersection_(E) {
  const elemE = elem_(E);
  return (xs, ys) => xs.filter((a) => elemE(ys, a));
}
function intersection(E) {
  const int = intersection_(E);
  return (ys) => (xs) => int(xs, ys);
}
function foldMap(M) {
  return (f) => foldMapWithIndex(M)((_, a) => f(a));
}
function foldMap_(M) {
  return (fa, f) => foldMapWithIndex_(M)(fa, (_, a) => f(a));
}
function foldMapWithIndex(M) {
  return (f) => (fa) => foldMapWithIndex_(M)(fa, f);
}
function foldMapWithIndex_(M) {
  return (fa, f) => fa.reduce((b, a, i) => M.combine(b, f(i, a)), M.identity);
}
function sort(O) {
  return (as) => [...as].sort((x, y) => O.compare(x, y));
}
function sortBy(ords) {
  const M = Ord.getIdentity();
  return sort(ords.reduce((x, y) => M.combine(x, y), M.identity));
}
function union_(E) {
  const elemE = elem_(E);
  return (xs, ys) => A.concat_(xs, ys.filter((a) => !elemE(xs, a)));
}
function union(E) {
  const un = union_(E);
  return (ys) => (xs) => un(xs, ys);
}
function uniq(E) {
  const elemS = elem_(E);
  return (as) => {
    const r = [];
    const len = as.length;
    let i = 0;
    for (; i < len; i++) {
      const a = as[i];
      if (!elemS(r, a)) {
        r.push(a);
      }
    }
    return len === r.length ? as : r;
  };
}
function partition(predicate) {
  return (fa) => partitionWithIndex((_, a) => predicate(a))(fa);
}
function partition_(fa, predicate) {
  return partitionWithIndex((_, a) => predicate(a))(fa);
}
function partitionMap(f) {
  return partitionMapWithIndex((_, a) => f(a));
}
function partitionMap_(fa, f) {
  return partitionMapWithIndex_(fa, (_, a) => f(a));
}
function partitionMapWithIndex_(fa, f) {
  const left = [];
  const right = [];
  for (let i = 0; i < fa.length; i++) {
    const e = f(i, fa[i]);
    if (e._tag === "Left") {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return Tp.tuple(left, right);
}
function partitionMapWithIndex(f) {
  return (fa) => partitionMapWithIndex_(fa, f);
}
function partitionWithIndex(predicateWithIndex) {
  return (fa) => partitionWithIndex_(fa, predicateWithIndex);
}
function partitionWithIndex_(fa, predicateWithIndex) {
  const left = [];
  const right = [];
  for (let i = 0; i < fa.length; i++) {
    const a = fa[i];
    if (predicateWithIndex(i, a)) {
      right.push(a);
    } else {
      left.push(a);
    }
  }
  return Tp.tuple(left, right);
}
module.exports = __toCommonJS(operations_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  compactF,
  compactWithIndexF,
  difference,
  difference_,
  elem,
  elem_,
  foldMap,
  foldMapWithIndex,
  foldMapWithIndex_,
  foldMap_,
  forEachF,
  forEachWithIndexF,
  getEqual,
  getIdentity,
  getOrd,
  getShow,
  intersection,
  intersection_,
  partition,
  partitionMap,
  partitionMapWithIndex,
  partitionMapWithIndex_,
  partitionMap_,
  partitionWithIndex,
  partitionWithIndex_,
  partition_,
  separateF,
  separateWithIndexF,
  sort,
  sortBy,
  union,
  union_,
  uniq
});
