var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var operations_exports = {};
__export(operations_exports, {
  compactF: () => compactF,
  compactWithIndexF: () => compactWithIndexF,
  difference: () => difference,
  difference_: () => difference_,
  elem: () => elem,
  elem_: () => elem_,
  foldMap: () => foldMap,
  foldMapWithIndex: () => foldMapWithIndex,
  foldMapWithIndex_: () => foldMapWithIndex_,
  foldMap_: () => foldMap_,
  forEachF: () => forEachF,
  forEachF_: () => forEachF_,
  forEachWithIndexF: () => forEachWithIndexF,
  getEqual: () => getEqual,
  getIdentity: () => getIdentity,
  getOrd: () => getOrd,
  getShow: () => getShow,
  intersection: () => intersection,
  intersection_: () => intersection_,
  partition: () => partition,
  partitionMapWithIndex: () => partitionMapWithIndex,
  partitionMapWithIndex_: () => partitionMapWithIndex_,
  partitionWithIndex: () => partitionWithIndex,
  partitionWithIndex_: () => partitionWithIndex_,
  partition_: () => partition_,
  separateF: () => separateF,
  separateWithIndexF: () => separateWithIndexF,
  sort: () => sort,
  sortBy: () => sortBy,
  sortBy_: () => sortBy_,
  sort_: () => sort_,
  union: () => union,
  union_: () => union_,
  uniq: () => uniq,
  uniq_: () => uniq_
});
var Chunk = __toESM(require("@effect-ts/system/Collections/Immutable/Chunk"));
var Tp = __toESM(require("@effect-ts/system/Collections/Immutable/Tuple"));
var import_Function = require("@effect-ts/system/Function");
var import_Equal = require("../../../Equal/index.js");
var import_Identity = require("../../../Identity/index.js");
var Ord = __toESM(require("../../../Ord/index.js"));
var DSL = __toESM(require("../../../Prelude/DSL/index.js"));
var P = __toESM(require("../../../Prelude/index.js"));
__reExport(operations_exports, require("@effect-ts/system/Collections/Immutable/Chunk"));
const forEachWithIndexF = /* @__PURE__ */ P.implementForEachWithIndexF()((_) => (G) => {
  const succeed = DSL.succeedF(G);
  return (f) => (fa) => {
    let base = succeed(Chunk.empty());
    for (let k = 0; k < fa.length; k += 1) {
      base = G.map(({
        tuple: [bs, b]
      }) => Chunk.append_(bs, b))(G.both(f(k, Chunk.unsafeGet_(fa, k)))(base));
    }
    return base;
  };
});
const forEachF = /* @__PURE__ */ P.implementForEachF()((_) => (G) => (f) => forEachWithIndexF(G)((_2, a) => f(a)));
const forEachF_ = (fa, G) => (f) => forEachF(G)(f)(fa);
const separateF = /* @__PURE__ */ P.implementSeparateF()((_) => (G) => (f) => (x) => G.map(Chunk.partitionMap(import_Function.identity))(forEachF(G)(f)(x)));
const separateWithIndexF = /* @__PURE__ */ P.implementSeparateWithIndexF()((_) => (G) => (f) => (x) => G.map(Chunk.partitionMap(import_Function.identity))(forEachWithIndexF(G)(f)(x)));
const compactF = /* @__PURE__ */ P.implementCompactF()((_) => (G) => (f) => (x) => G.map(Chunk.compact)(forEachF(G)(f)(x)));
const compactWithIndexF = /* @__PURE__ */ P.implementCompactWithIndexF()((_) => (G) => (f) => (x) => G.map(Chunk.compact)(forEachWithIndexF(G)(f)(x)));
function elem(E, a) {
  return (as) => elem_(as, E, a);
}
function elem_(as, E, a) {
  const predicate = (element) => E.equals(element, a);
  let i = 0;
  const len = as.length;
  for (; i < len; i++) {
    if (predicate(Chunk.unsafeGet_(as, i))) {
      return true;
    }
  }
  return false;
}
function difference_(xs, E, ys) {
  return Chunk.filter_(xs, (a) => !elem_(ys, E, a));
}
function difference(E, ys) {
  return (xs) => difference_(xs, E, ys);
}
function getEqual(E) {
  return (0, import_Equal.makeEqual)((xs, ys) => xs === ys || Chunk.corresponds_(xs, ys, E.equals));
}
function getIdentity() {
  return (0, import_Identity.makeIdentity)(Chunk.empty(), Chunk.concat_);
}
function getOrd(O) {
  return Ord.makeOrd((a, b) => {
    const aLen = a.length;
    const bLen = b.length;
    const len = Math.min(aLen, bLen);
    for (let i = 0; i < len; i++) {
      const ordering = O.compare(Chunk.unsafeGet_(a, i), Chunk.unsafeGet_(b, i));
      if (ordering !== 0) {
        return ordering;
      }
    }
    return Ord.number.compare(aLen, bLen);
  });
}
function getShow(S) {
  return {
    show: (as) => `[${Chunk.join_(Chunk.map_(as, S.show), ", ")}]`
  };
}
function intersection_(xs, E, ys) {
  return Chunk.filter_(xs, (a) => elem_(ys, E, a));
}
function intersection(E, ys) {
  return (xs) => intersection_(xs, E, ys);
}
function foldMap(M) {
  return (f) => foldMapWithIndex(M)((_, a) => f(a));
}
function foldMap_(fa, M, f) {
  return foldMapWithIndex_(fa, M, (_, a) => f(a));
}
function foldMapWithIndex(M) {
  return (f) => (fa) => foldMapWithIndex_(fa, M, f);
}
function foldMapWithIndex_(fa, M, f) {
  return Chunk.reduce_(Chunk.zipWithIndex(fa), M.identity, (b, {
    tuple: [a, i]
  }) => M.combine(b, f(i, a)));
}
function sort(O) {
  return (as) => sort_(as, O);
}
function sort_(as, O) {
  return Chunk.from([...Chunk.toArray(as)].sort((x, y) => O.compare(x, y)));
}
function sortBy(ords) {
  return (as) => sortBy_(as, ords);
}
function sortBy_(as, ords) {
  const M = Ord.getIdentity();
  return sort_(as, ords.reduce((x, y) => M.combine(x, y), M.identity));
}
function union_(xs, E, ys) {
  return Chunk.concat_(xs, Chunk.filter_(ys, (a) => !elem_(xs, E, a)));
}
function union(E, ys) {
  return (xs) => union_(xs, E, ys);
}
function uniq_(as, E) {
  let r = Chunk.empty();
  const len = as.length;
  let i = 0;
  for (; i < len; i++) {
    const a = as[i];
    if (!elem_(r, E, a)) {
      r = Chunk.append_(r, a);
    }
  }
  return len === r.length ? as : r;
}
function uniq(E) {
  return (as) => uniq_(as, E);
}
function partition(predicate) {
  return (fa) => partitionWithIndex((_, a) => predicate(a))(fa);
}
function partition_(fa, predicate) {
  return partitionWithIndex((_, a) => predicate(a))(fa);
}
function partitionMapWithIndex_(fa, f) {
  const left = [];
  const right = [];
  for (let i = 0; i < fa.length; i++) {
    const e = f(i, Chunk.unsafeGet_(fa, i));
    if (e._tag === "Left") {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return Tp.tuple(Chunk.from(left), Chunk.from(right));
}
function partitionMapWithIndex(f) {
  return (fa) => partitionMapWithIndex_(fa, f);
}
function partitionWithIndex(predicateWithIndex) {
  return (fa) => partitionWithIndex_(fa, predicateWithIndex);
}
function partitionWithIndex_(fa, predicateWithIndex) {
  const left = [];
  const right = [];
  for (let i = 0; i < fa.length; i++) {
    const a = Chunk.unsafeGet_(fa, i);
    if (predicateWithIndex(i, a)) {
      right.push(a);
    } else {
      left.push(a);
    }
  }
  return Tp.tuple(Chunk.from(left), Chunk.from(right));
}
module.exports = __toCommonJS(operations_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  compactF,
  compactWithIndexF,
  difference,
  difference_,
  elem,
  elem_,
  foldMap,
  foldMapWithIndex,
  foldMapWithIndex_,
  foldMap_,
  forEachF,
  forEachF_,
  forEachWithIndexF,
  getEqual,
  getIdentity,
  getOrd,
  getShow,
  intersection,
  intersection_,
  partition,
  partitionMapWithIndex,
  partitionMapWithIndex_,
  partitionWithIndex,
  partitionWithIndex_,
  partition_,
  separateF,
  separateWithIndexF,
  sort,
  sortBy,
  sortBy_,
  sort_,
  union,
  union_,
  uniq,
  uniq_
});
