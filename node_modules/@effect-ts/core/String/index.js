var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var String_exports = {};
__export(String_exports, {
  Equal: () => Equal,
  LinesIterator: () => LinesIterator,
  SumClosure: () => SumClosure,
  SumIdentity: () => SumIdentity,
  append: () => append,
  append_: () => append_,
  empty: () => empty,
  endsWith: () => endsWith,
  endsWith_: () => endsWith_,
  fromNumber: () => fromNumber,
  includes: () => includes,
  includes_: () => includes_,
  isEmpty: () => isEmpty,
  isString: () => isString,
  lines: () => lines,
  linesIterator: () => linesIterator,
  linesWithSeparators: () => linesWithSeparators,
  match: () => match,
  matchAll: () => matchAll,
  matchAll_: () => matchAll_,
  match_: () => match_,
  prepend: () => prepend,
  prepend_: () => prepend_,
  replace: () => replace,
  replace_: () => replace_,
  reverse: () => reverse,
  slice: () => slice,
  slice_: () => slice_,
  split: () => split,
  split_: () => split_,
  startsWith: () => startsWith,
  startsWith_: () => startsWith_,
  stripMargin: () => stripMargin,
  stripMarginWith: () => stripMarginWith,
  stripMarginWith_: () => stripMarginWith_,
  surround: () => surround,
  surround_: () => surround_,
  takeLeft: () => takeLeft,
  takeLeft_: () => takeLeft_,
  takeRight: () => takeRight,
  takeRight_: () => takeRight_,
  test: () => test,
  test_: () => test_,
  toLowerCase: () => toLowerCase,
  toUpperCase: () => toUpperCase,
  trim: () => trim,
  trimLeft: () => trimLeft,
  trimRight: () => trimRight,
  unappend: () => unappend,
  unappend_: () => unappend_,
  under: () => under,
  under_: () => under_,
  unlines: () => unlines,
  unprepend: () => unprepend,
  unprepend_: () => unprepend_,
  unsurround: () => unsurround,
  unsurround_: () => unsurround_
});
var import_Operator = require("../Operator/index.js");
var C = __toESM(require("../Closure/index.js"));
var A = __toESM(require("../Collections/Immutable/Array/index.js"));
var NA = __toESM(require("../Collections/Immutable/NonEmptyArray/index.js"));
var Eq = __toESM(require("../Equal/index.js"));
var import_Function = require("../Function/index.js");
var I = __toESM(require("../Identity/index.js"));
var import_Newtype = require("../Newtype/index.js");
var O = __toESM(require("../Option/index.js"));
const SumClosure = /* @__PURE__ */ C.makeClosure((l, r) => `${l}${r}`);
const SumIdentity = /* @__PURE__ */ I.makeIdentity("", SumClosure.combine);
const Equal = /* @__PURE__ */ Eq.strict();
function isString(u) {
  return typeof u === "string";
}
function isEmpty(s) {
  return s === "";
}
function includes_(s, substr) {
  return s.includes(substr);
}
function includes(substr) {
  return (s) => s.includes(substr);
}
function startsWith_(s, substr) {
  return s.startsWith(substr);
}
function startsWith(substr) {
  return (s) => startsWith_(s, substr);
}
function endsWith_(s, substr) {
  return s.endsWith(substr);
}
function endsWith(substr) {
  return (s) => endsWith_(s, substr);
}
const empty = "";
function fromNumber(x) {
  return String(x);
}
function trim(s) {
  return s.trim();
}
function trimLeft(s) {
  return s.trimStart();
}
function trimRight(s) {
  return s.trimEnd();
}
function prepend_(s, prepend2) {
  return prepend2 + s;
}
function prepend(prepend2) {
  return (s) => prepend2 + s;
}
function unprepend_(s, s1) {
  return s.startsWith(s1) ? s.substr(s1.length) : s;
}
function unprepend(s1) {
  return (s) => unprepend_(s, s1);
}
function append_(s, x) {
  return s + x;
}
function append(x) {
  return (s) => s + x;
}
function unappend_(s, x) {
  return s.endsWith(x) ? s.substring(0, s.lastIndexOf(x)) : s;
}
function unappend(x) {
  return (s) => unappend_(s, x);
}
function surround_(s, x) {
  return append(x)(prepend(x)(s));
}
function surround(x) {
  return (s) => surround_(s, x);
}
function unsurround_(s, x) {
  return s.startsWith(x) && s.endsWith(x) ? unappend(x)(unprepend(x)(s)) : s;
}
function unsurround(x) {
  return (s) => unsurround_(s, x);
}
function slice_(s, start, end) {
  return s.slice(start, end);
}
function slice(start, end) {
  return (s) => s.slice(start, end);
}
function takeLeft_(s, n) {
  return s.slice(0, Math.max(n, 0));
}
function takeLeft(n) {
  return (s) => takeLeft_(s, n);
}
function takeRight_(s, n) {
  return s.slice(Math.max(0, s.length - Math.floor(n)), Infinity);
}
function takeRight(n) {
  return (s) => takeRight_(s, n);
}
function match_(s, r) {
  return O.fromNullable(s.match(r));
}
function match(r) {
  return (s) => match_(s, r);
}
function matchAll_(s, r) {
  return O.chain_(O.fromNullable(s.matchAll(r)), (x) => NA.fromArray(A.from(x)));
}
function matchAll(r) {
  return (s) => matchAll_(s, r);
}
function split_(s, on) {
  return s.split(on);
}
function split(on) {
  return (s) => s.split(on);
}
function under_(s, f) {
  return A.join_(f(split("")(s)), "");
}
function under(f) {
  return (s) => under_(s, f);
}
function reverse(s) {
  return under_(s, A.reverse);
}
function lines(s) {
  return split_(s, /\r\n|\r|\n/);
}
function unlines(as) {
  return A.join_(as, "\n");
}
function test_(s, r) {
  return r.test(s);
}
function test(r) {
  return (s) => r.test(s);
}
function replace_(s, test2, r) {
  return s.replace(test2, r);
}
function replace(test2, r) {
  return (s) => s.replace(test2, r);
}
class LinesIterator {
  constructor(s, stripped = false) {
    this.s = s;
    this.stripped = stripped;
    this.index = 0;
    this.length = s.length;
  }
  next() {
    if (this.done()) {
      return {
        done: true,
        value: void 0
      };
    }
    const start = this.index;
    while (!this.done() && !this.isLineBreak(this.s[this.index])) {
      this.index = this.index + 1;
    }
    let end = this.index;
    if (!this.done()) {
      const char = this.s[this.index];
      this.index = this.index + 1;
      if (!this.done() && this.isLineBreak2(char, this.s[this.index])) {
        this.index = this.index + 1;
      }
      if (!this.stripped) {
        end = this.index;
      }
    }
    return {
      done: false,
      value: this.s.substring(start, end)
    };
  }
  [Symbol.iterator]() {
    return new LinesIterator(this.s, this.stripped);
  }
  done() {
    return this.index >= this.length;
  }
  isLineBreak(char) {
    const code = char.charCodeAt(0);
    return code === LinesIterator.CR || code === LinesIterator.LF;
  }
  isLineBreak2(char0, char1) {
    return char0.charCodeAt(0) === LinesIterator.CR && char1.charCodeAt(0) === LinesIterator.LF;
  }
}
LinesIterator.CR = 13;
LinesIterator.LF = 10;
function linesSeparated(s, stripped) {
  return new LinesIterator(s, stripped);
}
function linesIterator(s) {
  return linesSeparated(s, true);
}
function linesWithSeparators(s) {
  return linesSeparated(s, false);
}
function stripMargin(str) {
  return stripMarginWith_(str, "|");
}
function stripMarginWith_(str, marginChar) {
  let out = "";
  for (const line of linesWithSeparators(str)) {
    let index = 0;
    while (index < line.length && line.charAt(index) <= " ") {
      index += 1;
    }
    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;
    out += stripped;
  }
  return out;
}
function stripMarginWith(marginChar) {
  return (str) => stripMarginWith_(str, marginChar);
}
function toUpperCase(str) {
  return str.toUpperCase();
}
function toLowerCase(str) {
  return str.toLowerCase();
}
module.exports = __toCommonJS(String_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Equal,
  LinesIterator,
  SumClosure,
  SumIdentity,
  append,
  append_,
  empty,
  endsWith,
  endsWith_,
  fromNumber,
  includes,
  includes_,
  isEmpty,
  isString,
  lines,
  linesIterator,
  linesWithSeparators,
  match,
  matchAll,
  matchAll_,
  match_,
  prepend,
  prepend_,
  replace,
  replace_,
  reverse,
  slice,
  slice_,
  split,
  split_,
  startsWith,
  startsWith_,
  stripMargin,
  stripMarginWith,
  stripMarginWith_,
  surround,
  surround_,
  takeLeft,
  takeLeft_,
  takeRight,
  takeRight_,
  test,
  test_,
  toLowerCase,
  toUpperCase,
  trim,
  trimLeft,
  trimRight,
  unappend,
  unappend_,
  under,
  under_,
  unlines,
  unprepend,
  unprepend_,
  unsurround,
  unsurround_
});
