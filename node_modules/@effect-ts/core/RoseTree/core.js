var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var core_exports = {};
__export(core_exports, {
  Applicative: () => Applicative,
  Foldable: () => Foldable,
  ForEach: () => ForEach,
  Monad: () => Monad,
  ap: () => ap,
  apFirst: () => apFirst,
  apFirst_: () => apFirst_,
  apSecond: () => apSecond,
  apSecond_: () => apSecond_,
  ap_: () => ap_,
  bind: () => bind,
  chain: () => chain,
  chain_: () => chain_,
  do: () => do_,
  drawForest: () => drawForest,
  drawTree: () => drawTree,
  duplicate: () => duplicate,
  elem: () => elem,
  elem_: () => elem_,
  extend: () => extend,
  extend_: () => extend_,
  extract: () => extract,
  flatten: () => flatten,
  fold: () => fold,
  foldMap: () => foldMap,
  foldMap_: () => foldMap_,
  forEachF: () => forEachF,
  gen: () => gen,
  getEqual: () => getEqual,
  getShow: () => getShow,
  if: () => branch,
  if_: () => branch_,
  make: () => make,
  map: () => map,
  map_: () => map_,
  match: () => match,
  matchIn: () => matchIn,
  matchMorph: () => matchMorph,
  matchTag: () => matchTag,
  matchTagIn: () => matchTagIn,
  of: () => of,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  reduceRight_: () => reduceRight_,
  reduce_: () => reduce_,
  sequence: () => sequence,
  struct: () => struct,
  tap: () => tap,
  tap_: () => tap_,
  tuple: () => tuple,
  unfoldForest: () => unfoldForest,
  unfoldForestM: () => unfoldForestM,
  unfoldForestSafe: () => unfoldForestSafe,
  unfoldTree: () => unfoldTree,
  unfoldTreeM: () => unfoldTreeM,
  unfoldTreeSafe: () => unfoldTreeSafe
});
var A = __toESM(require("../Collections/Immutable/Array/index.js"));
var import_Equal = require("../Equal/index.js");
var import_Function = require("../Function/index.js");
var IO = __toESM(require("../IO/index.js"));
var DSL = __toESM(require("../Prelude/DSL/index.js"));
var import_DSL = require("../Prelude/DSL/index.js");
var P = __toESM(require("../Prelude/index.js"));
var import_Prelude = require("../Prelude/index.js");
function make(value, forest = A.empty()) {
  return {
    value,
    forest
  };
}
function getShow(S) {
  function showSafe(t) {
    if (t.forest === A.empty() || t.forest.length === 0) {
      return IO.succeed(`make(${S.show(t.value)})`);
    }
    return IO.map_(IO.forEachArray(showSafe)(t.forest), (forest) => `make(${S.show(t.value)}, [${forest.join(", ")}])`);
  }
  return {
    show: (x) => IO.run(showSafe(x))
  };
}
function getEqual(E) {
  function equalsForestSafe(x, y, i = 0) {
    if (i === x.length) {
      return IO.succeed(true);
    }
    return IO.chain_(IO.suspend(() => equalsSafe(x[i], y[i])), (b) => b ? equalsForestSafe(x, y, i + 1) : IO.succeed(false));
  }
  function equalsSafe(x, y) {
    return !E.equals(x.value, y.value) ? IO.succeed(false) : x.forest.length !== y.forest.length ? IO.succeed(false) : equalsForestSafe(x.forest, y.forest);
  }
  return (0, import_Equal.makeEqual)((x, y) => IO.run(equalsSafe(x, y)));
}
function draw(indentation, forest) {
  return IO.gen(function* (_) {
    let r = "";
    const len = forest.length;
    let tree;
    for (let i = 0; i < len; i++) {
      tree = forest[i];
      const isLast = i === len - 1;
      r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
      r += yield* _(draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest));
    }
    return r;
  });
}
function drawForest(forest) {
  return IO.run(draw("\n", forest));
}
function drawTree(tree) {
  return tree.value + drawForest(tree.forest);
}
function unfoldTree(b, f) {
  return IO.run(unfoldTreeSafe(b, f));
}
function unfoldTreeSafe(b, f) {
  const [a, bs] = f(b);
  return IO.map_(IO.suspend(() => unfoldForestSafe(bs, f)), (forest) => ({
    value: a,
    forest
  }));
}
function unfoldForest(bs, f) {
  return IO.run(unfoldForestSafe(bs, f));
}
function unfoldForestSafe(bs, f) {
  return IO.forEachArray((b) => unfoldTreeSafe(b, f))(bs);
}
function unfoldTreeM(M) {
  const unfoldForestMM = unfoldForestM(M);
  const chain2 = DSL.chainF(M);
  const succeed = DSL.succeedF(M);
  return (b, f) => chain2(([a, bs]) => chain2((ts) => succeed({
    value: a,
    forest: ts
  }))(unfoldForestMM(bs, f)))(f(b));
}
function unfoldForestM(M) {
  const traverseM = A.forEachF(M);
  return (bs, f) => traverseM((b) => unfoldTreeM(M)(b, f))(bs);
}
function elem_(E) {
  function goForest(forest, a, i = 0) {
    if (i === forest.length) {
      return IO.succeed(false);
    }
    return IO.chain_(IO.suspend(() => go(forest[i], a)), (b) => b ? IO.succeed(true) : goForest(forest, a, i + 1));
  }
  function go(fa, a) {
    if (E.equals(a, fa.value)) {
      return IO.succeed(true);
    }
    return IO.suspend(() => goForest(fa.forest, a));
  }
  return (fa, a) => IO.run(go(fa, a));
}
function elem(E) {
  const el = elem_(E);
  return (a) => (fa) => el(fa, a);
}
function fold(f) {
  function go(tree) {
    return IO.map_(IO.forEachArray(go)(tree.forest), (bs) => f(tree.value, bs));
  }
  return (tree) => IO.run(go(tree));
}
function map_(fa, f) {
  function go(node) {
    return IO.map_(IO.forEachArray(go)(node.forest), (forest) => ({
      value: f(node.value),
      forest
    }));
  }
  return IO.run(go(fa));
}
function of(a) {
  return {
    value: a,
    forest: A.empty()
  };
}
function ap_(fab, fa) {
  return chain_(fab, (f) => map_(fa, f));
}
function chain_(fa, f) {
  function go(node) {
    const {
      forest,
      value
    } = f(node.value);
    return IO.map_(IO.forEachArray(go)(node.forest), (x) => ({
      value,
      forest: [...forest, ...x]
    }));
  }
  return IO.run(go(fa));
}
function reduce_(fa, b, f) {
  function go(node, b2) {
    return IO.gen(function* (_) {
      let r = f(b2, node.value);
      const len = fa.forest.length;
      for (let i = 0; i < len; i++) {
        r = yield* _(go(node.forest[i], r));
      }
      return r;
    });
  }
  return IO.run(go(fa, b));
}
function foldMap_(M) {
  return (fa, f) => reduce_(fa, M.identity, (acc, a) => M.combine(acc, f(a)));
}
function reduceRight_(fa, b, f) {
  function go(node, b2) {
    return IO.gen(function* (_) {
      let r = b2;
      const len = node.forest.length;
      for (let i = len - 1; i >= 0; i--) {
        r = yield* _(go(node.forest[i], r));
      }
      return f(node.value, r);
    });
  }
  return IO.run(go(fa, b));
}
const forEachF = /* @__PURE__ */ P.implementForEachF()((_) => (G) => {
  const traverseF = A.forEachF(G);
  const r = (f) => (ta) => DSL.apF(G)(traverseF((t) => r(f)(t))(ta.forest))(G.map((value) => (forest) => ({
    value,
    forest
  }))(f(ta.value)));
  return r;
});
const ForEach = {
  forEachF,
  map
};
const sequence = /* @__PURE__ */ (0, import_Prelude.sequenceF)(ForEach);
function extract(wa) {
  return wa.value;
}
function extend_(wa, f) {
  function go(node) {
    return IO.map_(IO.forEachArray(go)(node.forest), (forest) => ({
      value: f(node),
      forest
    }));
  }
  return IO.run(go(wa));
}
function extend(f) {
  return (ma) => extend_(ma, f);
}
function ap(fa) {
  return (fab) => ap_(fab, fa);
}
function apFirst(fb) {
  return (fa) => ap_(map_(fa, (a) => () => a), fb);
}
function apFirst_(fa, fb) {
  return ap_(map_(fa, (a) => () => a), fb);
}
function apSecond(fb) {
  return (fa) => ap_(map_(fa, () => (b) => b), fb);
}
function apSecond_(fa, fb) {
  return ap_(map_(fa, () => (b) => b), fb);
}
function chain(f) {
  return (ma) => chain_(ma, f);
}
function tap(f) {
  return (ma) => chain_(ma, (x) => map_(f(x), () => x));
}
function tap_(ma, f) {
  return chain_(ma, (x) => map_(f(x), () => x));
}
function duplicate(ma) {
  return extend_(ma, (x) => x);
}
function flatten(mma) {
  return chain_(mma, (x) => x);
}
function foldMap(M) {
  return (f) => (fa) => foldMap_(M)(fa, f);
}
function map(f) {
  return (fa) => map_(fa, f);
}
function reduce(b, f) {
  return (fa) => reduce_(fa, b, f);
}
function reduceRight(b, f) {
  return (fa) => reduceRight_(fa, b, f);
}
const Foldable = {
  foldMap,
  reduce,
  reduceRight
};
const Monad = {
  any: () => of({}),
  flatten,
  map
};
const Applicative = /* @__PURE__ */ (0, import_DSL.getApplicativeF)(Monad);
const gen = /* @__PURE__ */ DSL.genF(Monad);
const bind = /* @__PURE__ */ DSL.bindF(Monad);
const do_ = /* @__PURE__ */ DSL.doF(Monad);
const struct = /* @__PURE__ */ DSL.structF(Applicative);
const tuple = /* @__PURE__ */ DSL.tupleF(Applicative);
const {
  match,
  matchIn,
  matchMorph,
  matchTag,
  matchTagIn
} = /* @__PURE__ */ DSL.matchers(Monad);
const branch = /* @__PURE__ */ DSL.conditionalF(Monad);
const branch_ = /* @__PURE__ */ DSL.conditionalF_(Monad);
module.exports = __toCommonJS(core_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Applicative,
  Foldable,
  ForEach,
  Monad,
  ap,
  apFirst,
  apFirst_,
  apSecond,
  apSecond_,
  ap_,
  bind,
  chain,
  chain_,
  do: null,
  drawForest,
  drawTree,
  duplicate,
  elem,
  elem_,
  extend,
  extend_,
  extract,
  flatten,
  fold,
  foldMap,
  foldMap_,
  forEachF,
  gen,
  getEqual,
  getShow,
  if: null,
  if_,
  make,
  map,
  map_,
  match,
  matchIn,
  matchMorph,
  matchTag,
  matchTagIn,
  of,
  reduce,
  reduceRight,
  reduceRight_,
  reduce_,
  sequence,
  struct,
  tap,
  tap_,
  tuple,
  unfoldForest,
  unfoldForestM,
  unfoldForestSafe,
  unfoldTree,
  unfoldTreeM,
  unfoldTreeSafe
});
