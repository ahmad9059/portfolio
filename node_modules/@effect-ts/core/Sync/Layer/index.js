var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var Layer_exports = {};
__export(Layer_exports, {
  All: () => All,
  Both: () => Both,
  Fresh: () => Fresh,
  From: () => From,
  Of: () => Of,
  Suspended: () => Suspended,
  SyncLayer: () => SyncLayer,
  Using: () => Using,
  all: () => all,
  and: () => and,
  andTo: () => andTo,
  fresh: () => fresh,
  from: () => from,
  fromFunction: () => fromFunction,
  fromRawSync: () => fromRawSync,
  fromSync: () => fromSync,
  fromValue: () => fromValue,
  getMemoOrElseCreate: () => getMemoOrElseCreate,
  provideSyncLayer: () => provideSyncLayer,
  suspended: () => suspended,
  to: () => to,
  using: () => using
});
var import_Operator = require("../../Operator/index.js");
var import_Effect = require("@effect-ts/system/Effect");
var import_AtomicReference = require("@effect-ts/system/Support/AtomicReference");
var A = __toESM(require("../../Collections/Immutable/Array/index.js"));
var import_Function = require("../../Function/index.js");
var Sy = __toESM(require("../_internal/index.js"));
class SyncLayer {
  constructor() {
    this.hash = new import_AtomicReference.AtomicReference(Symbol());
  }
  setKey(key) {
    this.hash.set(key);
    return this;
  }
  ["+++"](that) {
    return new Both(this, that);
  }
  ["<<<"](that) {
    return new From(that, this);
  }
  [">>>"](that) {
    return new From(this, that);
  }
  ["<+<"](that) {
    return new Using(that, this);
  }
  [">+>"](that) {
    return new Using(this, that);
  }
  build() {
    const scope = () => this.scope();
    return Sy.gen(function* (_) {
      const memo = yield* _(Sy.succeedWith(() => /* @__PURE__ */ new Map()));
      const scoped = yield* _(scope());
      return yield* _(scoped(memo));
    });
  }
}
class Of extends SyncLayer {
  constructor(sync) {
    super();
    this.sync = sync;
    this._tag = "FromSync";
  }
  scope() {
    return Sy.succeed((_) => this.sync);
  }
}
class Fresh extends SyncLayer {
  constructor(sync) {
    super();
    this.sync = sync;
    this._tag = "Fresh";
  }
  scope() {
    return Sy.succeed((_) => this.sync.build());
  }
}
class Suspended extends SyncLayer {
  constructor(sync) {
    super();
    this.sync = sync;
    this._tag = "Suspended";
  }
  scope() {
    return Sy.succeed(getMemoOrElseCreate(this.sync()));
  }
}
class Both extends SyncLayer {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this._tag = "Both";
  }
  scopeBoth(self) {
    return Sy.succeed((map) => Sy.gen(function* (_) {
      const l = yield* _(getMemoOrElseCreate(self.left)(map));
      const r = yield* _(getMemoOrElseCreate(self.right)(map));
      return __spreadValues(__spreadValues({}, l), r);
    }));
  }
  scope() {
    return this.scopeBoth(this);
  }
}
class Using extends SyncLayer {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this._tag = "Using";
  }
  scope() {
    return Sy.succeed((_) => Sy.chain_(getMemoOrElseCreate(this.left)(_), (l) => Sy.provide(l)(Sy.map_(getMemoOrElseCreate(this.right)(_), (r) => __spreadValues(__spreadValues({}, l), r)))));
  }
}
class From extends SyncLayer {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this._tag = "From";
  }
  scope() {
    return Sy.succeed((_) => Sy.chain_(getMemoOrElseCreate(this.left)(_), (l) => Sy.provide(l)(getMemoOrElseCreate(this.right)(_))));
  }
}
class All extends SyncLayer {
  constructor(layers) {
    super();
    this.layers = layers;
    this._tag = "All";
  }
  scope() {
    return Sy.succeed((_) => A.reduce_(this.layers, Sy.succeed({}), (b, a) => Sy.chain_(getMemoOrElseCreate(a)(_), (x) => Sy.map_(b, (k) => __spreadValues(__spreadValues({}, k), x)))));
  }
}
function getMemoOrElseCreate(layer) {
  return (m) => Sy.gen(function* (_) {
    const inMap = yield* _(Sy.succeedWith(() => m.get(layer.hash.get)));
    if (inMap) {
      return yield* _(Sy.succeed(inMap));
    } else {
      return yield* _(Sy.gen(function* (_2) {
        const f = yield* _2(layer.scope());
        const a = yield* _2(f(m));
        yield* _2(Sy.succeedWith(() => {
          m.set(layer.hash.get, a);
        }));
        return a;
      }));
    }
  });
}
function fromRawSync(_) {
  return new Of(_);
}
function fresh(layer) {
  return new Fresh(layer);
}
function suspended(layer) {
  return new Suspended(layer);
}
function fromSync(tag) {
  return (_) => new Of(Sy.map_(_, tag.has));
}
function fromFunction(tag) {
  return (_) => new Of(Sy.map_(Sy.access(_), tag.has));
}
function fromValue(tag) {
  return (_) => new Of(Sy.succeed(tag.has(_)));
}
function and(left) {
  return (right) => new Both(left, right);
}
function andTo(left) {
  return (right) => new Using(right, left);
}
function to(left) {
  return (right) => new From(right, left);
}
function using(left) {
  return (right) => new Using(left, right);
}
function from(left) {
  return (right) => new From(left, right);
}
function provideSyncLayer(layer) {
  return (_) => Sy.chain_(layer.build(), (a) => Sy.provide(a)(_));
}
function all(...ls) {
  return new All(ls);
}
module.exports = __toCommonJS(Layer_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  All,
  Both,
  Fresh,
  From,
  Of,
  Suspended,
  SyncLayer,
  Using,
  all,
  and,
  andTo,
  fresh,
  from,
  fromFunction,
  fromRawSync,
  fromSync,
  fromValue,
  getMemoOrElseCreate,
  provideSyncLayer,
  suspended,
  to,
  using
});
